<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HelloWorld</title>
  
  
  <link href="http://universeinheart.github.io/atom.xml" rel="self"/>
  
  <link href="http://universeinheart.github.io/"/>
  <updated>2021-05-16T09:09:13.687Z</updated>
  <id>http://universeinheart.github.io/</id>
  
  <author>
    <name>xjf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>08.Web 进阶开发</title>
    <link href="http://universeinheart.github.io/2021/05/17/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/08/"/>
    <id>http://universeinheart.github.io/2021/05/17/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/08/</id>
    <published>2021-05-17T15:28:37.000Z</published>
    <updated>2021-05-16T09:09:13.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计好的-RESTful-Web-Service"><a href="#设计好的-RESTful-Web-Service" class="headerlink" title="设计好的 RESTful Web Service"></a>设计好的 RESTful Web Service</h2><h2 id="什么是-HATEOAS"><a href="#什么是-HATEOAS" class="headerlink" title="什么是 HATEOAS"></a>什么是 HATEOAS</h2><h2 id="使⽤-Spring-Data-REST-实现简单的超媒体服务"><a href="#使⽤-Spring-Data-REST-实现简单的超媒体服务" class="headerlink" title="使⽤ Spring Data REST 实现简单的超媒体服务"></a>使⽤ Spring Data REST 实现简单的超媒体服务</h2><h2 id="分布式环境中如何解决-Session-的问题"><a href="#分布式环境中如何解决-Session-的问题" class="headerlink" title="分布式环境中如何解决 Session 的问题"></a>分布式环境中如何解决 Session 的问题</h2><h2 id="使⽤-WebFlux-代替-Spring-MVC"><a href="#使⽤-WebFlux-代替-Spring-MVC" class="headerlink" title="使⽤ WebFlux 代替 Spring MVC"></a>使⽤ WebFlux 代替 Spring MVC</h2>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="Web" scheme="http://universeinheart.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>07.Web 资源</title>
    <link href="http://universeinheart.github.io/2021/05/17/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/07/"/>
    <id>http://universeinheart.github.io/2021/05/17/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/07/</id>
    <published>2021-05-17T15:27:37.000Z</published>
    <updated>2021-05-16T09:07:51.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过-RestTemplate-访问-Web-资源"><a href="#通过-RestTemplate-访问-Web-资源" class="headerlink" title="通过 RestTemplate 访问 Web 资源"></a>通过 RestTemplate 访问 Web 资源</h2><h2 id="RestTemplate-的⾼阶⽤法"><a href="#RestTemplate-的⾼阶⽤法" class="headerlink" title="RestTemplate 的⾼阶⽤法"></a>RestTemplate 的⾼阶⽤法</h2><h2 id="简单定制-RestTemplate"><a href="#简单定制-RestTemplate" class="headerlink" title="简单定制 RestTemplate"></a>简单定制 RestTemplate</h2><h2 id="通过-WebClient-访问-Web-资源"><a href="#通过-WebClient-访问-Web-资源" class="headerlink" title="通过 WebClient 访问 Web 资源"></a>通过 WebClient 访问 Web 资源</h2>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="Web" scheme="http://universeinheart.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>06.Web</title>
    <link href="http://universeinheart.github.io/2021/05/17/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/06/"/>
    <id>http://universeinheart.github.io/2021/05/17/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/06/</id>
    <published>2021-05-17T15:26:37.000Z</published>
    <updated>2021-05-16T09:04:25.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-MVC-实践"><a href="#Spring-MVC-实践" class="headerlink" title="Spring MVC 实践"></a>Spring MVC 实践</h2><h2 id="理解-Spring-的应⽤上下⽂"><a href="#理解-Spring-的应⽤上下⽂" class="headerlink" title="理解 Spring 的应⽤上下⽂"></a>理解 Spring 的应⽤上下⽂</h2><h2 id="Spring-MVC-中的各种机制"><a href="#Spring-MVC-中的各种机制" class="headerlink" title="Spring MVC 中的各种机制"></a>Spring MVC 中的各种机制</h2><h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><h3 id="视图处理"><a href="#视图处理" class="headerlink" title="视图处理"></a>视图处理</h3><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h2 id="如何定义处理⽅法"><a href="#如何定义处理⽅法" class="headerlink" title="如何定义处理⽅法"></a>如何定义处理⽅法</h2><h2 id="Spring-MVC-中的常⽤视图"><a href="#Spring-MVC-中的常⽤视图" class="headerlink" title="Spring MVC 中的常⽤视图"></a>Spring MVC 中的常⽤视图</h2><h2 id="静态资源与缓存"><a href="#静态资源与缓存" class="headerlink" title="静态资源与缓存"></a>静态资源与缓存</h2><h2 id="了解-Spring-MVC-的切⼊点"><a href="#了解-Spring-MVC-的切⼊点" class="headerlink" title="了解 Spring MVC 的切⼊点"></a>了解 Spring MVC 的切⼊点</h2>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="Web" scheme="http://universeinheart.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>05.数据访问进阶</title>
    <link href="http://universeinheart.github.io/2021/05/16/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/05/"/>
    <id>http://universeinheart.github.io/2021/05/16/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/05/</id>
    <published>2021-05-16T15:26:37.000Z</published>
    <updated>2021-05-16T09:01:42.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reactor-核⼼的概念"><a href="#Reactor-核⼼的概念" class="headerlink" title="Reactor 核⼼的概念"></a>Reactor 核⼼的概念</h2><p><strong>Operators - Publisher / Subscriber</strong></p><ul><li>Nothing Happens Until You subscribe()</li><li><code>Flux</code> [ 0..N ] - onNext()、onComplete()、onError()</li><li><code>Mono</code> [ 0..1 ] - onNext()、onComplete()、onError()</li></ul><p><strong>Backpressure</strong></p><ul><li>Subscription</li><li>onRequest()、onCancel()、onDispose()</li></ul><p><strong>线程调度Schedulers</strong></p><ul><li>immediate() / single() / newSingle()</li><li>elastic() / parallel() / newParallel() </li></ul><p><strong>错误处理</strong> </p><ul><li>onError / onErrorReturn / onErrorResume</li><li>doOnError / doFinally</li></ul><h2 id="通过-Reactive-的⽅式访问"><a href="#通过-Reactive-的⽅式访问" class="headerlink" title="通过 Reactive 的⽅式访问"></a>通过 Reactive 的⽅式访问</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><strong>Lettuce 能够⽀持 Reactive ⽅式</strong></p><p><strong>Spring Data Redis 中主要的⽀持</strong></p><ul><li>ReactiveRedisConnection</li><li>ReactiveRedisConnectionFactory</li><li>ReactiveRedisTemplate</li></ul><h2 id="通过-AOP-打印数据访问层摘要"><a href="#通过-AOP-打印数据访问层摘要" class="headerlink" title="通过 AOP 打印数据访问层摘要"></a>通过 AOP 打印数据访问层摘要</h2><img src="/2021/05/16/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/05/image-20210516161410468.png" class="" title="image-20210516161410468"><p><strong>Spring事务实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableTransactionManagement</span><br><span class="line"></span><br><span class="line">ProxyTransactionManagementConfiguration</span><br><span class="line"></span><br><span class="line">TransactionInterceptor</span><br><span class="line"></span><br><span class="line">org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction</span><br></pre></td></tr></table></figure><p><strong>常⽤注解</strong></p><ul><li>@EnableAspectJAutoProxy</li><li>@Aspect</li><li>@Pointcut</li><li>@Before</li><li>@After / @AfterReturning / @AfterThrowing</li><li>@Around</li><li>@Order</li></ul>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://universeinheart.github.io/tags/SpringBoot/"/>
    
    <category term="JDBC" scheme="http://universeinheart.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>03.NoSQL 实践</title>
    <link href="http://universeinheart.github.io/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/"/>
    <id>http://universeinheart.github.io/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/</id>
    <published>2021-05-13T15:26:37.000Z</published>
    <updated>2021-05-15T16:20:51.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过-Docker-辅助开发"><a href="#通过-Docker-辅助开发" class="headerlink" title="通过 Docker 辅助开发"></a>通过 Docker 辅助开发</h2><h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234130722.png" class="" title="image-20210513234130722"><h3 id="认识-Docker"><a href="#认识-Docker" class="headerlink" title="认识 Docker"></a>认识 Docker</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234119641.png" class="" title="image-20210513234119641"><h3 id="Docker-常⽤命令"><a href="#Docker-常⽤命令" class="headerlink" title="Docker 常⽤命令"></a>Docker 常⽤命令</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234104049.png" class="" title="image-20210513234104049"><h3 id="docker-run-的常⽤选项"><a href="#docker-run-的常⽤选项" class="headerlink" title="docker run 的常⽤选项"></a>docker run 的常⽤选项</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234032281.png" class="" title="image-20210513234032281"><h3 id="国内-Docker-镜像配置"><a href="#国内-Docker-镜像配置" class="headerlink" title="国内 Docker 镜像配置"></a>国内 Docker 镜像配置</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234048018.png" class="" title="image-20210513234048018"><h3 id="通过-Docker-启动-Redis"><a href="#通过-Docker-启动-Redis" class="headerlink" title="通过 Docker 启动 Redis"></a>通过 Docker 启动 Redis</h3><p><strong>官⽅指引</strong></p><ul><li><a href="https://hub.docker.com/_/redis">https://hub.docker.com/_/redis</a> </li></ul><p><strong>获取镜像</strong></p><ul><li>docker pull redis </li></ul><p><strong>启动 Redis</strong></p><ul><li>docker run –name redis -d -p 6379:6379 redis</li></ul><h2 id="在-Spring-中访问-Redis"><a href="#在-Spring-中访问-Redis" class="headerlink" title="在 Spring 中访问 Redis"></a>在 Spring 中访问 Redis</h2><ul><li>⽀持的客户端 <code>Jedis</code> / <code>Lettuce</code></li><li><code>RedisTemplate</code></li><li><code>Repository</code> ⽀持</li></ul><p><strong>Jedis 客户端</strong></p><ul><li><code>Jedis</code> 不是线程安全的</li><li>通过 <code>JedisPool</code> 获得 <code>Jedis</code> 实例</li><li>直接使⽤ <code>Jedis</code> 中的⽅法</li></ul><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210515122625375.png" class="" title="image-20210515122625375"><p><strong>Lettuce 客户端</strong></p><p>目前主流推荐驱动，基于Netty NIO，API线程安全</p><p><strong>Redission 客户端</strong></p><p>基于Netty NIO，API线程安全,大量分布式功能特性，JUC线程安全集合和工具的安全的分布式版本，分布式的数据结构和锁</p><h2 id="Redis-的哨兵与集群模式"><a href="#Redis-的哨兵与集群模式" class="headerlink" title="Redis 的哨兵与集群模式"></a>Redis 的哨兵与集群模式</h2><p><code>Redis Sentinel</code> 是 <code>Redis</code> 的⼀种⾼可⽤⽅案</p><ul><li>监控、通知、⾃动故障转移、服务发现</li></ul><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210515170904613.png" class="" title="image-20210515170904613"><p><code>JedisSentinelPool</code> </p><ul><li>继承  Pool</li><li>HostAndPort initSentinels(Set<String> sentinels, final String masterName) <ul><li>遍历sentinels 找到master</li><li>遍历sentinels 为每个sentinel增加 MasterListener，以便后面做切换</li></ul></li><li>initPool</li></ul><p>Redis Cluster</p><ul><li>数据⾃动分⽚（分成16384个 Hash Slot ）</li><li> 在部分节点失效时有⼀定可⽤性 </li></ul><p>JedisCluster</p><ul><li>Jedis 只从 Master 读数据，如果想要⾃动读写分离，可以定制</li></ul><h2 id="了解-Spring-的缓存抽象"><a href="#了解-Spring-的缓存抽象" class="headerlink" title="了解 Spring 的缓存抽象"></a>了解 Spring 的缓存抽象</h2><h3 id="Spring-的缓存抽象"><a href="#Spring-的缓存抽象" class="headerlink" title="Spring 的缓存抽象"></a>Spring 的缓存抽象</h3><p>为不同的缓存提供⼀层抽象</p><ul><li>为 <code>Java</code> ⽅法增加缓存，缓存执⾏结果</li><li>⽀持<code>ConcurrentMap</code>、<code>EhCache</code>、<code>Caffeine</code>、<code>JCache</code>（JSR-107）</li><li>接⼝<ul><li><code>org.springframework.cache.Cache</code></li><li><code>org.springframework.cache.CacheManager</code></li></ul></li></ul><h3 id="基于注解的缓存"><a href="#基于注解的缓存" class="headerlink" title="基于注解的缓存"></a>基于注解的缓存</h3><p><strong>@EnableCaching</strong>  //  开启缓存</p><ul><li>@Cacheable</li><li>@CacheEvict </li><li>@CachePut </li><li>@Caching </li><li>@CacheConfig</li></ul><h2 id="Redis-在-Spring-中的其他⽤法"><a href="#Redis-在-Spring-中的其他⽤法" class="headerlink" title="Redis 在 Spring 中的其他⽤法"></a>Redis 在 Spring 中的其他⽤法</h2>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://universeinheart.github.io/tags/SpringBoot/"/>
    
    <category term="JDBC" scheme="http://universeinheart.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>Java 动态代理</title>
    <link href="http://universeinheart.github.io/2021/05/13/Java/000/"/>
    <id>http://universeinheart.github.io/2021/05/13/Java/000/</id>
    <published>2021-05-13T15:18:37.000Z</published>
    <updated>2021-05-13T15:36:21.747Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是字节码增强技术"><a href="#什么是字节码增强技术" class="headerlink" title="什么是字节码增强技术"></a>什么是字节码增强技术</h3><p>java字节码生成之后，**运行期 **对其进行修改，增强其功能</p><h3 id="运行期"><a href="#运行期" class="headerlink" title="运行期"></a>运行期</h3><h3 id="字节码相关技术"><a href="#字节码相关技术" class="headerlink" title="字节码相关技术"></a>字节码相关技术</h3><ul><li>动态代理</li><li>CGLIB</li><li>javassist</li><li>asm</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li>实质上动态生成字节码与反射机制结合</li><li>运行期根据不同的入参生成不同的字节码文件，继承于Proxy对象，实现传入对象的实现接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyObject</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        object=o;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),o.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalArgumentException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before invoke ...&quot;</span>);</span><br><span class="line">        Object result= method.invoke(object,args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after invoke ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理的步骤"><a href="#动态代理的步骤" class="headerlink" title="动态代理的步骤"></a>动态代理的步骤</h3><p><strong>创建一个实现 <code>InvocationHandler</code>  的类，必须实现 <code>Invoke</code> 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object proxyObject;</span><br><span class="line"></span><br><span class="line">    MyInvocationHandler(Object proxyObject) &#123;</span><br><span class="line">        <span class="keyword">this</span>.proxyObject = proxyObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before invoke ...&quot;</span> + method);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != args) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object o : args) &#123;</span><br><span class="line">                System.out.println(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Object invoke = method.invoke(proxyObject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after invoke ...&quot;</span> + method);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建被代理的类以及接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;18&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;18&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过<code>Proxy</code>的静态方法  <code>newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h) </code>创建一个代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxyObject</span><span class="params">(Object realObject)</span> </span>&#123;</span><br><span class="line">    MyInvocationHandler myInvocationHandler = <span class="keyword">new</span> MyInvocationHandler(realObject);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object proxyInstance = Proxy.newProxyInstance(</span><br><span class="line">                realObject.getClass().getClassLoader(),</span><br><span class="line">                realObject.getClass().getInterfaces(),</span><br><span class="line">                myInvocationHandler);</span><br><span class="line">        <span class="keyword">return</span> proxyInstance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过代理调用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List proxyList = (List) getProxyObject(<span class="keyword">new</span> Vector());</span><br><span class="line">proxyList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">proxyList.add(<span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是字节码增强技术&quot;&gt;&lt;a href=&quot;#什么是字节码增强技术&quot; class=&quot;headerlink&quot; title=&quot;什么是字节码增强技术&quot;&gt;&lt;/a&gt;什么是字节码增强技术&lt;/h3&gt;&lt;p&gt;java字节码生成之后，**运行期 **对其进行修改，增强其功能&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://universeinheart.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://universeinheart.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>03.O/R Mapping 实践</title>
    <link href="http://universeinheart.github.io/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/"/>
    <id>http://universeinheart.github.io/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/</id>
    <published>2021-05-11T15:26:37.000Z</published>
    <updated>2021-05-12T23:26:15.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识-Spring-Data-JPA"><a href="#认识-Spring-Data-JPA" class="headerlink" title="认识 Spring Data JPA"></a>认识 Spring Data JPA</h2><h3 id="Java-Persistence-API"><a href="#Java-Persistence-API" class="headerlink" title="Java Persistence API"></a>Java Persistence API</h3><p>JPA 为对象关系映射提供了⼀种基于 POJO 的持久化模型</p><ul><li>简化数据持久化代码的开发⼯作</li><li>为 Java 社区屏蔽不同持久化 API 的差异</li></ul><h3 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h3><p>在保留底层存储特性的同时，提供相对⼀致的、基于 Spring 的编程模型</p><p>主要模块</p><ul><li>Spring Data Commons</li><li>Spring Data JDBC</li><li><strong>Spring Data JPA</strong></li><li>Spring Data Redis</li></ul><img src="/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/image-20210511011936375.png" class="" title="image-20210511011936375"><h2 id="定义-JPA-实体对象"><a href="#定义-JPA-实体对象" class="headerlink" title="定义 JPA 实体对象"></a>定义 JPA 实体对象</h2><h3 id="常⽤-JPA-注解"><a href="#常⽤-JPA-注解" class="headerlink" title="常⽤ JPA 注解"></a>常⽤ JPA 注解</h3><p><strong>实体</strong></p><ul><li><code>@Entity</code>  注明这个类是一个实体</li><li><code>@MappedSuperclass</code> </li><li><code>@Table(name)</code>  实体和表关联</li></ul><p><strong>主键</strong></p><ul><li><code>@Id</code><ul><li><code>@GeneratedValue(strategy, generator)</code> </li><li><code>@SequenceGenerator(name, sequenceName)</code></li></ul></li></ul><img src="/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/image-20210511012943447.png" class="" title="image-20210511012943447"><p><strong>映射</strong></p><ul><li><code>@Column(name, nullable, length, insertable, updatable)</code> </li><li><code>@JoinTable(name)</code>、<code>@JoinColumn(name)</code> </li></ul><p><strong>关系</strong> </p><ul><li><code>@OneToOne</code>、<code>@OneToMany</code>、<code>@ManyToOne</code>、<code>@ManyToMany</code></li><li><code>@OrderBy</code></li></ul><h2 id="通过-Spring-Data-JPA-操作数据库"><a href="#通过-Spring-Data-JPA-操作数据库" class="headerlink" title="通过 Spring Data JPA 操作数据库"></a>通过 Spring Data JPA 操作数据库</h2><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p><code>@EnableJpaRepositories</code> 注解，自动发现 <code>Repository</code> 的扩展</p><p><strong><code>Repository</code> 接⼝</strong></p><ul><li><code>CrudRepository&lt;T,ID&gt;</code></li><li><code>PagingAndSortingRepository&lt;T,ID&gt;</code></li><li><code>JpaRepository&lt;T,ID&gt;</code></li></ul><h3 id="定义查询"><a href="#定义查询" class="headerlink" title="定义查询"></a>定义查询</h3><p>根据⽅法名定义查询</p><ul><li>find…By… / read…By… / query…By… / get…By… </li><li>count…By… </li><li>…OrderBy…[Asc / Desc] </li><li>And / Or / IgnoreCase </li><li>Top / First / Distinct</li></ul><h3 id="分⻚查询"><a href="#分⻚查询" class="headerlink" title="分⻚查询"></a>分⻚查询</h3><ul><li>PagingAndSortingRepository &lt;T, ID&gt;</li><li>Pageable / Sort </li><li>Slice / Page&lt;T, ID&gt;</li></ul><h3 id="保存实体"><a href="#保存实体" class="headerlink" title="保存实体"></a>保存实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Coffee latte = Coffee.builder().name(<span class="string">&quot;latte&quot;</span>).price(Money.of(CurrencyUnit.of(<span class="string">&quot;CNY&quot;</span>), <span class="number">30.0</span>)).build();</span><br><span class="line">coffeeRepository.save(latte);</span><br><span class="line"></span><br><span class="line">CoffeeOrder order = CoffeeOrder.builder()</span><br><span class="line">.customer(<span class="string">&quot;Li Lei&quot;</span>)</span><br><span class="line">.items(Collections.singletonList(espresso))</span><br><span class="line">.state(OrderState.INIT)</span><br><span class="line">.build();</span><br><span class="line">orderRepository.save(order);</span><br></pre></td></tr></table></figure><h3 id="查询实体"><a href="#查询实体" class="headerlink" title="查询实体"></a>查询实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseRepository</span>&lt;<span class="title">T</span>, <span class="title">Long</span>&gt; <span class="keyword">extends</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findTop3ByOrderByUpdateTimeDescIdAsc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoffeeOrderRepository</span> <span class="keyword">extends</span> <span class="title">BaseRepository</span>&lt;<span class="title">CoffeeOrder</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;CoffeeOrder&gt; <span class="title">findByCustomerOrderById</span><span class="params">(String customer)</span></span>;</span><br><span class="line">    <span class="function">List&lt;CoffeeOrder&gt; <span class="title">findByItems_Name</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">coffeeRepository.findAll(Sort.by(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>)).forEach(c -&gt; log.info(<span class="string">&quot;Loading &#123;&#125;&quot;</span>, c));</span><br><span class="line"></span><br><span class="line">List&lt;CoffeeOrder&gt; list = orderRepository.findTop3ByOrderByUpdateTimeDescIdAsc();</span><br><span class="line">log.info(<span class="string">&quot;findTop3ByOrderByUpdateTimeDescIdAsc: &#123;&#125;&quot;</span>, JSON.toJSONString(list));</span><br><span class="line"></span><br><span class="line">list = orderRepository.findByCustomerOrderById(<span class="string">&quot;Li Lei&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;findByCustomerOrderById: &#123;&#125;&quot;</span>, JSON.toJSONString(list));</span><br><span class="line"><span class="comment">// 不开启事务会因为没Session而报LazyInitializationException</span></span><br><span class="line">list.forEach(o -&gt; &#123;</span><br><span class="line">log.info(<span class="string">&quot;Order &#123;&#125;&quot;</span>, o.getId());</span><br><span class="line">o.getItems().forEach(i -&gt; log.info(<span class="string">&quot;  Item &#123;&#125;&quot;</span>, i));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">list = orderRepository.findByItems_Name(<span class="string">&quot;latte&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;findByItems_Name: &#123;&#125;&quot;</span>, JSON.toJSONString(list));</span><br></pre></td></tr></table></figure><h2 id="Repository-是怎么从接⼝变成-Bean-的"><a href="#Repository-是怎么从接⼝变成-Bean-的" class="headerlink" title="Repository 是怎么从接⼝变成 Bean 的"></a>Repository 是怎么从接⼝变成 Bean 的</h2><h3 id="Repository-Bean-是如何创建的"><a href="#Repository-Bean-是如何创建的" class="headerlink" title="Repository Bean 是如何创建的"></a>Repository Bean 是如何创建的</h3><p><strong>JpaRepositoriesRegistrar</strong></p><ul><li>激活了 <code>@EnableJpaRepositories</code></li><li>返回了 <code>JpaRepositoryConfigExtension</code> </li></ul><p><strong>RepositoryBeanDefinitionRegistrarSupport.registerBeanDefinitions</strong></p><ul><li>注册 <code>Repository Bean</code>（类型是 <code>JpaRepositoryFactoryBean</code> ） </li></ul><p><strong>RepositoryConfigurationDelegate.registerRepositoriesIn</strong></p><ul><li>注册找到的 repositories</li></ul><p><strong>RepositoryConfigurationExtensionSupport.getRepositoryConfigurations</strong> </p><ul><li>取得 <code>Repository</code> 配置 </li></ul><p><strong>JpaRepositoryFactory.getTargetRepository</strong> </p><ul><li>创建了 <code>Repository</code></li></ul><h3 id="接⼝中的⽅法是如何被解释的"><a href="#接⼝中的⽅法是如何被解释的" class="headerlink" title="接⼝中的⽅法是如何被解释的"></a>接⼝中的⽅法是如何被解释的</h3><p><strong>RepositoryFactorySupport.getRepository 添加了Advice</strong></p><ul><li><code>DefaultMethodInvokingMethodInterceptor</code></li><li><code>QueryExecutorMethodInterceptor</code></li></ul><p><strong><code>AbstractJpaQuery.execute</code> 执⾏具体的查询</strong> </p><p><strong>语法解析在 <code>Part/PartTree</code> 中</strong></p><h2 id="通过-MyBatis-操作数据库"><a href="#通过-MyBatis-操作数据库" class="headerlink" title="通过 MyBatis 操作数据库"></a>通过 MyBatis 操作数据库</h2><h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><ul><li>mybatis.mapper-locations = classpath*:mapper/**/*.xml</li><li>mybatis.type-aliases-package = 类型别名的包名</li><li>mybatis.type-handlers-package = TypeHandler扫描包名（类型转换处理器）</li><li>mybatis.configuration.map-underscore-to-camel-case = true  </li></ul><h3 id="Mapper-的定义与扫描"><a href="#Mapper-的定义与扫描" class="headerlink" title="Mapper 的定义与扫描"></a>Mapper 的定义与扫描</h3><ul><li><code>@MapperScan</code> 配置扫描位置</li><li><code>@Mapper</code> 定义接⼝</li><li>映射的定义—— XML 与注解</li></ul><img src="/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/image-20210512231958054.png" class="" title="image-20210512231958054"><h3 id="MyBatis-Generator"><a href="#MyBatis-Generator" class="headerlink" title="MyBatis Generator"></a>MyBatis Generator</h3><h3 id="MyBatis-PageHelper"><a href="#MyBatis-PageHelper" class="headerlink" title="MyBatis PageHelper"></a>MyBatis PageHelper</h3>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://universeinheart.github.io/tags/SpringBoot/"/>
    
    <category term="JDBC" scheme="http://universeinheart.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>07、复杂度来源：低成本、安全、规模</title>
    <link href="http://universeinheart.github.io/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/07/"/>
    <id>http://universeinheart.github.io/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/07/</id>
    <published>2021-05-03T12:14:59.000Z</published>
    <updated>2021-05-03T13:50:35.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="低成本"><a href="#低成本" class="headerlink" title="低成本"></a>低成本</h2><p>当我们的架构方案只涉及几台或者十几台服务器时，一般情况下成本并不是我们重点关注的目标，但如果架构方案涉及几百上千甚至上万台服务器，成本就会变成一个非常重要的架构设计考虑点。</p><p>当我们设计“高性能”“高可用”的架构时，通用的手段都是增加更多服务器来满足“高性能”和“高可用”的要求；而低成本正好与此相反，我们需要减少服务器的数量才能达成低成本的目标。因此，低成本本质上是与高性能和高可用冲突的，所以低成本很多时候不会是架构设计的首要目标，而是架构设计的附加约束。</p><p>低成本给架构设计带来的主要复杂度体现在，<strong>往往只有“创新”才能达到低成本目标</strong>。这里的“创新”既包括开创一个全新的技术领域（这个要求对绝大部分公司太高），也包括引入新技术，如果没有找到能够解决自己问题的新技术，那么就真的需要自己创造新技术了。</p><ul><li><p><code>NoSQL</code>（<code>Memcache</code>、<code>Redis</code> 等）的出现是为了解决关系型数据库无法应对高并发访问带来的访问压力。</p></li><li><p>全文搜索引擎（<code>Sphinx</code>、<code>Elasticsearch</code>、<code>Solr</code>）的出现是为了解决关系型数据库 <strong>like 搜索的低效</strong>的问题。</p></li><li><p><code>Hadoop</code> 的出现是为了解决传统文件系统无法应对海量数据存储和计算的问题。</p></li><li><p><code>Facebook</code> 为了解决 PHP 的低效问题，刚开始的解决方案是 HipHop PHP，可以将 PHP 语言翻译为 C++ 语言执行，后来改为 HHVM，将 PHP 翻译为字节码然后由虚拟机执行，和 Java 的 JVM 类似。</p></li><li><p>新浪微博将传统的 Redis/MC + MySQL 方式，扩展为 Redis/MC + SSD Cache + MySQL 方式，SSD Cache 作为 L2 缓存使用，既解决了 MC/Redis 成本过高，容量小的问题，也解决了穿透 DB 带来的数据库访问压力</p></li><li><p><code>Linkedin</code> 为了处理每天 5 千亿的事件，开发了高效的 Kafka 消息系统。</p></li><li><p>其他类似将 Ruby on Rails 改为 Java、Lua + redis 改为 Go 语言实现的例子还有很多。</p></li></ul><p>无论是引入新技术，还是自己创造新技术，都是一件复杂的事情。引入新技术的主要复杂度在于需要去熟悉新技术，并且将新技术与已有技术结合起来；创造新技术的主要复杂度在于需要自己去创造全新的理念和技术，并且新技术跟旧技术相比，需要有质的飞跃。</p><p>相比来说，创造新技术复杂度更高，因此一般中小公司基本都是靠引入新技术来达到低成本的目标；而大公司更有可能自己去创造新的技术来达到低成本的目标，因为大公司才有足够的资源、技术和时间去创造新技术。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>安全本身是一个庞大而又复杂的技术领域，并且一旦出问题，对业务和企业形象影响非常大。正因为经常能够看到或者听到各类安全事件，所以大部分技术人员和架构师，对安全这部分会多一些了解和考虑。</p><p>从技术的角度来讲，安全可以分为两类：一类是功能上的安全，一类是架构上的安全。</p><ol><li>功能安全</li></ol><p>例如，常见的 XSS 攻击、CSRF 攻击、SQL 注入、Windows 漏洞、密码破解等，本质上是因为系统实现有漏洞，黑客有了可乘之机。黑客会利用各种漏洞潜入系统，这种行为就像小偷一样，黑客和小偷的手法都是利用系统或家中不完善的地方潜入，并进行破坏或者盗取。因此形象地说，<strong>功能安全其实就是“防小偷”</strong>。</p><p>从实现的角度来看，功能安全更多地是和具体的编码相关，与架构关系不大。现在很多开发框架都内嵌了常见的安全功能，能够大大减少安全相关功能的重复开发，但框架只能预防常见的安全漏洞和风险（常见的 XSS 攻击、CSRF 攻击、SQL 注入等），无法预知新的安全问题，而且框架本身很多时候也存在漏洞（例如，流行的 Apache Struts2 就多次爆出了调用远程代码执行的高危漏洞，给整个互联网都造成了一定的恐慌）。所以功能安全是一个逐步完善的过程，而且往往都是在问题出现后才能有针对性的提出解决方案，我们永远无法预测系统下一个漏洞在哪里，也不敢说自己的系统肯定没有任何问题。换句话讲，功能安全其实也是一个“攻”与“防”的矛盾，只能在这种攻防大战中逐步完善，不可能在系统架构设计的时候一劳永逸地解决。</p><ol start="2"><li>架构安全</li></ol><p>如果说功能安全是“防小偷”，那么<strong>架构安全就是“防强盗”</strong>。强盗会直接用大锤将门砸开，或者用炸药将围墙炸倒；小偷是偷东西，而强盗很多时候就是故意搞破坏，对系统的影响也大得多。因此架构设计时需要特别关注架构安全，尤其是互联网时代，理论上来说系统部署在互联网上时，全球任何地方都可以发起攻击。</p><p>传统的架构安全主要依靠防火墙，防火墙最基本的功能就是隔离网络，通过将网络划分成不同的区域，制定出不同区域之间的<strong>访问控制策略</strong>来控制不同信任程度区域间传送的数据流。</p><p>例如，下图是一个典型的银行系统的安全架构。</p><img src="/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/07/image-20210503213404249.png" class="" title="image-20210503213404249"><p>从图中你可以看到，整个系统根据不同的分区部署了多个防火墙来保证系统的安全。</p><p>防火墙的功能虽然强大，但性能一般，所以在传统的银行和企业应用领域应用较多。但在互联网领域，防火墙的应用场景并不多。因为互联网的业务具有海量用户访问和高并发的特点，防火墙的性能不足以支撑；尤其是互联网领域的 DDoS 攻击，轻则几 GB，重则几十 GB。这种规模的攻击，如果用防火墙来防，则需要部署大量的防火墙，成本会很高。例如，中高端一些的防火墙价格 10 万元，每秒能抗住大约 25GB 流量，那么应对这种攻击就需要将近 30 台防火墙，成本将近 300 万元，这还不包括维护成本，而这些防火墙设备在没有发生攻击的时候又没有什么作用。也就是说，如果花费几百万元来买这么一套设备，有可能几年都发挥不了任何作用。</p><p>就算是公司对钱不在乎，一般也不会堆防火墙来防 DDoS 攻击，因为 DDoS 攻击最大的影响是大量消耗机房的出口总带宽。不管防火墙处理能力有多强，当出口带宽被耗尽时，整个业务在用户看来就是不可用的，因为用户的正常请求已经无法到达系统了。防火墙能够保证内部系统不受冲击，但用户也是进不来的。对于用户来说，业务都已经受到影响了，至于是因为用户自己进不去，还是因为系统出故障，用户其实根本不会关心。</p><p>基于上述原因，互联网系统的架构安全目前并没有太好的设计手段来实现，更多地是依靠运营商或者云服务商强大的带宽和流量清洗的能力，较少自己来设计和实现。</p><h2 id="规模"><a href="#规模" class="headerlink" title="规模"></a>规模</h2><p>很多企业级的系统，既没有高性能要求，也没有双中心高可用要求，也不需要什么扩展性，但往往我们一说到这样的系统，很多人都会脱口而出：这个系统好复杂！为什么这样说呢？关键就在于这样的系统往往功能特别多，逻辑分支特别多。特别是有的系统，发展时间比较长，不断地往上面叠加功能，后来的人由于不熟悉整个发展历史，可能连很多功能的应用场景都不清楚，或者细节根本无法掌握，面对的就是一个黑盒系统，看不懂、改不动、不敢改、修不了，复杂度自然就感觉很高了。</p><p><strong>规模带来复杂度的主要原因就是“量变引起质变”</strong>，当数量超过一定的阈值后，复杂度会发生质的变化。</p><p>常见的规模带来的复杂度有：</p><ol><li>功能越来越多，导致系统复杂度指数级上升</li><li>数据越来越多，系统复杂度发生质变</li></ol>]]></content>
    
    
    <summary type="html">架构</summary>
    
    
    
    <category term="从零开始学架构" scheme="http://universeinheart.github.io/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://universeinheart.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>06、复杂度来源：可扩展性</title>
    <link href="http://universeinheart.github.io/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/06/"/>
    <id>http://universeinheart.github.io/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/06/</id>
    <published>2021-05-03T11:14:59.000Z</published>
    <updated>2021-05-03T12:50:40.780Z</updated>
    
    <content type="html"><![CDATA[<p>可扩展性指系统为了<strong>应对将来需求变化</strong>而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。</p><p>在软件开发领域，面向对象思想的提出，就是为了解决可扩展性带来的问题；后来的设计模式，更是将可扩展性做到了极致。得益于设计模式的巨大影响力，几乎所有的技术人员对于可扩展性都特别重视。</p><p>设计具备良好可扩展性的系统，有两个基本条件：<strong>正确预测变化</strong>、<strong>完美封装变化</strong>。</p><h2 id="预测变化"><a href="#预测变化" class="headerlink" title="预测变化"></a>预测变化</h2><p>软件系统与硬件或者建筑相比，有一个很大的差异：软件系统在发布后还可以不断地修改和演进，这就意味着<strong>不断有新的需求需要实现</strong>。</p><blockquote><p>唯一不变的是变化</p></blockquote><p>对于架构师来说，如何把握预测的程度和提升预测结果的准确性，是一件很复杂的事情，而且没有通用的标准可以简单套上去，更多是靠自己的经验、直觉，所以架构设计评审的时候经常会出现两个设计师对某个判断争得面红耳赤的情况，原因就在于没有明确标准，不同的人理解和判断有偏差，而最终又只能选择一个判断。</p><h2 id="应对变化"><a href="#应对变化" class="headerlink" title="应对变化"></a>应对变化</h2><p>第一种应对变化的常见方案是<strong>将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”</strong>。无论是变化层依赖稳定层，还是稳定层依赖变化层都是可以的，需要根据具体业务情况来设计。</p><p>例如，如果系统需要支持 XML、JSON、ProtocolBuffer 三种接入方式，那么最终的架构就是上面图中的“形式 1”架构，也就是下面这样。</p><img src="/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/06/image-20210503202856173.png" class="" title="image-20210503202856173"><p>如果系统需要支持 MySQL、Oracle、DB2 数据库存储，那么最终的架构就变成了“形式 2”的架构了，你可以看下面这张图。</p><img src="/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/06/image-20210503202914502.png" class="" title="image-20210503202914502"><p>无论采取哪种形式，通过剥离变化层和稳定层的方式应对变化，都会带来两个主要的复杂性相关的问题。</p><ol><li>系统需要拆分出变化层和稳定层</li></ol><p>对于哪些属于变化层，哪些属于稳定层，很多时候并不是像前面的示例（不同接口协议或者不同数据库）那样明确，不同的人有不同的理解，导致架构设计评审的时候可能吵翻天。</p><ol start="2"><li>需要设计变化层和稳定层之间的接口</li></ol><p>接口设计同样至关重要，对于稳定层来说，接口肯定是越稳定越好；但对于变化层来说，在有差异的多个实现方式中找出共同点，并且还要保证当加入新的功能时原有的接口设计不需要太大修改，这是一件很复杂的事情。例如，<code>MySQL</code> 的 <code>REPLACE INTO</code> 和 <code>Oracle</code> 的 <code>MERGE INTO</code> 语法和功能有一些差异，那存储层如何向稳定层提供数据访问接口呢？是采取 MySQL 的方式，还是采取 Oracle 的方式，还是自适应判断？如果再考虑 DB2 的情况呢？相信你看到这里就已经能够大致体会到接口设计的复杂性了。</p><hr><p>第二种常见的应对变化的方案是<strong>提炼出一个“抽象层”和一个“实现层”</strong>。抽象层是稳定的，实现层可以根据具体业务需要定制开发，当加入新的功能时，只需要增加新的实现，无须修改抽象层。这种方案典型的实践就是<strong>设计模式</strong>和<strong>规则引擎</strong>。考虑到绝大部分技术人员对设计模式都非常熟悉，我以设计模式为例来说明这种方案的复杂性。</p><p>以设计模式的“<strong>装饰者</strong>”模式来分析，下面是装饰者模式的类关系图。</p><img src="/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/06/image-20210503204626263.png" class="" title="image-20210503204626263"><p>图中的 <code>Component</code> 和 <code>Decorator</code> 就是抽象出来的规则，这个规则包括几部分：</p><ol><li><code>Component</code> 和 <code>Decorator</code> 类。</li><li><code>Decorator</code> 类继承 <code>Component</code> 类</li><li><code>Decorator</code> 类聚合了 <code>Component</code> 类。</li></ol><p>这个规则一旦抽象出来后就固定了，不能轻易修改。例如，把规则 3 去掉，就无法实现装饰者模式的目的了。</p><p>装饰者模式相比传统的继承来实现功能，确实灵活很多。例如，《设计模式》中装饰者模式的样例“TextView”类的实现，用了装饰者之后，能够灵活地给 TextView 增加额外更多功能，比如可以增加边框、滚动条、背景图片等，这些功能上的组合不影响规则，只需要按照规则实现即可。但装饰者模式相对普通的类实现模式，明显要复杂多了。本来一个函数或者一个类就能搞定的事情，现在要拆分成多个类，而且多个类之间必须按照装饰者模式来设计和调用。</p><p>规则引擎和设计模式类似，都是通过灵活的设计来达到可扩展的目的，但“灵活的设计”本身就是一件复杂的事情，不说别的，光是把 23 种设计模式全部理解和备注，都是一件很困难的事情。</p>]]></content>
    
    
    <summary type="html">架构</summary>
    
    
    
    <category term="从零开始学架构" scheme="http://universeinheart.github.io/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://universeinheart.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>05、复杂度来源：高可用</title>
    <link href="http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/05/"/>
    <id>http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/05/</id>
    <published>2021-05-02T11:14:59.000Z</published>
    <updated>2021-05-03T12:20:52.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>高可用 : 系统<strong>无中断</strong>地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。</p><p><strong>高性能增加机器目的在于“扩展”处理性能；</strong></p><p><strong>高可用增加机器目的在于“冗余”处理单元</strong>。</p></blockquote><h2 id="计算高可用"><a href="#计算高可用" class="headerlink" title="计算高可用"></a>计算高可用</h2><p>这里的“计算”指的是业务的逻辑处理。计算有一个特点就是<strong>无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的</strong>，所以将计算从一台机器迁移到另外一台机器，对业务并没有什么影响。</p><img src="/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/05/image-20210503001438346.png" class="" title="image-20210503001438346"><p>高可用集群分配算法更加复杂，可以是 1 主 3 备、2 主 2 备、3 主 1 备、4 主 0 备，具体应该采用哪种方式，需要结合实际业务需求来分析和判断，并不存在某种算法就一定优于另外的算法。例如，ZooKeeper 采用的就是 1 主多备，而 Memcached 采用的就是全主 0 备。</p><h2 id="存储高可用"><a href="#存储高可用" class="headerlink" title="存储高可用"></a>存储高可用</h2><p>对于需要存储数据的系统来说，整个系统的高可用设计关键点和难点就在于“存储高可用”。存储与计算相比，有一个本质上的区别：<strong>将数据从一台机器搬到到另一台机器，需要经过线路进行传输</strong>。线路传输的速度是毫秒级别，同一机房内部能够做到几毫秒；分布在不同地方的机房，传输耗时需要几十甚至上百毫秒。例如，从广州机房到北京机房，稳定情况下 ping 延时大约是 50ms，不稳定情况下可能达到 1s 甚至更多。</p><p>虽然毫秒对于人来说几乎没有什么感觉，但是对于高可用系统来说，就是本质上的不同，这意味着整个系统在某个时间点上，数据肯定是不一致的。按照“<strong>数据 + 逻辑 = 业务</strong>”这个公式来套的话，数据不一致，即使逻辑一致，最后的业务表现就不一样了。</p><p>以最经典的银行储蓄业务为例，假设用户的数据存在北京机房，用户存入了 1 万块钱，然后他查询的时候被路由到了上海机房，北京机房的数据没有同步到上海机房，用户会发现他的余额并没有增加 1 万块。想象一下，此时用户肯定会背后一凉，马上会怀疑自己的钱被盗了，然后赶紧打客服电话投诉，甚至打 110 报警，即使最后发现只是因为传输延迟导致的问题，站在用户的角度来说，这个过程的体验肯定很不好。</p><img src="/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/05/image-20210503001623102.png" class="" title="image-20210503001623102"><p>除了物理上的传输速度限制，传输线路本身也存在可用性问题，传输线路可能中断、可能拥塞、可能异常（错包、丢包），并且传输线路的故障时间一般都特别长，短的十几分钟，长的几个小时都是可能的。例如，2015 年支付宝因为光缆被挖断，业务影响超过 4 个小时；2016 年中美海底光缆中断 3 小时等。在传输线路中断的情况下，就意味着存储无法进行同步，在这段时间内整个系统的数据是不一致的。</p><p>综合分析，无论是正常情况下的传输延迟，还是异常情况下的传输中断，都会导致系统的数据在某个时间点或者时间段是不一致的，而数据的不一致又会导致业务问题；但如果完全不做冗余，系统的整体高可用又无法保证，所以<strong>存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响</strong>。</p><p>分布式领域里面有一个著名的 <strong>CAP 定理</strong>，从理论上论证了存储高可用的复杂度。也就是说，存储高可用不可能同时满足“<strong>一致性</strong>、<strong>可用性</strong>、<strong>分区容错性</strong>”，最多满足其中两个，这就要求我们在做架构设计时结合业务进行取舍。</p><h2 id="高可用状态决策"><a href="#高可用状态决策" class="headerlink" title="高可用状态决策"></a>高可用状态决策</h2><p>无论是计算高可用还是存储高可用，其基础都是“<strong>状态决策</strong>”，即系统需要能够判断当前的状态是正常还是异常，如果出现了异常就要采取行动来保证高可用。如果状态决策本身都是有错误或者有偏差的，那么后续的任何行动和处理无论多么完美也都没有意义和价值。但在具体实践的过程中，恰好存在一个本质的矛盾：<strong>通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确</strong>。</p><p>下面我基于几种常见的决策方式进行详细分析。</p><h3 id="独裁式"><a href="#独裁式" class="headerlink" title="独裁式"></a>独裁式</h3><p>独裁式决策指的是存在一个独立的决策主体，我们姑且称它为“决策者”，负责收集信息然后进行决策；所有冗余的个体，我们姑且称它为“上报者”，都将状态信息发送给决策者。独裁式的决策方式不会出现决策混乱的问题，因为只有一个决策者，但问题也正是在于只有一个决策者。当决策者本身故障时，整个系统就无法实现准确的状态决策。如果决策者本身又做一套状态决策，那就陷入一个递归的死循环了。</p><h3 id="协商式"><a href="#协商式" class="headerlink" title="协商式"></a>协商式</h3><p>协商式决策指的是两个独立的个体通过交流信息，然后根据规则进行决策，<strong>最常用的协商式决策就是主备决策</strong>。</p><p>这个架构的基本协商规则可以设计成：</p><ul><li>2 台服务器启动时都是备机。</li><li>2 台服务器建立连接。</li><li>2 台服务器交换状态信息。</li><li>某 1 台服务器做出决策，成为主机；另一台服务器继续保持备机身份。</li></ul><p>协商式决策的架构不复杂，规则也不复杂，其难点在于，如果两者的信息交换出现问题（比如主备连接中断），此时状态决策应该怎么做。</p><ul><li>如果备机在连接中断的情况下认为主机故障，那么备机需要升级为主机，但实际上此时主机并没有故障，那么系统就出现了两个主机，这与设计初衷（1 主 1 备）是不符合的。</li><li>如果备机在连接中断的情况下不认为主机故障，则此时如果主机真的发生故障，那么系统就没有主机了，这同样与设计初衷（1 主 1 备）是不符合的。</li><li>如果为了规避连接中断对状态决策带来的影响，可以增加更多的连接。例如，双连接、三连接。这样虽然能够降低连接中断对状态带来的影响（注意：只能降低，不能彻底解决），但同时又引入了这几条连接之间信息取舍的问题，即如果不同连接传递的信息不同，应该以哪个连接为准？实际上这也是一个无解的答案，无论以哪个连接为准，在特定场景下都可能存在问题。</li></ul><h3 id="民主式"><a href="#民主式" class="headerlink" title="民主式"></a>民主式</h3><p>民主式决策指的是多个独立的个体通过投票的方式来进行状态决策。</p><p>例如，ZooKeeper 集群在选举 leader 时就是采用这种方式。</p><img src="/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/05/image-20210503002341224.png" class="" title="image-20210503002341224"><p>民主式决策和协商式决策比较类似，其基础都是独立的个体之间交换信息，每个个体做出自己的决策，然后按照“<strong>多数取胜</strong>”的规则来确定最终的状态。不同点在于民主式决策比协商式决策要复杂得多，ZooKeeper 的选举算法 Paxos，绝大部分人都看得云里雾里，更不用说用代码来实现这套算法了。</p><p>除了算法复杂，民主式决策还有一个固有的缺陷：脑裂。这个词来源于医学，指人体左右大脑半球的连接被切断后，左右脑因为无法交换信息，导致各自做出决策，然后身体受到两个大脑分别控制，会做出各种奇怪的动作。</p><p>脑裂的根本原因是，原来统一的集群因为连接中断，造成了两个独立分隔的子集群，每个子集群单独进行选举，于是选出了 2 个主机，相当于人体有两个大脑了。</p><p>为了解决脑裂问题，民主式决策的系统一般都采用“<strong>投票节点数必须超过系统总节点数一半</strong>”规则来处理。这种方式虽然解决了脑裂问题，但同时降低了系统整体的可用性，即如果系统不是因为脑裂问题导致投票节点数过少，而真的是因为节点故障，此时系统也不会选出主节点，整个系统就相当于宕机了，尽管此时还有节点 4 和节点 5 是正常的。</p>]]></content>
    
    
    <summary type="html">架构</summary>
    
    
    
    <category term="从零开始学架构" scheme="http://universeinheart.github.io/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://universeinheart.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>04、复杂度来源：高性能</title>
    <link href="http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/04/"/>
    <id>http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/04/</id>
    <published>2021-05-02T11:14:57.000Z</published>
    <updated>2021-05-02T15:24:35.040Z</updated>
    
    <content type="html"><![CDATA[<p>软件系统中高性能带来的复杂度主要体现在两方面，一方面是<strong>单台计算机内部为了高性能带来的复杂度</strong>；另一方面是<strong>多台计算机集群为了高性能带来的复杂度</strong>。</p><h2 id="单机复杂度"><a href="#单机复杂度" class="headerlink" title="单机复杂度"></a>单机复杂度</h2><p>计算机内部复杂度最关键的地方就是操作系统。计算机性能的发展本质上是由硬件发展驱动的，尤其是 CPU 的性能发展。著名的“摩尔定律”表明了 CPU 的处理能力每隔 18 个月就翻一番；而将硬件性能充分发挥出来的关键就是操作系统，所以操作系统本身其实也是跟随硬件的发展而发展的，操作系统是软件系统的运行环境，<strong>操作系统的复杂度直接决定了软件系统的复杂度</strong>。</p><p>操作系统和性能最相关的就是<strong>进程</strong>和<strong>线程</strong>。用进程来对应一个任务，每个任务都有自己独立的内存空间，进程间互不相关，由操作系统来进行调度。此时的 CPU 还没有多核和多线程的概念，为了达到多进程并行运行的目的，采取了分时的方式，即把 CPU 的时间分成很多片段，每个片段只能执行某个进程中的指令。虽然从操作系统和 CPU 的角度来说还是串行处理的，但是由于 CPU 的处理速度很快，从用户的角度来看，感觉是多进程在并行处理。</p><p>多进程虽然要求每个任务都有独立的内存空间，进程间互不相关，但从用户的角度来看，两个任务之间能够在运行过程中就进行通信，会让任务设计变得更加灵活高效。否则如果两个任务运行过程中不能通信，只能是 A 任务将结果写到存储，B 任务再从存储读取进行处理，不仅效率低，而且任务设计更加复杂。为了解决这个问题，进程间通信的各种方式被设计出来了，包括<strong>管道</strong>、<strong>消息队列</strong>、<strong>信号量</strong>、<strong>共享存储</strong>等。</p><p>多进程让多任务能够并行处理任务，但本身还有缺点，单个进程内部只能串行处理，而实际上很多进程内部的子任务并不要求是严格按照时间顺序来执行的，也需要并行处理。例如，一个餐馆管理进程，排位、点菜、买单、服务员调度等子任务必须能够并行处理，否则就会出现某个客人买单时间比较长（比如说信用卡刷不出来），其他客人都不能点菜的情况。为了解决这个问题，人们又发明了<strong>线程</strong>，线程是进程内部的子任务，但这些子任务都共享同一份进程数据。为了保证数据的正确性，又发明了互斥锁机制。<strong>有了多线程后，操作系统调度的最小单位就变成了线程，而进程变成了操作系统分配资源的最小单位。</strong></p><p>多进程多线程虽然让多任务并行处理的性能大大提升，但本质上还是分时系统，并不能做到时间上真正的并行。解决这个问题的方式显而易见，就是让多个 CPU 能够同时执行计算任务，从而实现真正意义上的多任务并行。</p><p>操作系统发展到现在，如果我们要完成一个高性能的软件系统，需要考虑如多进程、多线程、进程间通信、多线程并发等技术点，而且这些技术<strong>并不是最新的就是最好的，也不是非此即彼的选择</strong>。</p><h2 id="集群的复杂度"><a href="#集群的复杂度" class="headerlink" title="集群的复杂度"></a>集群的复杂度</h2><p>虽然计算机硬件的性能快速发展，但和业务的发展速度相比，还是小巫见大巫了，尤其是进入互联网时代后，业务的发展速度远远超过了硬件的发展速度。例如：</p><p>2016 年“双 11”支付宝每秒峰值达 12 万笔支付。</p><p>2017 年春节微信红包收发红包每秒达到 76 万个。</p><p>要支持支付和红包这种复杂的业务，单机的性能无论如何是无法支撑的，必须采用机器集群的方式来达到高性能。例如，支付宝和微信这种规模的业务系统，后台系统的机器数量都是万台级别的。</p><p>通过大量机器来提升性能，并不仅仅是增加机器这么简单，让多台机器配合起来达到高性能的目的，是一个复杂的任务，我针对常见的几种方式简单分析一下。</p><h3 id="1、任务分配"><a href="#1、任务分配" class="headerlink" title="1、任务分配"></a>1、任务分配</h3><p>任务分配的意思是指每台机器都可以处理完整的业务任务，不同的任务分配到不同的机器上执行。</p><p>我从最简单的一台服务器变两台服务器开始，来讲任务分配带来的复杂性，整体架构示意图如下。</p><img src="/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/04/image-20210502231221916.png" class="" title="image-20210502231221916"><p>从图中可以看到，1 台服务器演变为 2 台服务器后，架构上明显要复杂多了，主要体现在：</p><ul><li>需要增加一个<strong>任务分配器</strong>，这个分配器可能是硬件网络设备（例如，F5、交换机等），可能是软件网络设备（例如，LVS），也可能是负载均衡软件（例如，Nginx、HAProxy），还可能是自己开发的系统。选择合适的任务分配器也是一件复杂的事情，需要综合考虑性能、成本、可维护性、可用性等各方面的因素。</li><li>任务分配器和真正的业务服务器之间有连接和交互（即图中任务分配器到业务服务器的连接线），需要选择合适的<strong>连接方式</strong>，并且对连接进行管理。例如，连接建立、连接检测、连接中断后如何处理等。</li><li>任务分配器需要增加<strong>分配算法</strong>。例如，是采用轮询算法，还是按权重分配，又或者按照负载进行分配。如果按照服务器的负载进行分配，则业务服务器还要能够上报自己的状态给任务分配器。</li></ul><p>我们假设单台业务服务器每秒能够处理 5000 次业务请求，那么这个架构理论上能够支撑 10000 次请求，实际上的性能一般按照 8 折计算，大约是 8000 次左右。如果我们的性能要求继续提高，假设要求每秒提升到 10 万次，上面这个架构会出现什么问题呢？是不是将业务服务器增加到 25 台就可以了呢？显然不是，因为随着性能的增加，任务分配器本身又会成为性能瓶颈，当业务请求达到每秒 10 万次的时候，单台任务分配器也不够用了，任务分配器本身也需要扩展为多台机器，这时的架构又会演变成这个样子。</p><img src="/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/04/image-20210502231424201.png" class="" title="image-20210502231424201"><p>这个架构比 2 台业务服务器的架构要复杂，主要体现在：</p><ul><li>任务分配器从 1 台变成了多台，这个变化带来的复杂度就是需要将不同的用户分配到不同的任务分配器上（即图中的虚线“用户分配”部分），常见的方法包括 <strong>DNS 轮询</strong>、<strong>智能 DNS</strong>、<strong>CDN</strong>（Content Delivery Network，内容分发网络）、<strong>GSLB</strong> 设备（Global Server Load Balance，全局负载均衡）等。</li><li>任务分配器和业务服务器的连接从简单的“1 对多”变成了“多对多”（多台任务分配器连接多台业务服务器）的网状结构。</li><li>机器数量从 3 台扩展到 30 台（一般任务分配器数量比业务服务器要少，这里我们假设业务服务器为 25 台，任务分配器为 5 台），状态管理、故障处理复杂度也大大增加。</li></ul><p>上面这两个例子都是以业务处理为例，实际上“任务”涵盖的范围很广，<strong>可以指完整的业务处理，也可以单指某个具体的任务</strong>。例如，“存储”“运算”“缓存”等都可以作为一项任务，因此存储系统、运算系统、缓存系统都可以按照任务分配的方式来搭建架构。此外，“任务分配器”也并不一定只能是物理上存在的机器或者一个独立运行的程序，也可以是嵌入在其他程序中的算法，例如 Memcache 的集群架构。</p><h3 id="2、任务分解"><a href="#2、任务分解" class="headerlink" title="2、任务分解"></a>2、任务分解</h3><p>通过任务分解的方式，能够把原来大一统但复杂的业务系统，拆分成小而简单但需要多个系统配合的业务系统。从业务的角度来看，任务分解既不会减少功能，也不会减少代码量（事实上代码量可能还会增加，因为从代码内部调用改为通过服务器之间的接口调用），那为何通过任务分解就能够提升性能呢？</p><p>主要有几方面的因素：</p><p>1、<strong>简单的系统更加容易做到高性能</strong></p><p>系统的功能越简单，影响性能的点就越少，就更加容易进行有针对性的优化。而系统很复杂的情况下，首先是比较难以找到关键性能点，因为需要考虑和验证的点太多；其次是即使花费很大力气找到了，修改起来也不容易，因为可能将 A 关键性能点提升了，但却无意中将 B 点的性能降低了，整个系统的性能不但没有提升，还有可能会下降。</p><p>2、<strong>可以针对单个任务进行扩展</strong></p><p>当各个逻辑任务分解到独立的子系统后，整个系统的性能瓶颈更加容易发现，而且发现后只需要针对有瓶颈的子系统进行性能优化或者提升，不需要改动整个系统，风险会小很多。以微信的后台架构为例，如果用户数增长太快，注册登录子系统性能出现瓶颈的时候，只需要优化登录注册子系统的性能（可以是代码优化，也可以简单粗暴地加机器），消息逻辑、LBS 逻辑等其他子系统完全不需要改动。</p><p>既然将一个大一统的系统分解为多个子系统能够提升性能，那是不是划分得越细越好呢？其实不然，这样做性能不仅不会提升，反而还会下降，最主要的原因是如果系统拆分得太细，为了完成某个业务，系统间的调用次数会呈指数级别上升，而系统间的调用通道目前都是通过网络传输的方式，性能远比系统内的函数调用要低得多。</p><p>虽然系统拆分可能在某种程度上能提升业务处理性能，但提升性能也是有限的，不可能系统不拆分的时候业务处理耗时为 50ms，系统拆分后业务处理耗时只要 1ms，因为最终决定业务处理性能的还是业务逻辑本身，业务逻辑本身没有发生大的变化下，理论上的性能是有一个上限的，系统拆分能够让性能逼近这个极限，但无法突破这个极限。因此，任务分解带来的性能收益是有一个度的，并不是任务分解越细越好，而对于架构设计来说，如何把握这个粒度就非常关键了。</p>]]></content>
    
    
    <summary type="html">架构</summary>
    
    
    
    <category term="从零开始学架构" scheme="http://universeinheart.github.io/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://universeinheart.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>03、架构设计的目的</title>
    <link href="http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/03/"/>
    <id>http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/03/</id>
    <published>2021-05-02T11:14:56.000Z</published>
    <updated>2021-05-02T15:04:18.900Z</updated>
    
    <content type="html"><![CDATA[<p>通过回顾架构产生的历史背景和原因，我们可以基本推导出答案：<strong>架构设计的主要目的是为了解决软件系统复杂度带来的问题</strong>。</p><blockquote><p>问：“这么多需求，从哪里开始下手进行架构设计呢？”</p><p>答：通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。</p><p>问：“架构设计要考虑高性能、高可用、高扩展……这么多高 XX，全部设计完成估计要 1 个月，但老大只给了 1 周时间”</p><p>答：架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点然后有针对性地解决问题。</p><p>问：“业界 A 公司的架构是 X，B 公司的方案是 Y，两个差别比较大，该参考哪一个呢？”</p><p>答：理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。</p><p>问：“我们的系统一定要做到每秒 TPS 10 万”</p><p>答：如果系统的复杂度不是在性能这部分，TPS 做到 10 万并没有什么用。</p><p>问：“淘宝的架构是这么做的，我们也要这么做”</p><p>答：淘宝的架构是为了解决淘宝业务的复杂度而设计的，淘宝的业务复杂度并不就是我们的业务复杂度，绝大多数业务的用户量都不可能有淘宝那么大。</p><p>问：“Docker 现在很流行，我们的架构应该将 Docker 应用进来”</p><p>答：Docker 不是万能的，只是为了解决资源重用和动态分配而设计的，如果我们的系统复杂度根本不是在这方面，引入 Docker 没有什么意义。</p></blockquote><h2 id="简单的复杂度分析案例"><a href="#简单的复杂度分析案例" class="headerlink" title="简单的复杂度分析案例"></a>简单的复杂度分析案例</h2><p> 假设我们需要设计一个大学的学生管理系统，其基本功能包括登录、注册、成绩管理、课程管理等。</p><p>当我们对这样一个系统进行架构设计的时候，首先应识别其复杂度到底体现在哪里。</p><p><strong>性能</strong>：一个学校的学生大约 1 ~ 2 万人，学生管理系统的访问频率并不高，平均每天单个学生的访问次数平均不到 1 次，因此性能这部分并不复杂，存储用 MySQL 完全能够胜任，缓存都可以不用，Web 服务器用 Nginx 绰绰有余。</p><p><strong>可扩展性</strong>：学生管理系统的功能比较稳定，可扩展的空间并不大，因此可扩展性也不复杂。</p><p><strong>高可用</strong>：学生管理系统即使宕机 2 小时，对学生管理工作影响并不大，因此可以不做负载均衡，更不用考虑异地多活这类复杂的方案了。但是，如果学生的数据全部丢失，修复是非常麻烦的，只能靠人工逐条修复，这个很难接受，因此需要考虑存储高可靠，这里就有点复杂了。我们需要考虑多种异常情况：机器故障、机房故障，针对机器故障，我们需要设计 MySQL 同机房主备方案；针对机房故障，我们需要设计 MySQL 跨机房同步方案。</p><p><strong>安全性</strong>：学生管理系统存储的信息有一定的隐私性，例如学生的家庭情况，但并不是和金融相关的，也不包含强隐私（例如玉照、情感）的信息，因此安全性方面只要做 3 个事情就基本满足要求了：Nginx 提供 ACL 控制、用户账号密码管理、数据库访问权限控制。</p><img src="/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/03/image-20210502223059420.png" class="" title="image-20210502223059420">]]></content>
    
    
    <summary type="html">架构</summary>
    
    
    
    <category term="从零开始学架构" scheme="http://universeinheart.github.io/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://universeinheart.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>02、架构设计的历史背景</title>
    <link href="http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/02/"/>
    <id>http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/02/</id>
    <published>2021-05-02T11:13:56.000Z</published>
    <updated>2021-05-02T14:17:27.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="机器语言（1940-年之前）"><a href="#机器语言（1940-年之前）" class="headerlink" title="机器语言（1940 年之前）"></a>机器语言（1940 年之前）</h2><p>直接使用二进制码 0 和 1 来表示机器可以识别的指令和数据</p><p>机器语言的主要问题是三难：<strong>太难写、太难读、太难改</strong>！</p><h2 id="汇编语言（20-世纪-40-年代）"><a href="#汇编语言（20-世纪-40-年代）" class="headerlink" title="汇编语言（20 世纪 40 年代）"></a>汇编语言（20 世纪 40 年代）</h2><p>汇编语言又叫“<strong>符号语言</strong>”，用助记符代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</p><p>汇编语言虽然解决了机器语言读写复杂的问题，但本质上还是<strong>面向机器</strong>的，因为写汇编语言需要我们精确了解计算机底层的知识。例如，CPU 指令、寄存器、段地址等底层的细节。这对于程序员来说同样很复杂，因为程序员需要将现实世界中的问题和需求按照机器的逻辑进行翻译。</p><h2 id="高级语言（20-世纪-50-年代）"><a href="#高级语言（20-世纪-50-年代）" class="headerlink" title="高级语言（20 世纪 50 年代）"></a>高级语言（20 世纪 50 年代）</h2><p>高级语言让程序员不需要关注机器底层的低级结构和逻辑，而只要关注具体的问题和业务即可。</p><p>除此以外，通过编译程序的处理，高级语言可以被编译为适合不同 CPU 指令的机器语言。程序员只要写一次程序，就可以在多个不同的机器上编译运行，无须根据不同的机器指令重写整个程序。</p><h2 id="第一次软件危机与结构化程序设计（20-世纪-60-年代-20-世纪-70-年代）"><a href="#第一次软件危机与结构化程序设计（20-世纪-60-年代-20-世纪-70-年代）" class="headerlink" title="第一次软件危机与结构化程序设计（20 世纪 60 年代~20 世纪 70 年代）"></a>第一次软件危机与结构化程序设计（20 世纪 60 年代~20 世纪 70 年代）</h2><p>随着软件的规模和复杂度的大大增加，20 世纪 60 年代中期开始爆发了第一次软件危机，典型表现有软件质量低下、项目无法如期完成、项目严重超支等，因为软件而导致的重大事故时有发生。</p><p>软件危机最典型的例子莫过于 IBM 的 System/360 的操作系统开发。佛瑞德·布鲁克斯（Frederick P. Brooks, Jr.）作为项目主管，率领 2000 多个程序员夜以继日地工作，共计花费了 5000 人一年的工作量，写出将近 100 万行的源码，总共投入 5 亿美元，是美国的“曼哈顿”原子弹计划投入的 1/4。尽管投入如此巨大，但项目进度却一再延迟，软件质量也得不到保障。布鲁克斯后来基于这个项目经验而总结的《<strong>人月神话</strong>》一书，成了畅销的软件工程书籍。</p><p>结构化程序设计的主要特点是抛弃 goto 语句，采取“自顶向下、逐步细化、模块化”的指导思想。结构化程序设计本质上还是一种面向过程的设计思想，但通过“自顶向下、逐步细化、模块化”的方法，将软件的复杂度控制在一定范围内，从而从整体上降低了软件开发的复杂度。结构化程序方法成为了 20 世纪 70 年代软件开发的潮流。</p><h2 id="第二次软件危机与面向对象（20-世纪-80-年代）"><a href="#第二次软件危机与面向对象（20-世纪-80-年代）" class="headerlink" title="第二次软件危机与面向对象（20 世纪 80 年代）"></a>第二次软件危机与面向对象（20 世纪 80 年代）</h2><p>第二次软件危机的根本原因还是在于软件生产力远远跟不上硬件和业务的发展。第一次软件危机的根源在于软件的“逻辑”变得非常复杂，而第二次软件危机主要体现在软件的“扩展”变得非常复杂。结构化程序设计虽然能够解决（也许用“缓解”更合适）软件逻辑的复杂性，但是对于业务变化带来的软件扩展却无能为力，软件领域迫切希望找到新的银弹来解决软件危机，在这种背景下，<strong>面向对象的思想</strong>开始流行起来。</p><p><strong>面向对象真正开始流行是在 20 世纪 80 年代，主要得益于 C++ 的功劳，后来的 Java、C# 把面向对象推向了新的高峰。到现在为止，面向对象已经成为了主流的开发思想。</strong></p>]]></content>
    
    
    <summary type="html">架构</summary>
    
    
    
    <category term="从零开始学架构" scheme="http://universeinheart.github.io/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://universeinheart.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>11、怎么给字符串字段加索引</title>
    <link href="http://universeinheart.github.io/2021/05/01/MySQL/11/"/>
    <id>http://universeinheart.github.io/2021/05/01/MySQL/11/</id>
    <published>2021-05-01T14:13:56.000Z</published>
    <updated>2021-05-01T10:03:47.730Z</updated>
    
    
    <summary type="html">MySQL</summary>
    
    
    
    <category term="MySQL实战" scheme="http://universeinheart.github.io/categories/MySQL%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="MySQL" scheme="http://universeinheart.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>01、架构到底是指什么？</title>
    <link href="http://universeinheart.github.io/2021/05/01/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/01/"/>
    <id>http://universeinheart.github.io/2021/05/01/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/01/</id>
    <published>2021-05-01T11:13:56.000Z</published>
    <updated>2021-05-02T14:23:37.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统与子系统"><a href="#系统与子系统" class="headerlink" title="系统与子系统"></a>系统与子系统</h2><blockquote><p>系统泛指由一群有<strong>关联</strong>的个体组成，根据某种<strong>规则</strong>运作，能完成个别元件不能单独完成的<strong>能力</strong>的群体。</p></blockquote><p>我们以微信为例来做一个分析。</p><ol><li>微信本身是一个系统，包含聊天、登录、支付、朋友圈等子系统。</li><li>朋友圈这个系统又包括动态、评论、点赞等子系统。</li><li>评论这个系统可能又包括防刷子系统、审核子系统、发布子系统、存储子系统。</li><li>评论审核子系统不再包含业务意义上的子系统，而是包括各个模块或者组件，这些模块或者组件本身也是另外一个维度上的系统。例如，MySQL、Redis 等是存储系统，但不是业务子系统。</li></ol><h2 id="模块与组件"><a href="#模块与组件" class="headerlink" title="模块与组件"></a>模块与组件</h2><p><strong>模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已</strong>。</p><p>从<strong>逻辑</strong>的角度来拆分系统后，得到的单元就是“<strong>模块</strong>”；</p><p>从<strong>物理</strong>的角度来拆分系统后，得到的单元就是“<strong>组件</strong>”。</p><p>假设我们要做一个学生信息管理系统，这个系统从逻辑的角度来拆分，可以分为“登录注册模块”“个人信息模块”“个人成绩模块”；从物理的角度来拆分，可以拆分为 Nginx、Web 服务器、MySQL。</p><h2 id="框架与架构"><a href="#框架与架构" class="headerlink" title="框架与架构"></a>框架与架构</h2>]]></content>
    
    
    <summary type="html">架构</summary>
    
    
    
    <category term="从零开始学架构" scheme="http://universeinheart.github.io/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://universeinheart.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>01.JDBC必知必会01</title>
    <link href="http://universeinheart.github.io/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/"/>
    <id>http://universeinheart.github.io/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/</id>
    <published>2021-04-28T15:26:37.000Z</published>
    <updated>2021-05-12T23:31:21.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何配置数据源"><a href="#如何配置数据源" class="headerlink" title="如何配置数据源"></a>如何配置数据源</h2><h3 id="Spring-Boot-的配置演示"><a href="#Spring-Boot-的配置演示" class="headerlink" title="Spring Boot 的配置演示"></a>Spring Boot 的配置演示</h3><ul><li>引⼊对应数据库驱动——H2</li><li>引⼊ JDBC 依赖——<code>spring-boot-starter-jdbc</code> </li><li>获取 DataSource Bean，打印信息 </li><li>可通过 /acturator/beans 查看 Bean</li></ul><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210428225118878.png" class="" title="image-20210428225118878"><blockquote><p>CommandLineRunner<code>接口实现的</code>run<code>方法，会在 </code>SpringApplication.run` 方法中执行、</p></blockquote><h3 id="直接配置所需的Bean"><a href="#直接配置所需的Bean" class="headerlink" title="直接配置所需的Bean"></a>直接配置所需的Bean</h3><ul><li>数据源相关：  <code>DataSource</code>（根据选择的连接池实现决定）</li><li>事务相关： <code>DataSourceTransactionManager</code></li><li><code>TransactionTemplate</code> 操作相关：  <code>JdbcTemplate</code></li></ul><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210428225031908.png" class="" title="image-20210428225031908"><h3 id="Spring-Boot-做了哪些配置"><a href="#Spring-Boot-做了哪些配置" class="headerlink" title="Spring Boot 做了哪些配置"></a>Spring Boot 做了哪些配置</h3><p><code>DataSourceTransactionManager</code> 配置 <code>DataSource</code></p><p><code>JdbcTemplateAutoConfiguration</code>配置 <code>JdbcTemplate</code></p><p><code>DataSourceTransactionManagerAutoConfiguration</code> 配置 <code>DataSourceAutoConfiguration</code></p><p><strong>符合条件时才进⾏配置</strong></p><h3 id="数据源相关配置属性"><a href="#数据源相关配置属性" class="headerlink" title="数据源相关配置属性"></a>数据源相关配置属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通用</span><br><span class="line">spring.datasource.url&#x3D;jdbc:h2:mem:testdb</span><br><span class="line">spring.datasource.username&#x3D;admin</span><br><span class="line">spring.datasource.password&#x3D;admin</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver（可选）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化内嵌数据库</span><br><span class="line">spring.datasource.initialization-mode&#x3D;embedded|always|never</span><br><span class="line">spring.datasource.platform&#x3D;hsqldb | h2 | oracle | mysql | postgresql（与前者对应)</span><br><span class="line">spring.datasource.schema&#x3D;classpath:schema.sql (初始化表结构)</span><br><span class="line">spring.datasource.data&#x3D;classpath:data.sql (初始化数据)</span><br></pre></td></tr></table></figure><h3 id="配置多数据源的注意事项"><a href="#配置多数据源的注意事项" class="headerlink" title="配置多数据源的注意事项"></a>配置多数据源的注意事项</h3><p><strong>不同数据源的配置要分开</strong></p><p> <strong>关注每次使⽤的数据源</strong></p><ul><li>有多个DataSource时系统如何判断</li><li>对应的设施（事务、ORM等）如何选择DataSource</li></ul><h3 id="Spring-Boot中的多数据源配置"><a href="#Spring-Boot中的多数据源配置" class="headerlink" title="Spring Boot中的多数据源配置"></a>Spring Boot中的多数据源配置</h3><p><strong>排除Spring Boot的⾃动配置</strong></p><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210428230608385.png" class="" title="image-20210428230608385"><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210428230744941.png" class="" title="image-20210428230744941"><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210428230534448.png" class="" title="image-20210428230534448"><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210428230509295.png" class="" title="image-20210428230509295"><h2 id="连接池-HikariCP"><a href="#连接池-HikariCP" class="headerlink" title="连接池 HikariCP"></a>连接池 HikariCP</h2><blockquote><p><code>HikariCP</code> 为什么快?</p><ul><li>字节码级别优化（很多⽅法通过 <code>JavaAssist</code> ⽣成）</li><li>⼤量⼩改进<ul><li>⽤ <code>FastStatementList</code> 代替 <code>ArrayList</code></li><li>⽆锁集合 <code>ConcurrentBag</code></li><li>代理类的优化（⽐如，⽤ <code>invokestatic</code> 代替了 <code>invokevirtual</code>）</li></ul></li></ul></blockquote><h3 id="在-Spring-Boot-中的配置"><a href="#在-Spring-Boot-中的配置" class="headerlink" title="在 Spring Boot 中的配置"></a>在 Spring Boot 中的配置</h3><p><strong>Spring Boot 2.x</strong></p><ul><li>默认使⽤ <code>HikariCP</code></li><li>配置 <code>spring.datasource.hikari.*</code> </li></ul><p>Spring Boot 1.x </p><ul><li>默认使⽤ <code>Tomcat</code> 连接池，需要移除 tomcat-jdbc 依赖</li><li>spring.datasource.type=com.zaxxer.hikari.HikariDataSource</li></ul><h3 id="常⽤-HikariCP-配置参数"><a href="#常⽤-HikariCP-配置参数" class="headerlink" title="常⽤ HikariCP 配置参数"></a>常⽤ HikariCP 配置参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">常⽤配置</span><br><span class="line">spring.datasource.hikari.maximumPoolSize&#x3D;5</span><br><span class="line">spring.datasource.hikari.minimumIdle&#x3D;5</span><br><span class="line">spring.datasource.hikari.idleTimeout&#x3D;600000</span><br><span class="line">spring.datasource.hikari.connectionTimeout&#x3D;30000</span><br><span class="line">spring.datasource.hikari.maxLifetime&#x3D;1800000</span><br><span class="line"></span><br><span class="line">其他配置详⻅ HikariCP 官⽹</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;brettwooldridge&#x2F;HikariCP</span><br></pre></td></tr></table></figure><h3 id="如何配置数据源属性"><a href="#如何配置数据源属性" class="headerlink" title="如何配置数据源属性"></a>如何配置数据源属性</h3><p><code>org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hikari DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(HikariDataSource.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DataSource.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;com.zaxxer.hikari.HikariDataSource&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hikari</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.hikari&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HikariDataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">HikariDataSource dataSource = createDataSource(properties,</span><br><span class="line">HikariDataSource.class);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(properties.getName())) &#123;</span><br><span class="line">dataSource.setPoolName(properties.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Alibaba-Druid"><a href="#Alibaba-Druid" class="headerlink" title="Alibaba Druid"></a>Alibaba Druid</h2><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>详细的监控（真的是全⾯）</li><li>ExceptionSorter，针对主流数据库的返回码都有⽀持</li><li>SQL 防注⼊</li><li>内置加密配置</li><li>众多扩展点，⽅便进⾏定制</li></ul><h4 id="如何用Druid"><a href="#如何用Druid" class="headerlink" title="如何用Druid"></a>如何用Druid</h4><p>需要排除掉HikariCP的包</p><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210509122207290.png" class="" title="image-20210509122207290"><ol><li>直接配置 <code>DruidDataSource</code></li><li>通过 <code>druid-spring-boot-starter</code>   配置：<code>spring.datasource.druid.*</code></li></ol><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210509121007744.png" class="" title="image-20210509121007744"><h4 id="Druid配置项"><a href="#Druid配置项" class="headerlink" title="Druid配置项"></a>Druid配置项</h4><ul><li>Filter 配置<ul><li>spring.datasource.druid.filters=stat,config,wall,log4j （全部使⽤默认值） </li></ul></li><li>密码加密<ul><li>spring.datasource.password=&lt;加密密码&gt; </li><li>spring.datasource.druid.filter.config.enabled=true</li><li>spring.datasource.druid.connection-properties=config.decrypt=true;config.decrypt.key= </li></ul></li><li>SQL 防注⼊<ul><li>spring.datasource.druid.filter.wall.enabled=true</li><li>spring.datasource.druid.filter.wall.db-type=h2</li><li>spring.datasource.druid.filter.wall.config.delete-allow=false</li><li>spring.datasource.druid.filter.wall.config.drop-table-allow=false</li></ul></li></ul><h4 id="Druid-Filter"><a href="#Druid-Filter" class="headerlink" title="Druid Filter"></a>Druid Filter</h4><ul><li>⽤于定制连接池操作的各种环节</li><li>可以继承 <code>FilterEventAdapter</code> 以便⽅便地实现 <code>Filter</code></li><li>修改 <code>META-INF/druid-filter.properties</code> 增加 <code>Filter</code> 配置</li></ul><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210509121912105.png" class="" title="image-20210509121912105">]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://universeinheart.github.io/tags/SpringBoot/"/>
    
    <category term="JDBC" scheme="http://universeinheart.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>02.JDBC必知必会02</title>
    <link href="http://universeinheart.github.io/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/"/>
    <id>http://universeinheart.github.io/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/</id>
    <published>2021-04-28T15:26:37.000Z</published>
    <updated>2021-05-12T23:31:10.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过-Spring-JDBC-访问数据库"><a href="#通过-Spring-JDBC-访问数据库" class="headerlink" title="通过 Spring JDBC 访问数据库"></a>通过 Spring JDBC 访问数据库</h2><ul><li><code>core</code>，<code>JdbcTemplate</code> 等相关核⼼接⼝和类</li><li><code>datasource</code>，数据源相关的辅助类 </li><li><code>object</code>，将基本的 JDBC 操作封装成对象 </li><li><code>support</code>，错误码等其他辅助⼯具</li></ul><h3 id="简单的-JDBC-操作"><a href="#简单的-JDBC-操作" class="headerlink" title="简单的 JDBC 操作"></a>简单的 JDBC 操作</h3><p>JdbcTemplate </p><ul><li><code>query</code> </li><li><code>queryForObject</code> </li><li><code>queryForList</code> </li><li><code>queryForMap</code></li><li><code>update</code> </li><li><code>execute</code></li></ul><p><code>NamedParameterJdbcTemplate</code>: SQL 按名称而不是按位置进行指定. 具名参数更易于维护, 也提升了可读性. 具名参数由框架类在运行时用占位符取代</p><h3 id="SQL-批处理"><a href="#SQL-批处理" class="headerlink" title="SQL 批处理"></a>SQL 批处理</h3><ul><li>JdbcTemplate<ul><li>batchUpdate<ul><li>BatchPreparedStatementSetter</li></ul></li></ul></li><li>NamedParameterJdbcTemplate <ul><li>batchUpdate<ul><li>SqlParameterSourceUtils.createBatch</li></ul></li></ul></li></ul><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210509131855838.png" class="" title="image-20210509131855838"><h2 id="了解-Spring-的抽象"><a href="#了解-Spring-的抽象" class="headerlink" title="了解 Spring 的抽象"></a>了解 Spring 的抽象</h2><h3 id="Spring-的事务抽象"><a href="#Spring-的事务抽象" class="headerlink" title="Spring 的事务抽象"></a>Spring 的事务抽象</h3><h4 id="事务抽象的核⼼接⼝"><a href="#事务抽象的核⼼接⼝" class="headerlink" title="事务抽象的核⼼接⼝"></a>事务抽象的核⼼接⼝</h4><ul><li>PlatformTransactionManager<ul><li>DataSourceTransactionManager</li><li>HibernateTransactionManager</li><li>JtaTransactionManager </li></ul></li><li>TransactionDefinition <ul><li>Propagation</li><li>Isolation</li><li>Timeout</li><li>Read-only status</li></ul></li></ul><h4 id="事务传播特性"><a href="#事务传播特性" class="headerlink" title="事务传播特性"></a>事务传播特性</h4><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210509133127418.png" class="" title="image-20210509133127418"><h4 id="事务隔离特性"><a href="#事务隔离特性" class="headerlink" title="事务隔离特性"></a>事务隔离特性</h4><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210509133148998.png" class="" title="image-20210509133148998"><h4 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h4><ul><li><strong>TransactionTemplate</strong><ul><li>TransactionCallback</li><li>TransactionCallbackWithoutResult </li></ul></li><li><strong>PlatformTransactionManager</strong>  <ul><li>可以传⼊TransactionDefinition进⾏定义</li></ul></li></ul><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210510132837890.png" class="" title="image-20210510132837890"><h4 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h4><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210510134107786.png" class="" title="image-20210510134107786"><p><code>Spring</code> 的声明式事务本质上是通过 <code>AOP</code> 来增强了类的功能，<code>AOP</code> 本质上就是为类做了⼀个代理，看似在调⽤⾃⼰写的类，实际⽤的是增强后的代理类</p><p><strong>基于注解的配置⽅式</strong></p><ul><li>开启事务注解的⽅式<ul><li><code>@EnableTransactionManagement</code></li><li><code>&lt;tx:annotation-driven/&gt;</code></li></ul></li><li>EnableTransactionManagement注解的配置、<ul><li>proxyTargetClass</li><li>mode</li><li>order </li></ul></li><li><code>@Transactional</code>  <ul><li>transactionManager</li><li>propagation</li><li>isolation</li><li>timeout</li><li>readOnly</li><li>怎么判断回滚</li></ul></li></ul><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210510134404080.png" class="" title="image-20210510134404080"><blockquote><p><code>invokeInsertThenRollback</code> 方法中调用<code>insertThenRollback</code>，外部调用<code>invokeInsertThenRollback</code> 并不存在事务，而是插入成功，没有回滚</p><p>原因是 <code>Spring</code> 是为类做了代理，需要调用代理类才能真正执行到被代理增强的方法，如果是在类内部做的调用，说明没有走到增强的代理方法</p><p>解决方案：</p><ol><li>把自己的实例注入进来，内部方法调用改为直接调用注入的实例。Spring创建了一个代理，我们调用代理就好了<img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210510135823823.png" class="" title="image-20210510135823823"></li><li>在当前类的方法中通过<code>AopContext.currentProxy()</code>获取当前类的代理对象，再调用的代理对象的方法<img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210510135852673.png" class="" title="image-20210510135852673"></li></ol></blockquote><h3 id="JDBC-异常抽象"><a href="#JDBC-异常抽象" class="headerlink" title="JDBC 异常抽象"></a>JDBC 异常抽象</h3><p>Spring 会将数据操作的异常转换为 <code>DataAccessException</code>  ⽆论使⽤何种数据访问⽅式，都能使⽤⼀样的异常</p><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210510223812309.png" class="" title="image-20210510223812309"><h4 id="Spring是怎么认识那些错误码的"><a href="#Spring是怎么认识那些错误码的" class="headerlink" title="Spring是怎么认识那些错误码的"></a>Spring是怎么认识那些错误码的</h4><p><strong>通过 <code>SQLErrorCodeSQLExceptionTranslator</code> 解析错误码</strong> </p><p><code>ErrorCode</code> 定义</p><ul><li>org/springframework/jdbc/support/sql-error-codes.xml</li><li>Classpath 下的 sql-error-codes.xml</li></ul><h4 id="定制错误码解析逻辑"><a href="#定制错误码解析逻辑" class="headerlink" title="定制错误码解析逻辑"></a>定制错误码解析逻辑</h4><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210511000852039.png" class="" title="image-20210511000852039">]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://universeinheart.github.io/tags/SpringBoot/"/>
    
    <category term="JDBC" scheme="http://universeinheart.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>03.Kafka只是消息引擎系统吗？</title>
    <link href="http://universeinheart.github.io/2021/04/24/Kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/03/"/>
    <id>http://universeinheart.github.io/2021/04/24/Kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/03/</id>
    <published>2021-04-24T08:47:37.000Z</published>
    <updated>2021-04-24T09:45:26.069Z</updated>
    
    <content type="html"><![CDATA[<p><code>Apache Kafka</code> 是消息引擎系统，也是一个分布式流处理平台（<code>Distributed Streaming Platform</code>）</p><blockquote><p>Kafka 在设计之初就旨在提供三个方面的特性：</p><ul><li>提供一套 API 实现生产者和消费者；</li><li>降低网络传输和磁盘存储开销；</li><li>实现高伸缩性架构。</li></ul></blockquote><p><strong>流处理</strong>要最终替代它的“兄弟”<strong>批处理</strong>需要具备两点核心优势：<strong>要实现正确性和提供能够推导时间的工具</strong>。</p><p>实现正确性是流处理能够匹敌批处理的基石。正确性一直是批处理的强项，而实现正确性的基石则是要求框架能提供精确一次处理语义，即处理一条消息有且只有一次机会能够影响系统状态。</p><p>目前主流的大数据流处理框架都宣称实现了精确一次处理语义，但这是有限定条件的，即它们只能实现框架内的精确一次处理语义，无法实现端到端的。这是为什么呢？因为当这些框架与外部消息引擎系统结合使用时，它们无法影响到外部系统的处理语义，所以如果你搭建了一套环境使得 <code>Spark</code> 或 <code>Flink</code> 从 <code>Kafka</code> 读取消息之后进行有状态的数据计算，最后再写回 <code>Kafka</code>，那么你只能保证在 <code>Spark</code> 或 <code>Flink</code> 内部，这条消息对于状态的影响只有一次。但是计算结果有可能多次写入到 <code>Kafka</code>，因为它们不能控制 <code>Kafka</code> 的语义处理。相反地，<code>Kafka</code> 则不是这样，因为所有的数据流转和计算都在 <code>Kafka</code> 内部完成，故 <code>Kafka</code> 可以实现端到端的精确一次处理语义。</p>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="Kafka" scheme="http://universeinheart.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="http://universeinheart.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>02.Kafka术语</title>
    <link href="http://universeinheart.github.io/2021/04/24/Kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/02/"/>
    <id>http://universeinheart.github.io/2021/04/24/Kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/02/</id>
    <published>2021-04-24T08:46:37.000Z</published>
    <updated>2021-04-24T09:37:38.383Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Kafka</code> 中，发布订阅的对象是主题（<code>Topic</code>），你可以为每个业务、每个应用甚至是每类数据都创建专属的主题。</p><p>向主题发布消息的客户端应用程序称为生产者（<code>Producer</code>），生产者程序通常持续不断地向一个或多个主题发送消息，而订阅这些主题消息的客户端应用程序就被称为消费者（<code>Consumer</code>）。</p><p>和生产者类似，消费者也能够同时订阅多个主题的消息。我们把生产者和消费者统称为客户端（<code>Clients</code>）。你可以同时运行多个生产者和消费者实例，这些实例会不断地向 <code>Kafka</code> 集群中的多个主题生产和消费消息。</p><p><code>Kafka</code> 的服务器端由被称为 <code>Broker</code> 的服务进程构成，即一个 <code>Kafka</code> 集群由多个 <code>Broker</code> 组成，<code>Broker</code> 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。</p><p>虽然多个 <code>Broker</code> 进程能够运行在同一台机器上，但更常见的做法是将不同的 <code>Broker</code> 分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在它上面运行的所有 <code>Broker</code> 进程都挂掉了，其他机器上的 <code>Broker</code> 也依然能够对外提供服务。这其实就是 <code>Kafka</code> 提供高可用的手段之一。</p><p>实现高可用的另一个手段就是备份机制（<code>Replication</code>）。备份的思想很简单，就是把<strong>相同的数据拷贝到多台机器上</strong>，而这些相同的数据拷贝在 <code>Kafka</code> 中被称为副本（<code>Replica</code>）。副本的数量是可以配置的，这些副本保存着相同的数据，但却有不同的角色和作用。</p><p><code>Kafka</code> 定义了两类副本：<strong>领导者副本</strong>（<code>Leader Replica</code>）和<strong>追随者副本</strong>（<code>Follower Replica</code>）。前者对外提供服务，这里的对外指的是与客户端程序进行交互；而后者只是被动地追随领导者副本而已，不能与外界进行交互。当然了，你可能知道在很多其他系统中追随者副本是可以对外提供服务的，比如 <code>MySQL</code> 的从库是可以处理读操作的，但是在 <code>Kafka</code> 中<strong>追随者副本不会对外提供服务</strong>。 </p><p>副本的工作机制也很简单：生产者总是向领导者副本写消息；而消费者总是从领导者副本读消息。至于追随者副本，它只做一件事：向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步。</p><p>伸缩性即所谓的 <code>Scalability</code>，是分布式系统中非常重要且必须要谨慎对待的问题。什么是伸缩性呢？我们拿副本来说，虽然现在有了领导者副本和追随者副本，但倘若领导者副本积累了太多的数据以至于单台 <code>Broker</code> 机器都无法容纳了，此时应该怎么办呢？一个很自然的想法就是，能否把数据分割成多份保存在不同的 <code>Broker</code> 上？</p><p>如果你就是这么想的，那么恭喜你，<code>Kafka</code> 就是这么设计的。这种机制就是所谓的分区（<code>Partitioning</code>）。<code>Kafka</code> 中的分区机制指的是将<strong>每个主题划分成多个分区</strong>（<code>Partition</code>），<strong>每个分区是一组有序的消息日志</strong>。生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。</p><p>刚才提到的副本如何与这里的分区联系在一起呢？实际上，副本是在分区这个层级定义的。每个分区下可以配置若干个副本，其中只能有 1 个领导者副本和 N-1 个追随者副本。生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移（<code>Offset</code>）的数据来表征。分区位移总是从 0 开始，假设一个生产者向一个空分区写入了 10 条消息，那么这 10 条消息的位移依次是 0、1、2、……、9。</p><blockquote><p>完整地串联起 Kafka 的三层消息架构：</p><ul><li>第一层是<strong>主题层</strong>，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本。</li><li>第二层是<strong>分区层</strong>，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 N-1 个副本是追随者副本，只是提供数据冗余之用。</li><li>第三层是<strong>消息层</strong>，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。</li><li>最后，客户端程序只能与分区的领导者副本进行交互。</li></ul></blockquote><p><code>Kafka Broker</code> 是如何持久化数据的。总的来说，<code>Kafka</code> 使用<strong>消息日志</strong>（<code>Log</code>）来保存数据，一个日志就是磁盘上一个只能追加写（<code>Append-only</code>）消息的物理文件。因为只能追加写入，故避免了缓慢的随机 I/O 操作，改为性能较好的顺序 I/O 写操作，这也是实现 <code>Kafka</code> 高吞吐量特性的一个重要手段。</p><p>不过如果你不停地向一个日志写入消息，最终也会耗尽所有的磁盘空间，因此 <code>Kafka</code> 必然要定期地删除消息以回收磁盘。怎么删除呢？简单来说就是通过日志段（<code>Log Segment</code>）机制。在 <code>Kafka</code> 底层，一个日志又进一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，<code>Kafka</code> 会自动切分出一个新的日志段，并将老的日志段封存起来。<code>Kafka</code> 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</p><p>在 Kafka 中实现这种点对点模型（<code>Peer to Peer，P2P</code>）的方法就是引入了<strong>消费者组</strong>（<code>Consumer Group</code>）。所谓的消费者组，指的是<strong>多个消费者实例共同组成一个组来消费一组主题</strong>。这组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它。</p><p>为什么要引入消费者组呢？主要是为了<strong>提升消费者端的吞吐量</strong>。多个消费者实例同时消费，加速整个消费端的吞吐量（TPS）。消费者实例可以是运行消费者应用的进程，也可以是一个线程，它们都称为一个消费者实例（Consumer Instance）。</p><p>消费者组里面的所有消费者实例不仅“瓜分”订阅主题的数据，而且更酷的是它们还能彼此协助。假设组内某个实例挂掉了，<code>Kafka</code> 能够自动检测到，然后把这个 <code>Failed</code> 实例之前负责的分区转移给其他活着的消费者。这个过程就是 <code>Kafka</code> 中大名鼎鼎的“重平衡”（<code>Rebalance</code>）。嗯，其实既是大名鼎鼎，也是臭名昭著，因为由重平衡引发的消费者问题比比皆是。事实上，目前很多重平衡的 Bug 社区都无力解决。</p><p>每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上，这个字段就是<strong>消费者位移</strong>（<strong>Consumer Offset</strong>）。注意，这和上面所说的位移完全不是一个概念。上面的“位移”表征的是分区内的消息位置，它是不变的，即一旦消息被成功写入到一个分区上，它的位移值就是固定的了。而消费者位移则不同，它可能是随时变化的，毕竟它是消费者消费进度的指示器嘛。另外每个消费者有着自己的消费者位移，因此一定要区分这两类位移的区别。我个人把消息在分区中的位移称为分区位移，而把消费者端的位移称为消费者位移。</p><p>总结一下今天提到的所有名词术语：</p><ul><li><strong>消息</strong>：<code>Record</code>。<code>Kafka</code> 是消息引擎嘛，这里的消息就是指 <code>Kafka</code> 处理的主要对象。</li><li><strong>主题</strong>：<code>Topic</code>。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。</li><li><strong>分区</strong>：<code>Partition</code>。一个有序不变的消息序列。每个主题下可以有多个分区。</li><li><strong>消息位移</strong>：<code>Offset</code>。表示分区中每条消息的位置信息，是一个单调递增且不变的值。</li><li><strong>副本</strong>：<code>Replica</code>。<code>Kafka</code> 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。</li><li><strong>生产者</strong>：<code>Producer</code>。向主题发布新消息的应用程序。</li><li><strong>消费者</strong>：<code>Consumer</code>。从主题订阅新消息的应用程序。</li><li><strong>消费者位移</strong>：<code>Consumer Offset</code>。表征消费者消费进度，每个消费者都有自己的消费者位移。</li><li><strong>消费者组</strong>：<code>Consumer Group</code>。多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。</li><li><strong>重平衡</strong>：<code>Rebalance</code>。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。<code>Rebalance</code> 是 <code>Kafka</code> 消费者端实现高可用的重要手段。</li></ul><img src="/2021/04/24/Kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/02/image-20210424173638327.png" class="" title="image-20210424173638327">]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="Kafka" scheme="http://universeinheart.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="http://universeinheart.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>曾国藩修身十二法</title>
    <link href="http://universeinheart.github.io/2021/04/24/%E5%B0%8F%E5%86%8C%E5%AD%90/%E6%9B%BE%E5%9B%BD%E8%97%A9%E4%BF%AE%E8%BA%AB%E5%8D%81%E4%BA%8C%E6%B3%95/"/>
    <id>http://universeinheart.github.io/2021/04/24/%E5%B0%8F%E5%86%8C%E5%AD%90/%E6%9B%BE%E5%9B%BD%E8%97%A9%E4%BF%AE%E8%BA%AB%E5%8D%81%E4%BA%8C%E6%B3%95/</id>
    <published>2021-04-24T07:07:37.000Z</published>
    <updated>2021-04-24T15:47:19.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一法、主敬"><a href="#第一法、主敬" class="headerlink" title="第一法、主敬"></a>第一法、主敬</h2><p><strong>整齐严肃，无时不惧。无事时心在腔子里，应事时专一不杂。清明在躬，如日之升。</strong></p><blockquote><p>每天保证衣冠外貌整齐，心思神情端正严肃，时时刻刻都要警惕、检查自己的念头、举止中有无背离义理之处。</p><p>平日里，闲居无事的时候宁静安泰，投入事务中则专心致志，不存杂念。</p><p>永远让自己的精神状态保持清澈，就如同旭日东升般光彩照人。</p></blockquote><h2 id="第二法、静坐"><a href="#第二法、静坐" class="headerlink" title="第二法、静坐"></a>第二法、静坐</h2><p><strong>每日不拘何时，静坐四刻，体念来复之仁心，正位凝命，如鼎之镇。</strong></p><blockquote><p>每天，一定要抽出一段时间静坐，以修身养性，并反省体悟自己天性中隐现的仁义之心。</p><p>正襟危坐，凝然镇定，如同宝鼎一般沉稳。</p></blockquote><h2 id="第三法、早起"><a href="#第三法、早起" class="headerlink" title="第三法、早起"></a>第三法、早起</h2><p><strong>黎明即起，醒后勿粘恋</strong></p><h2 id="第四法、读书不二"><a href="#第四法、读书不二" class="headerlink" title="第四法、读书不二"></a>第四法、读书不二</h2><p><strong>一书未点完，不看他书。东翻西阅，徒务外为人，每日以十页为率</strong></p><blockquote><p>一本书没有读完时，不要再看其他书籍。</p><p>东翻西阅随意读书，对自己的道德学问毫无益处。</p></blockquote><h2 id="第五法、读史"><a href="#第五法、读史" class="headerlink" title="第五法、读史"></a>第五法、读史</h2><p><strong>丙申年购《二十三史》，大人曰：“尔借钱买书，吾不惮极力为尔弥缝，尔能圈点一遍，则不负我矣。”嗣后每日圈点十页，间断不孝。</strong></p><h2 id="第六法、谨言"><a href="#第六法、谨言" class="headerlink" title="第六法、谨言"></a>第六法、谨言</h2><p><strong>刻刻留心，第一功夫</strong></p><h2 id="第七法、养气"><a href="#第七法、养气" class="headerlink" title="第七法、养气"></a>第七法、养气</h2><p><strong>气藏丹田，无不可对人言之事</strong></p><h2 id="第八法、保身"><a href="#第八法、保身" class="headerlink" title="第八法、保身"></a>第八法、保身</h2><p><strong>十二月奉大人手谕：“节劳，节欲，节饮食。”时时当作养病。</strong></p><h2 id="第九法、日知所亡"><a href="#第九法、日知所亡" class="headerlink" title="第九法、日知所亡"></a>第九法、日知所亡</h2><p><strong>每日读书记录心得语，有求深意是徇人</strong></p><blockquote><p>每天读书，都要将心得体会记录下来，不要刻意地从书中谋求深意，否则，就是曲从于他人。</p></blockquote><h2 id="第十法、月无亡所能"><a href="#第十法、月无亡所能" class="headerlink" title="第十法、月无亡所能"></a>第十法、月无亡所能</h2><p><strong>每月做诗文数首，以验积理之多寡，养气之盛否。不可一味耽著，最易溺心丧志。</strong></p><h2 id="第十一法、作字"><a href="#第十一法、作字" class="headerlink" title="第十一法、作字"></a>第十一法、作字</h2><p><strong>早饭后做字半时。凡笔墨应酬，当作自己课程。凡事不待明日，愈积愈难清。</strong></p><h2 id="第十二法、夜不出门"><a href="#第十二法、夜不出门" class="headerlink" title="第十二法、夜不出门"></a>第十二法、夜不出门</h2><p><strong>旷功疲神，切戒切戒！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一法、主敬&quot;&gt;&lt;a href=&quot;#第一法、主敬&quot; class=&quot;headerlink&quot; title=&quot;第一法、主敬&quot;&gt;&lt;/a&gt;第一法、主敬&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;整齐严肃，无时不惧。无事时心在腔子里，应事时专一不杂。清明在躬，如日之升。&lt;/strong&gt;</summary>
      
    
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>
