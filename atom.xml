<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HelloWorld</title>
  
  
  <link href="http://universeinheart.github.io/atom.xml" rel="self"/>
  
  <link href="http://universeinheart.github.io/"/>
  <updated>2021-05-31T16:07:17.161Z</updated>
  <id>http://universeinheart.github.io/</id>
  
  <author>
    <name>xjf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>02.JVM</title>
    <link href="http://universeinheart.github.io/2021/06/01/%E9%A9%AC%E8%80%81%E5%B8%88/02/"/>
    <id>http://universeinheart.github.io/2021/06/01/%E9%A9%AC%E8%80%81%E5%B8%88/02/</id>
    <published>2021-06-01T15:26:37.000Z</published>
    <updated>2021-05-31T16:07:17.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚拟机基础概念"><a href="#虚拟机基础概念" class="headerlink" title="虚拟机基础概念"></a>虚拟机基础概念</h2><img src="/2021/06/01/%E9%A9%AC%E8%80%81%E5%B8%88/02/image-20210531233330270.png" class="" title="image-20210531233330270"><blockquote><p><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a></p><p>A single write to a non-volatile <code>long</code> or <code>double</code> value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.</p><p><strong>Writes and reads of volatile <code>long</code> and <code>double</code> values are always atomic.</strong></p><p>Programmers are encouraged to declare shared 64-bit values as <code>volatile</code> or synchronize their programs correctly to avoid possible complications.</p></blockquote><h2 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h2><h2 id="内存加载过程"><a href="#内存加载过程" class="headerlink" title="内存加载过程"></a>内存加载过程</h2><h2 id="运行时内存结构"><a href="#运行时内存结构" class="headerlink" title="运行时内存结构"></a>运行时内存结构</h2><h2 id="JVM常用指令"><a href="#JVM常用指令" class="headerlink" title="JVM常用指令"></a>JVM常用指令</h2><h2 id="GC与调优（重点）"><a href="#GC与调优（重点）" class="headerlink" title="GC与调优（重点）"></a>GC与调优（重点）</h2>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="跟马老师学编程" scheme="http://universeinheart.github.io/categories/%E8%B7%9F%E9%A9%AC%E8%80%81%E5%B8%88%E5%AD%A6%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="http://universeinheart.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="http://universeinheart.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://universeinheart.github.io/2021/06/01/mmm/"/>
    <id>http://universeinheart.github.io/2021/06/01/mmm/</id>
    <published>2021-05-31T16:31:35.249Z</published>
    <updated>2021-05-31T16:33:30.516Z</updated>
    
    <content type="html"><![CDATA[<div class="mermaid">pie​Test X ​&quot;A&quot; : 50 ​&quot;B&quot; : 20​ &quot;C&quot; : 10 ​&quot;D&quot; :  5</div><div class="mermaid">classDiagram      Executor &lt;|-- ExecutorService      ExecutorService &lt;|-- ThreadPoolExecutor</div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;mermaid&quot;&gt;
pie

​	Test X 

​	&amp;quot;A&amp;quot; : 50 

​	&amp;quot;B&amp;quot; : 20

​	 &amp;quot;C&amp;quot; : 10 

​	&amp;quot;D&amp;quot; :  5
&lt;/div&gt;

&lt;div</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java多线程编程面试</title>
    <link href="http://universeinheart.github.io/2021/05/31/%E9%9D%A2%E8%AF%95/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://universeinheart.github.io/2021/05/31/%E9%9D%A2%E8%AF%95/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-05-31T15:19:37.000Z</published>
    <updated>2021-05-31T15:26:50.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>第一题<br>实现一个容器，提供两个方法，add，size<br>写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</p><p>方法1：<br>使用wait和notify做到，wait会释放锁，而notify不会释放锁<br>需要注意的是，运用这种方法，必须要保证t2先执行，也就是首先让t2监听才可以<br>notify之后，t1必须释放锁，t2退出后，也必须notify，通知t1继续执行</p><p>方法2：<br>使用Latch（门闩）替代wait notify来进行通知<br>好处是通信方式简单，同时也可以指定等待时间<br>使用await和countdown方法替代wait和notify<br>CountDownLatch不涉及锁定，当count的值为零时当前线程继续运行<br>当不涉及同步，只是涉及线程通信的时候，用synchronized + wait/notify就显得太重了<br>这时应该考虑countdownlatch/cyclicbarrier/semaphore</p><p>方法3：<br>LockSupport</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_NotifyFreeLock</span> </span>&#123;</span><br><span class="line">List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">lists.add(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lists.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">T04_NotifyFreeLock c = <span class="keyword">new</span> T04_NotifyFreeLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;t2启动&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(c.size() != <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;t2 结束&quot;</span>);</span><br><span class="line"><span class="comment">//通知t1继续执行</span></span><br><span class="line">lock.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;t1启动&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">c.add(<span class="keyword">new</span> Object());</span><br><span class="line">System.out.println(<span class="string">&quot;add &quot;</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">lock.notify();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                               <span class="comment">//释放锁，让t2得以执行</span></span><br><span class="line">lock.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_CountDownLatch</span> </span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">lists.add(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lists.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">T05_CountDownLatch c = <span class="keyword">new</span> T05_CountDownLatch();</span><br><span class="line"></span><br><span class="line">CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">CountDownLatch latch2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;t2启动&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (c.size() != <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">latch.await();</span><br><span class="line">latch2.countDown();</span><br><span class="line"><span class="comment">//也可以指定等待时间</span></span><br><span class="line"><span class="comment">//latch.await(5000, TimeUnit.MILLISECONDS);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;t2 结束&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;t1启动&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">c.add(<span class="keyword">new</span> Object());</span><br><span class="line">System.out.println(<span class="string">&quot;add &quot;</span> + i);</span><br><span class="line"><span class="keyword">if</span> (c.size() == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="comment">// 打开门闩，让t2得以执行</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                          latch.countDown();</span><br><span class="line">latch2.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第二题</span><br><span class="line">面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用</span><br><span class="line"></span><br><span class="line">使用wait和notify&#x2F;notifyAll来实现</span><br><span class="line"></span><br><span class="line">使用Lock和Condition来实现</span><br><span class="line"></span><br><span class="line">对比两种方式，Condition的方式可以更加精确的指定哪些线程被唤醒</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer1</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> LinkedList&lt;T&gt; lists = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> MAX = <span class="number">10</span>; <span class="comment">//最多10个元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(lists.size() == MAX) &#123; <span class="comment">//想想为什么用while而不是用if？</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.wait(); <span class="comment">//effective java</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lists.add(t);</span><br><span class="line">++count;</span><br><span class="line"><span class="keyword">this</span>.notifyAll(); <span class="comment">//通知消费者线程进行消费</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">T t = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>(lists.size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">t = lists.removeFirst();</span><br><span class="line">count --;</span><br><span class="line"><span class="keyword">this</span>.notifyAll(); <span class="comment">//通知生产者进行生产</span></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyContainer1&lt;String&gt; c = <span class="keyword">new</span> MyContainer1&lt;&gt;();</span><br><span class="line"><span class="comment">//启动消费者线程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++) System.out.println(c.get());</span><br><span class="line">&#125;, <span class="string">&quot;c&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动生产者线程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">25</span>; j++) c.put(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">&#125;, <span class="string">&quot;p&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> LinkedList&lt;T&gt; lists = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> MAX = <span class="number">10</span>; <span class="comment">//最多10个元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> Condition producer = lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> Condition consumer = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">while</span>(lists.size() == MAX) &#123; <span class="comment">//想想为什么用while而不是用if？</span></span><br><span class="line">producer.await();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lists.add(t);</span><br><span class="line">++count;</span><br><span class="line">consumer.signalAll(); <span class="comment">//通知消费者线程进行消费</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">T t = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">while</span>(lists.size() == <span class="number">0</span>) &#123;</span><br><span class="line">consumer.await();</span><br><span class="line">&#125;</span><br><span class="line">t = lists.removeFirst();</span><br><span class="line">count --;</span><br><span class="line">producer.signalAll(); <span class="comment">//通知生产者进行生产</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyContainer2&lt;String&gt; c = <span class="keyword">new</span> MyContainer2&lt;&gt;();</span><br><span class="line"><span class="comment">//启动消费者线程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++) System.out.println(c.get());</span><br><span class="line">&#125;, <span class="string">&quot;c&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动生产者线程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">25</span>; j++) c.put(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">&#125;, <span class="string">&quot;p&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;第一题&lt;br&gt;实现一个容器，提供两个方法，add，size&lt;br&gt;写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束&lt;/p&gt;
&lt;p&gt;方法1：&lt;br&gt;使用wait和notify做到，wait会释放</summary>
      
    
    
    
    <category term="面试" scheme="http://universeinheart.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="http://universeinheart.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java面试</title>
    <link href="http://universeinheart.github.io/2021/05/31/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95666/"/>
    <id>http://universeinheart.github.io/2021/05/31/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95666/</id>
    <published>2021-05-31T15:18:37.000Z</published>
    <updated>2021-05-31T15:26:28.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h4 id="hashMap和HashTable的异同"><a href="#hashMap和HashTable的异同" class="headerlink" title="hashMap和HashTable的异同"></a>hashMap和HashTable的异同</h4><h4 id="HashMap底层数据结构"><a href="#HashMap底层数据结构" class="headerlink" title="HashMap底层数据结构"></a>HashMap底层数据结构</h4><h4 id="HashMap容量为什么要设置为2的幂"><a href="#HashMap容量为什么要设置为2的幂" class="headerlink" title="HashMap容量为什么要设置为2的幂"></a>HashMap容量为什么要设置为2的幂</h4><h4 id="什么是跳表？什么场景用到？"><a href="#什么是跳表？什么场景用到？" class="headerlink" title="什么是跳表？什么场景用到？"></a>什么是跳表？什么场景用到？</h4><p>concurrentSkipListMap 用在多线程下自定义排序顺序时</p><h4 id="为什么使用红黑树不适用普通AVL树"><a href="#为什么使用红黑树不适用普通AVL树" class="headerlink" title="为什么使用红黑树不适用普通AVL树"></a>为什么使用红黑树不适用普通AVL树</h4><h4 id="为什么8到树，6到链表"><a href="#为什么8到树，6到链表" class="headerlink" title="为什么8到树，6到链表"></a>为什么8到树，6到链表</h4><h4 id="说一下volatile"><a href="#说一下volatile" class="headerlink" title="说一下volatile"></a>说一下volatile</h4><h4 id="volatile的可见性和禁止指令重排序如何实现的？"><a href="#volatile的可见性和禁止指令重排序如何实现的？" class="headerlink" title="volatile的可见性和禁止指令重排序如何实现的？"></a>volatile的可见性和禁止指令重排序如何实现的？</h4><p>可见性：缓存一致性协议</p><p>禁止指令重排序：JMM模型有8个指令完成数据的读写，其中通过load和store指令相互组合的4个内存屏障实现指令重排序</p><h4 id="允许null键的Map-有哪些？"><a href="#允许null键的Map-有哪些？" class="headerlink" title="允许null键的Map 有哪些？"></a>允许null键的Map 有哪些？</h4><p>HashMap  LinkedHashMap  weakHashMap</p><h4 id="null键放在HashMap的哪里？"><a href="#null键放在HashMap的哪里？" class="headerlink" title="null键放在HashMap的哪里？"></a>null键放在HashMap的哪里？</h4><p>底层数组的0号位置</p><h4 id="为什么HashTable的扩容是两倍-1"><a href="#为什么HashTable的扩容是两倍-1" class="headerlink" title="为什么HashTable的扩容是两倍+1"></a>为什么HashTable的扩容是两倍+1</h4><p>从除溜余数法，hashtable初始容量方面回答</p><h4 id="红黑树的插入时间复杂度"><a href="#红黑树的插入时间复杂度" class="headerlink" title="红黑树的插入时间复杂度"></a>红黑树的插入时间复杂度</h4><h4 id="解决哈希冲突的方式"><a href="#解决哈希冲突的方式" class="headerlink" title="解决哈希冲突的方式"></a>解决哈希冲突的方式</h4><h4 id="现有1T的数据，内存只有1G，如果排序"><a href="#现有1T的数据，内存只有1G，如果排序" class="headerlink" title="现有1T的数据，内存只有1G，如果排序"></a>现有1T的数据，内存只有1G，如果排序</h4><p>外部排序，多路归并</p><h4 id="tamcat为什么要重写类加载器"><a href="#tamcat为什么要重写类加载器" class="headerlink" title="tamcat为什么要重写类加载器"></a>tamcat为什么要重写类加载器</h4><h4 id="cookie和session介绍一下"><a href="#cookie和session介绍一下" class="headerlink" title="cookie和session介绍一下"></a>cookie和session介绍一下</h4><h4 id="反射，反射会影响性能么"><a href="#反射，反射会影响性能么" class="headerlink" title="反射，反射会影响性能么"></a>反射，反射会影响性能么</h4><h4 id="如何判断内存泄露"><a href="#如何判断内存泄露" class="headerlink" title="如何判断内存泄露"></a>如何判断内存泄露</h4><h4 id="怎么在日志里排查错误？改用那些linux命令？"><a href="#怎么在日志里排查错误？改用那些linux命令？" class="headerlink" title="怎么在日志里排查错误？改用那些linux命令？"></a>怎么在日志里排查错误？改用那些linux命令？</h4><h4 id="如何看待接口和抽象类？"><a href="#如何看待接口和抽象类？" class="headerlink" title="如何看待接口和抽象类？"></a>如何看待接口和抽象类？</h4><h4 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h4><h4 id="hibernate一级缓存和二级缓存"><a href="#hibernate一级缓存和二级缓存" class="headerlink" title="hibernate一级缓存和二级缓存"></a>hibernate一级缓存和二级缓存</h4><h4 id="说一下了解的MQ"><a href="#说一下了解的MQ" class="headerlink" title="说一下了解的MQ"></a>说一下了解的MQ</h4><h4 id="说一下NIO和AIO"><a href="#说一下NIO和AIO" class="headerlink" title="说一下NIO和AIO"></a>说一下NIO和AIO</h4><h4 id="说一下select-poll-epoll"><a href="#说一下select-poll-epoll" class="headerlink" title="说一下select,poll,epoll"></a>说一下select,poll,epoll</h4><h4 id="什么是as-if-serial语义？和happen-before语义有什么区别？"><a href="#什么是as-if-serial语义？和happen-before语义有什么区别？" class="headerlink" title="什么是as-if-serial语义？和happen-before语义有什么区别？"></a>什么是as-if-serial语义？和happen-before语义有什么区别？</h4><p>本质没有区别，前者讲的是单线程程序，后者讲的是多线程程序</p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h4 id="spring的事务传播特性"><a href="#spring的事务传播特性" class="headerlink" title="spring的事务传播特性"></a>spring的事务传播特性</h4><p>IOC底层原理</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="mysql的隔离级别"><a href="#mysql的隔离级别" class="headerlink" title="mysql的隔离级别"></a>mysql的隔离级别</h4><h4 id="B树和B-树的区别？为什么不用红黑树？"><a href="#B树和B-树的区别？为什么不用红黑树？" class="headerlink" title="B树和B+树的区别？为什么不用红黑树？"></a>B树和B+树的区别？为什么不用红黑树？</h4><h4 id="innodb的底层数据结构？"><a href="#innodb的底层数据结构？" class="headerlink" title="innodb的底层数据结构？"></a>innodb的底层数据结构？</h4><h4 id="mysql的原子性和持久性怎么保证？"><a href="#mysql的原子性和持久性怎么保证？" class="headerlink" title="mysql的原子性和持久性怎么保证？"></a>mysql的原子性和持久性怎么保证？</h4><p>undolog。redolog</p><h4 id="怎么解决幻读？"><a href="#怎么解决幻读？" class="headerlink" title="怎么解决幻读？"></a>怎么解决幻读？</h4><p>mvcc+间隙锁</p><h4 id="innodb和myisam区别"><a href="#innodb和myisam区别" class="headerlink" title="innodb和myisam区别"></a>innodb和myisam区别</h4><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><h4 id="主键索引设计应该采用b-tree索引还是hash索引？"><a href="#主键索引设计应该采用b-tree索引还是hash索引？" class="headerlink" title="主键索引设计应该采用b-tree索引还是hash索引？"></a>主键索引设计应该采用b-tree索引还是hash索引？</h4><h4 id="索引不适用条件？"><a href="#索引不适用条件？" class="headerlink" title="索引不适用条件？"></a>索引不适用条件？</h4><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h4 id="你知道哪些设计模式？在JDK源码中如何体现的？"><a href="#你知道哪些设计模式？在JDK源码中如何体现的？" class="headerlink" title="你知道哪些设计模式？在JDK源码中如何体现的？"></a>你知道哪些设计模式？在JDK源码中如何体现的？</h4><h4 id="线程池的设计体现了什么设计模式？"><a href="#线程池的设计体现了什么设计模式？" class="headerlink" title="线程池的设计体现了什么设计模式？"></a>线程池的设计体现了什么设计模式？</h4><h4 id="什么是责任链设计模式？"><a href="#什么是责任链设计模式？" class="headerlink" title="什么是责任链设计模式？"></a>什么是责任链设计模式？</h4><h4 id="wait、notify体现了什么设计模式？"><a href="#wait、notify体现了什么设计模式？" class="headerlink" title="wait、notify体现了什么设计模式？"></a>wait、notify体现了什么设计模式？</h4><h4 id="AIO里用到了什么设计模式？"><a href="#AIO里用到了什么设计模式？" class="headerlink" title="AIO里用到了什么设计模式？"></a>AIO里用到了什么设计模式？</h4><p>观察者</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h4 id="tcp握手挥手过程及其状态转换"><a href="#tcp握手挥手过程及其状态转换" class="headerlink" title="tcp握手挥手过程及其状态转换"></a>tcp握手挥手过程及其状态转换</h4><h4 id="谈一下TCP的拥塞控制"><a href="#谈一下TCP的拥塞控制" class="headerlink" title="谈一下TCP的拥塞控制"></a>谈一下TCP的拥塞控制</h4><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h4 id="synchronized-和-reentrantlock的底层实现及重入的底层原理？"><a href="#synchronized-和-reentrantlock的底层实现及重入的底层原理？" class="headerlink" title="synchronized 和 reentrantlock的底层实现及重入的底层原理？"></a>synchronized 和 reentrantlock的底层实现及重入的底层原理？</h4><ol><li>monitorenter，monitorexit AQS </li><li>重入原理：entrycount state</li></ol><h4 id="锁的四种状态及升级过程"><a href="#锁的四种状态及升级过程" class="headerlink" title="锁的四种状态及升级过程"></a>锁的四种状态及升级过程</h4><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h4 id="concurrentHashMap底层原理"><a href="#concurrentHashMap底层原理" class="headerlink" title="concurrentHashMap底层原理"></a>concurrentHashMap底层原理</h4><h4 id="PriorityQueue底层是什么？初始容量多少，扩容方式？"><a href="#PriorityQueue底层是什么？初始容量多少，扩容方式？" class="headerlink" title="PriorityQueue底层是什么？初始容量多少，扩容方式？"></a>PriorityQueue底层是什么？初始容量多少，扩容方式？</h4><h4 id="CopyOnWriteArrayList是什么？迭代器之前faile-fast么？"><a href="#CopyOnWriteArrayList是什么？迭代器之前faile-fast么？" class="headerlink" title="CopyOnWriteArrayList是什么？迭代器之前faile-fast么？"></a>CopyOnWriteArrayList是什么？迭代器之前faile-fast么？</h4><p>线程安全的ArrayList，写时复制，迭代器采用快照风格，不支持fail-fast</p><h4 id="AQS底层"><a href="#AQS底层" class="headerlink" title="AQS底层"></a>AQS底层</h4><p>CAS+volatile</p><p>state是volatile修饰的，并且设置state的方法除了有setState还有compareAndSetState</p><h4 id="JUC里同步组件主要实现了AQS的那些方法？"><a href="#JUC里同步组件主要实现了AQS的那些方法？" class="headerlink" title="JUC里同步组件主要实现了AQS的那些方法？"></a>JUC里同步组件主要实现了AQS的那些方法？</h4><p>tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared</p><h4 id="除了CAS-原子类，syn-Lock-还有什么线程安全的方式"><a href="#除了CAS-原子类，syn-Lock-还有什么线程安全的方式" class="headerlink" title="除了CAS,原子类，syn,Lock 还有什么线程安全的方式"></a>除了CAS,原子类，syn,Lock 还有什么线程安全的方式</h4><p>final</p><h4 id="什么叫做阻塞队列的有界和无界"><a href="#什么叫做阻塞队列的有界和无界" class="headerlink" title="什么叫做阻塞队列的有界和无界"></a>什么叫做阻塞队列的有界和无界</h4><h4 id="线程池的七个参数"><a href="#线程池的七个参数" class="headerlink" title="线程池的七个参数"></a>线程池的七个参数</h4><h4 id="CAS是什么"><a href="#CAS是什么" class="headerlink" title="CAS是什么"></a>CAS是什么</h4><h4 id="CAS-的ABA问题怎么解决"><a href="#CAS-的ABA问题怎么解决" class="headerlink" title="CAS 的ABA问题怎么解决"></a>CAS 的ABA问题怎么解决</h4><p>AtomicStampedReference，还可用带boolean版本戳的AtomicMarkableReference</p><h4 id="谈谈对高并发理解？什么角度设计高并发程序？"><a href="#谈谈对高并发理解？什么角度设计高并发程序？" class="headerlink" title="谈谈对高并发理解？什么角度设计高并发程序？"></a>谈谈对高并发理解？什么角度设计高并发程序？</h4><h4 id="JUC里限流该怎么做？"><a href="#JUC里限流该怎么做？" class="headerlink" title="JUC里限流该怎么做？"></a>JUC里限流该怎么做？</h4><p>semaphore和guava ratelimiter</p><h4 id="Executors创建线程池的方式？"><a href="#Executors创建线程池的方式？" class="headerlink" title="Executors创建线程池的方式？"></a>Executors创建线程池的方式？</h4><h4 id="CachedThreadPool里面用到是什么阻塞队列？"><a href="#CachedThreadPool里面用到是什么阻塞队列？" class="headerlink" title="CachedThreadPool里面用到是什么阻塞队列？"></a>CachedThreadPool里面用到是什么阻塞队列？</h4><p>synchronousQueue</p><h4 id="LinkedTransferQueue和SynchronousQueue-的区别？"><a href="#LinkedTransferQueue和SynchronousQueue-的区别？" class="headerlink" title="LinkedTransferQueue和SynchronousQueue 的区别？"></a>LinkedTransferQueue和SynchronousQueue 的区别？</h4><h4 id="都有哪些阻塞队列，都有什么特点？"><a href="#都有哪些阻塞队列，都有什么特点？" class="headerlink" title="都有哪些阻塞队列，都有什么特点？"></a>都有哪些阻塞队列，都有什么特点？</h4><p>ArrayBlockingQueue和LinkedBlockingQueue</p><p>linkedBlockingDeque</p><p>PriorityBlockingQueue</p><p>DelayQueue</p><h4 id="LongAdder和AtomicLong什么区别？"><a href="#LongAdder和AtomicLong什么区别？" class="headerlink" title="LongAdder和AtomicLong什么区别？"></a>LongAdder和AtomicLong什么区别？</h4><p>AtomicLong相当于多线程竞争一次修改value的机会，longAdder把value拆成多个值放在cell数组里，相当于多线程竞争多次修改value的机会，性能自然上升</p><h4 id="什么是LongAccumulator？"><a href="#什么是LongAccumulator？" class="headerlink" title="什么是LongAccumulator？"></a>什么是LongAccumulator？</h4><p>不仅支持加法还支持自定义操作</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>JMM共享内存模型以及8个原子操作指令</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h4><h4 id="对象在内存中的存储布局？"><a href="#对象在内存中的存储布局？" class="headerlink" title="对象在内存中的存储布局？"></a>对象在内存中的存储布局？</h4><p>对象头、类元指针、实例数据、对齐填充</p><h4 id="对象头包括什么？"><a href="#对象头包括什么？" class="headerlink" title="对象头包括什么？"></a>对象头包括什么？</h4><h4 id="对象怎么定位？"><a href="#对象怎么定位？" class="headerlink" title="对象怎么定位？"></a>对象怎么定位？</h4><p>直接指针、句柄</p><h4 id="堆是什么划分的？"><a href="#堆是什么划分的？" class="headerlink" title="堆是什么划分的？"></a>堆是什么划分的？</h4><h4 id="对象怎么分配？"><a href="#对象怎么分配？" class="headerlink" title="对象怎么分配？"></a>对象怎么分配？</h4><p>栈上分配，TLAB，新生代，老年代</p><h4 id="CMS流程？"><a href="#CMS流程？" class="headerlink" title="CMS流程？"></a>CMS流程？</h4><h4 id="Object-obj-new-Object-在内存中占用了多少内存？"><a href="#Object-obj-new-Object-在内存中占用了多少内存？" class="headerlink" title="Object obj = new Object();在内存中占用了多少内存？"></a>Object obj = new Object();在内存中占用了多少内存？</h4><p>引用变量4byte，Object对象头12Byte，对齐填充到16byte，一共20byte</p><h4 id="CMS和G1的异同"><a href="#CMS和G1的异同" class="headerlink" title="CMS和G1的异同"></a>CMS和G1的异同</h4><h4 id="G1什么时候引发FullGC"><a href="#G1什么时候引发FullGC" class="headerlink" title="G1什么时候引发FullGC"></a>G1什么时候引发FullGC</h4><h4 id="Java运行时数据区"><a href="#Java运行时数据区" class="headerlink" title="Java运行时数据区"></a>Java运行时数据区</h4><h4 id="最熟悉的垃圾回收算法"><a href="#最熟悉的垃圾回收算法" class="headerlink" title="最熟悉的垃圾回收算法"></a>最熟悉的垃圾回收算法</h4><h4 id="吞吐量优先和响应时间优先的回收器是哪些？"><a href="#吞吐量优先和响应时间优先的回收器是哪些？" class="headerlink" title="吞吐量优先和响应时间优先的回收器是哪些？"></a>吞吐量优先和响应时间优先的回收器是哪些？</h4><p>parallel scvenge 和 CMS</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><h4 id="无序数组找出第k大的数"><a href="#无序数组找出第k大的数" class="headerlink" title="无序数组找出第k大的数"></a>无序数组找出第k大的数</h4><h4 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h4><h4 id="n个物品每个商品都有一定的价值，分给两个人，怎么分两个人的价值差最小"><a href="#n个物品每个商品都有一定的价值，分给两个人，怎么分两个人的价值差最小" class="headerlink" title="n个物品每个商品都有一定的价值，分给两个人，怎么分两个人的价值差最小"></a>n个物品每个商品都有一定的价值，分给两个人，怎么分两个人的价值差最小</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;h4 id=&quot;hashMap和HashTable的异同&quot;&gt;&lt;a href=&quot;#hashMap和HashTable的异同&quot; class=&quot;head</summary>
      
    
    
    
    <category term="面试" scheme="http://universeinheart.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="http://universeinheart.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor源码解析</title>
    <link href="http://universeinheart.github.io/2021/05/30/%E9%A9%AC%E8%80%81%E5%B8%88/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://universeinheart.github.io/2021/05/30/%E9%A9%AC%E8%80%81%E5%B8%88/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2021-05-30T15:26:37.000Z</published>
    <updated>2021-05-30T09:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadPoolExecutor源码解析"><a href="#ThreadPoolExecutor源码解析" class="headerlink" title="ThreadPoolExecutor源码解析"></a>ThreadPoolExecutor源码解析</h1><h3 id="1、常用变量的解释"><a href="#1、常用变量的解释" class="headerlink" title="1、常用变量的解释"></a>1、常用变量的解释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. `ctl`，可以看做一个int类型的数字，高3位表示线程池状态，低29位表示worker数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 2. `COUNT_BITS`，`Integer.SIZE`为32，所以`COUNT_BITS`为29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 3. `CAPACITY`，线程池允许的最大线程数。1左移29位，然后减1，即为 2^29 - 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">// 4. 线程池有5种状态，按大小排序如下：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 5. `runStateOf()`，获取线程池状态，通过按位与操作，低29位将全部变成0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 6. `workerCountOf()`，获取线程池worker数量，通过按位与操作，高3位将全部变成0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 7. `ctlOf()`，根据线程池状态和线程池worker数量，生成ctl值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit field accessors that don&#x27;t require unpacking ctl.</span></span><br><span class="line"><span class="comment"> * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 8. `runStateLessThan()`，线程池状态小于xx</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 9. `runStateAtLeast()`，线程池状态大于等于xx</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本类型参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 空指针校验</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="comment">// 根据传入参数`unit`和`keepAliveTime`，将存活时间转换为纳秒存到变量`keepAliveTime `中</span></span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、提交执行task的过程"><a href="#3、提交执行task的过程" class="headerlink" title="3、提交执行task的过程"></a>3、提交执行task的过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// worker数量比核心线程数小，直接创建worker执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// worker数量超过核心线程数，任务直接进入队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作。</span></span><br><span class="line">        <span class="comment">// 这儿为什么需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 这儿为什么需要判断0值，主要是在线程池构造方法中，核心线程数允许为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务。</span></span><br><span class="line">    <span class="comment">// 这儿有3点需要注意：</span></span><br><span class="line">    <span class="comment">// 1. 线程池不是运行状态时，addWorker内部会判断线程池状态</span></span><br><span class="line">    <span class="comment">// 2. addWorker第2个参数表示是否创建核心线程</span></span><br><span class="line">    <span class="comment">// 3. addWorker返回false，则说明任务执行失败，需要执行reject操作</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、addworker源码解析"><a href="#4、addworker源码解析" class="headerlink" title="4、addworker源码解析"></a>4、addworker源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 外层自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个条件写得比较难懂，我对其进行了调整，和下面的条件等价</span></span><br><span class="line">        <span class="comment">// (rs &gt; SHUTDOWN) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; firstTask != null) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; workQueue.isEmpty())</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态大于SHUTDOWN时，直接返回false</span></span><br><span class="line">        <span class="comment">// 2. 线程池状态等于SHUTDOWN，且firstTask不为null，直接返回false</span></span><br><span class="line">        <span class="comment">// 3. 线程池状态等于SHUTDOWN，且队列为空，直接返回false</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// worker数量超过容量，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 使用CAS的方式增加worker数量。</span></span><br><span class="line">            <span class="comment">// 若增加成功，则直接跳出外层循环进入到第二部分</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 线程池状态发生变化，对外层循环进行自旋</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 其他情况，直接内层循环进行自旋即可</span></span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// worker的添加必须是串行的，因此需要加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">// 这儿需要重新检查线程池状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// worker已经调用过了start()方法，则不再创建worker</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// worker创建并添加到workers成功</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 更新`largestPoolSize`变量</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动worker线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// worker线程启动失败，说明线程池状态发生了变化（关闭操作被执行），需要进行shutdown相关操作</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、线程池worker任务单元"><a href="#5、线程池worker任务单元" class="headerlink" title="5、线程池worker任务单元"></a>5、线程池worker任务单元</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 这儿是Worker的关键所在，使用了线程工厂创建了一个线程。传入的参数为当前worker</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、核心线程执行逻辑-runworker"><a href="#6、核心线程执行逻辑-runworker" class="headerlink" title="6、核心线程执行逻辑-runworker"></a>6、核心线程执行逻辑-runworker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 调用unlock()是为了让外部可以中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 这个变量用于判断是否进入过自旋（while循环）</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这儿是自旋</span></span><br><span class="line">        <span class="comment">// 1. 如果firstTask不为null，则执行firstTask；</span></span><br><span class="line">        <span class="comment">// 2. 如果firstTask为null，则调用getTask()从队列获取任务。</span></span><br><span class="line">        <span class="comment">// 3. 阻塞队列的特性就是：当队列为空时，当前线程会被阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这儿对worker进行加锁，是为了达到下面的目的</span></span><br><span class="line">            <span class="comment">// 1. 降低锁范围，提升性能</span></span><br><span class="line">            <span class="comment">// 2. 保证每个worker执行的任务是串行的</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 如果线程池正在停止，则对当前线程进行中断操作</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="comment">// 执行任务，且在执行前后通过`beforeExecute()`和`afterExecute()`来扩展其功能。</span></span><br><span class="line">            <span class="comment">// 这两个方法在当前类里面为空实现。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 帮助gc</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 已完成任务数加一 </span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋操作被退出，说明线程池正在结束</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="跟马老师学编程" scheme="http://universeinheart.github.io/categories/%E8%B7%9F%E9%A9%AC%E8%80%81%E5%B8%88%E5%AD%A6%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="http://universeinheart.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="http://universeinheart.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="线程池" scheme="http://universeinheart.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>高性能队列——Disruptor</title>
    <link href="http://universeinheart.github.io/2021/05/30/Java/001/"/>
    <id>http://universeinheart.github.io/2021/05/30/Java/001/</id>
    <published>2021-05-30T15:18:37.000Z</published>
    <updated>2021-05-30T14:49:12.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java内置队列"><a href="#Java内置队列" class="headerlink" title="Java内置队列"></a>Java内置队列</h2><p>看一看常用的线程安全的内置队列有什么问题</p><table><thead><tr><th align="left">队列</th><th align="left">有界性</th><th align="left">锁</th><th align="left">数据结构</th></tr></thead><tbody><tr><td align="left">ArrayBlockingQueue</td><td align="left">bounded</td><td align="left">加锁</td><td align="left">arraylist</td></tr><tr><td align="left">LinkedBlockingQueue</td><td align="left">optionally-bounded</td><td align="left">加锁</td><td align="left">linkedlist</td></tr><tr><td align="left">ConcurrentLinkedQueue</td><td align="left">unbounded</td><td align="left">无锁</td><td align="left">linkedlist</td></tr><tr><td align="left">LinkedTransferQueue</td><td align="left">unbounded</td><td align="left">无锁</td><td align="left">linkedlist</td></tr><tr><td align="left">PriorityBlockingQueue</td><td align="left">unbounded</td><td align="left">加锁</td><td align="left">heap</td></tr><tr><td align="left">DelayQueue</td><td align="left">unbounded</td><td align="left">加锁</td><td align="left">heap</td></tr></tbody></table><p>通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在确定的范围内）；而加锁的方式，可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列；同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array/heap格式的数据结构。这样筛选下来，符合条件的队列就只有<code>ArrayBlockingQueue</code>。</p><h2 id="ArrayBlockingQueue的问题"><a href="#ArrayBlockingQueue的问题" class="headerlink" title="ArrayBlockingQueue的问题"></a>ArrayBlockingQueue的问题</h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>现实编程过程中，加锁通常会严重地影响性能。线程会因为竞争不到锁而被挂起，等锁被释放的时候，线程又会被恢复，这个过程中存在着很大的开销，并且通常会有较长时间的中断，因为当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，例如发生了缺页错误、调度延迟或者其它类似情况，那么所有需要这个锁的线程都无法执行下去。</p><p>单线程情况下，<strong>不加锁的性能 &gt; CAS操作的性能 &gt; 加锁的性能</strong>。在多线程情况下，为了保证线程安全，必须使用CAS或锁，这种情况下，CAS的性能超过锁的性能，前者大约是后者的8倍。综上可知，加锁的性能是最差的。</p><p><strong>保证线程安全一般分成两种方式：锁和原子变量</strong></p><p><code>ArrayBlockingQueue</code>通过加锁的方式实现的<code>offer</code>方法，保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            insert(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过原子变量可以实现线程安全。执行某个任务的时候，先假定不会有冲突，若不发生冲突，则直接执行成功；当发生冲突的时候，则执行失败，回滚再重新操作，直到不发生冲突。CAS会先把Entry现在的value跟线程当初读出的值相比较，若相同，则赋值；若不相同，则赋值执行失败。一般会通过while/for循环来重新执行，直到赋值成功。</p><p>代码示例是<code>AtomicInteger</code>的<code>getAndAdd</code>方法。CAS是CPU的一个指令，由CPU保证原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + delta;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment"> * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful. False return indicates that</span></span><br><span class="line"><span class="comment"> * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在高度竞争的情况下，锁的性能将超过原子变量的性能，但是更真实的竞争情况下，原子变量的性能将超过锁的性能。同时原子变量不会有死锁等活跃性问题。</p><h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><p><strong>缓存行</strong></p><p><code>Cache</code>是由很多个<code>cache line</code>组成的。每个<code>cache line</code>通常是64字节，并且它有效地引用主内存中的一块儿地址。</p><p>一个Java的long类型变量是8字节，因此在一个缓存行中可以存8个long类型的变量。</p><p>CPU每次从主存中拉取数据时，会把相邻的数据也存入同一个<code>cache line</code>。</p><p>在访问一个long数组的时候，如果数组中的一个值被加载到缓存中，它会自动加载另外7个。因此你能非常快的遍历这个数组。事实上，你可以非常快速的遍历在连续内存块中分配的任意数据结构。</p><p><strong>什么是伪共享</strong></p><p><code>ArrayBlockingQueue</code>有三个成员变量： </p><ul><li><code>takeIndex</code>：需要被取走的元素下标</li><li><code>putIndex</code>：可被元素插入的位置的下标</li><li><code>count</code>：队列中元素的数量</li></ul><p>这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。</p><img src="/2021/05/30/Java/001/image-20210530174002602.png" class="" title="image-20210530174002602"><p>如上图所示，当生产者线程put一个元素到<code>ArrayBlockingQueue</code>时，<code>putIndex</code>会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。</p><p>这种无法充分使用缓存行特性的现象，称为伪共享。</p><p>对于伪共享，一般的解决方案是，增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上，以空间换时间。</p><p>备注：在jdk1.8中，有专门的注解<code>@Contended</code>来避免伪共享，更优雅地解决问题。</p><h2 id="Disruptor的设计方案"><a href="#Disruptor的设计方案" class="headerlink" title="Disruptor的设计方案"></a>Disruptor的设计方案</h2><p><code>Disruptor</code>通过以下设计来解决队列速度慢的问题：</p><ul><li><p><strong>环形数组结构</strong> : 为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。</p></li><li><p><strong>元素位置定位</strong> : 数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心<code>index</code>溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</p></li><li><p><strong>无锁设计</strong> : 每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</p></li></ul><h3 id="一个生产者"><a href="#一个生产者" class="headerlink" title="一个生产者"></a>一个生产者</h3><p><strong>写数据</strong></p><p>生产者单线程写数据的流程比较简单：</p><ol><li>申请写入m个元素；</li><li>若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素；</li><li>若是返回的正确，则生产者开始写入元素。</li></ol><img src="/2021/05/30/Java/001/image-20210530174552002.png" class="" title="image-20210530174552002"><h3 id="多个生产者"><a href="#多个生产者" class="headerlink" title="多个生产者"></a>多个生产者</h3><p>多个生产者的情况下，会遇到“<strong>如何防止多个线程重复写同一个元素</strong>”的问题。</p><p><code>Disruptor</code>的解决方法是，每个线程获取不同的一段数组空间进行操作。这个通过CAS很容易达到。只需要在分配元素的时候，通过CAS判断一下这段空间是否已经分配出去即可。</p><p>但是会遇到一个新问题：<strong>如何防止读取的时候，读到还未写的元素</strong>。</p><p><code>Disruptor</code>在多个生产者的情况下，引入了一个与<code>Ring Buffer</code>大小相同的buffer：<code>available Buffer</code>。</p><p>当某个位置写入成功的时候，便把<code>availble Buffer</code>相应的位置置位，标记为写入成功。读取的时候，会遍历<code>available Buffer</code>，来判断元素是否已经就绪。</p><p>下面分读数据和写数据两种情况介绍。</p><h4 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h4><p>生产者多线程写入的情况会复杂很多：</p><ol><li>申请读取到序号n；</li><li>若<code>writer cursor</code> &gt;= n，这时仍然无法确定连续可读的最大下标。从<code>reader cursor</code>开始读取<code>available Buffer</code>，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；</li><li>消费者读取元素。</li></ol><p>如下图所示，读线程读到下标为2的元素，三个线程Writer1/Writer2/Writer3正在向RingBuffer相应位置写数据，写线程被分配到的最大元素下标是11。</p><p>读线程申请读取到下标从3到11的元素，判断writer cursor&gt;=11。然后开始读取availableBuffer，从3开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。</p><p>然后，消费者读取下标从3到6共计4个元素。</p><img src="/2021/05/30/Java/001/image-20210530182223173.png" class="" title="image-20210530182223173"><h4 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h4><p>多个生产者写入的时候：</p><ol><li>申请写入m个元素；</li><li>若是有m个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；</li><li>生产者写入元素，写入元素的同时设置<code>available Buffer</code>里面相应的位置，以标记自己哪些位置是已经写入成功的。</li></ol><p>如下图所示，Writer1和Writer2两个线程写入数组，都申请可写的数组空间。Writer1被分配了下标3到下表5的空间，Writer2被分配了下标6到下标9的空间。</p><p>Writer1写入下标3位置的元素，同时把available Buffer相应位置置位，标记已经写入成功，往后移一位，开始写下标4位置的元素。Writer2同样的方式。最终都写入完成。</p><img src="/2021/05/30/Java/001/image-20210530182519541.png" class="" title="image-20210530182519541"><p>防止不同生产者对同一段空间写入的代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryNext</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> InsufficientCapacityException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;n must be &gt; 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> current;</span><br><span class="line">    <span class="keyword">long</span> next;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        current = cursor.get();</span><br><span class="line">        next = current + n;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!hasAvailableCapacity(gatingSequences, n, current)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> InsufficientCapacityException.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!cursor.compareAndSet(current, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>do/while</code>循环的条件<code>cursor.compareAndSet(current, next)</code>，来判断每次申请的空间是否已经被其他生产者占据。假如已经被占据，该函数会返回失败，While循环重新执行，申请写入空间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Disruptor</code>通过精巧的无锁设计实现了在高并发情形下的高性能。</p><p>在美团内部，很多高并发场景借鉴了<code>Disruptor</code>的设计，减少竞争的强度。其设计思想可以扩展到分布式场景，通过无锁设计，来提升服务性能。</p><p>使用<code>Disruptor</code>比使用<code>ArrayBlockingQueue</code>略微复杂，为方便读者上手，增加代码样例。</p><p>代码实现的功能：每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端。详细逻辑请细读代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.meituan.Disruptor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> disruptor代码样例。每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.*;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.Disruptor;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.ProducerType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisruptorMain</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 队列中的元素</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value= value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者的线程工厂</span></span><br><span class="line">        ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactory()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;simpleThread&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RingBuffer生产工厂,初始化RingBuffer的时候使用</span></span><br><span class="line">        EventFactory&lt;Element&gt; factory = <span class="keyword">new</span> EventFactory&lt;Element&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Element <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Element();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理Event的handler</span></span><br><span class="line">        EventHandler&lt;Element&gt; handler = <span class="keyword">new</span> EventHandler&lt;Element&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Element element, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Element: &quot;</span> + element.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞策略</span></span><br><span class="line">        BlockingWaitStrategy strategy = <span class="keyword">new</span> BlockingWaitStrategy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定RingBuffer的大小</span></span><br><span class="line">        <span class="keyword">int</span> bufferSize = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建disruptor，采用单生产者模式</span></span><br><span class="line">        Disruptor&lt;Element&gt; disruptor = <span class="keyword">new</span> Disruptor(factory, bufferSize, threadFactory, ProducerType.SINGLE, strategy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置EventHandler</span></span><br><span class="line">        disruptor.handleEventsWith(handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动disruptor的线程</span></span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        RingBuffer&lt;Element&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; <span class="keyword">true</span>; l++) &#123;</span><br><span class="line">            <span class="comment">// 获取下一个可用位置的下标</span></span><br><span class="line">            <span class="keyword">long</span> sequence = ringBuffer.next();  </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 返回可用位置的元素</span></span><br><span class="line">                Element event = ringBuffer.get(sequence); </span><br><span class="line">                <span class="comment">// 设置该位置元素的值</span></span><br><span class="line">                event.set(l); </span><br><span class="line">            &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">                ringBuffer.publish(sequence);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java内置队列&quot;&gt;&lt;a href=&quot;#Java内置队列&quot; class=&quot;headerlink&quot; title=&quot;Java内置队列&quot;&gt;&lt;/a&gt;Java内置队列&lt;/h2&gt;&lt;p&gt;看一看常用的线程安全的内置队列有什么问题&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
</summary>
      
    
    
    
    <category term="Java" scheme="http://universeinheart.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://universeinheart.github.io/tags/Java/"/>
    
    <category term="队列" scheme="http://universeinheart.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>羽毛球教程</title>
    <link href="http://universeinheart.github.io/2021/05/25/%E7%BE%BD%E6%AF%9B%E7%90%83/00/"/>
    <id>http://universeinheart.github.io/2021/05/25/%E7%BE%BD%E6%AF%9B%E7%90%83/00/</id>
    <published>2021-05-25T15:18:37.000Z</published>
    <updated>2021-05-26T00:20:55.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="后场高位击球和前场反手击球发力方法"><a href="#后场高位击球和前场反手击球发力方法" class="headerlink" title="后场高位击球和前场反手击球发力方法"></a>后场高位击球和前场反手击球发力方法</h2><p>争取<strong>高手位主动击球</strong>是羽毛球运动最重要的意识之一，要通过判断，移动，取位获得对球的主动控制权</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;后场高位击球和前场反手击球发力方法&quot;&gt;&lt;a href=&quot;#后场高位击球和前场反手击球发力方法&quot; class=&quot;headerlink&quot; title=&quot;后场高位击球和前场反手击球发力方法&quot;&gt;&lt;/a&gt;后场高位击球和前场反手击球发力方法&lt;/h2&gt;&lt;p&gt;争取&lt;strong&gt;</summary>
      
    
    
    
    <category term="羽毛球" scheme="http://universeinheart.github.io/categories/%E7%BE%BD%E6%AF%9B%E7%90%83/"/>
    
    
    <category term="羽毛球" scheme="http://universeinheart.github.io/tags/%E7%BE%BD%E6%AF%9B%E7%90%83/"/>
    
  </entry>
  
  <entry>
    <title>01.多线程与高并发编程</title>
    <link href="http://universeinheart.github.io/2021/05/18/%E9%A9%AC%E8%80%81%E5%B8%88/01/"/>
    <id>http://universeinheart.github.io/2021/05/18/%E9%A9%AC%E8%80%81%E5%B8%88/01/</id>
    <published>2021-05-18T15:26:37.000Z</published>
    <updated>2021-05-31T16:35:02.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello MyThread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello MyRun!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRun()).start();</span><br><span class="line">    <span class="comment">// Java8</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Lambda!&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 面试题：请你告诉我启动线程的三种方式 1：Thread 2: Runnable 3:线程池</p></blockquote><p>Yield：谦让的退出一下，让出一下CPU，返回就绪状态</p><p>Join：让“主线程”等待“子线程”结束之后才能继续运行</p><img src="/2021/05/18/%E9%A9%AC%E8%80%81%E5%B8%88/01/image-20210517221957203.png" class="" title="image-20210517221957203"><p>wait：释放锁</p><p>notify：不释放锁</p><h3 id="Java中线程调度图"><a href="#Java中线程调度图" class="headerlink" title="Java中线程调度图"></a>Java中线程调度图</h3><img src="/2021/05/18/%E9%A9%AC%E8%80%81%E5%B8%88/01/image-20210517222106298.png" class="" title="image-20210517222106298"><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p><strong>可重入的</strong>（必须是可重入的，不然就死锁了）</p><p><strong>抛出异常，锁将被释放</strong></p><p>Synchronized锁的是<strong>对象</strong></p><img src="/2021/05/18/%E9%A9%AC%E8%80%81%E5%B8%88/01/image-20210517231304213.png" class="" title="image-20210517231304213"><p>锁信息就是记录在对象头中的<code>Mark Word</code>，<code>Mark Word</code>,用于存储自身的运行时数据，如：<strong>HashCode</strong>,<strong>GC分代年龄</strong>，<strong>锁标记</strong>、<strong>偏向锁线程ID</strong>等</p><blockquote><p>Synchronized锁升级过程</p><ol><li>只有一个线程获得到锁，记录这个线程的ID（偏向锁）</li><li>如果有线程争用，升级为自旋锁（占用CPU，不访问操作系统，处于用户态而不是内核态，加锁解锁效率比内核态高）</li><li>线程执行时间短（加锁代码），并且线程数少的情况下使用自旋锁，以为执行时间短，如果访问内核态的开销可能大于线程执行的开销 </li><li>自旋锁自旋10次后还没获取到锁后，升级为重量级锁，需要找操作系统申请锁</li></ol><p>锁细化和粗话</p><ul><li>细化，类似是行锁比表锁要性能高</li><li>粗化，如果每行都加锁，还不如加表锁</li></ul></blockquote><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><ul><li>保证线程可见性</li><li>禁止指令重排序(CPU)</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>无锁优化，自旋</p><p>compare and swap</p><blockquote><p>ABA问题</p><p>如果是Integer类型，无所谓的，引用类型不确定</p><p>可以是使用version解决（AtomicStampedReference）</p></blockquote><h3 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h3><p><strong>强</strong></p><p>有强引用不会被回收</p><p><strong>软</strong></p><p>作用：大对象的缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;byte[]&gt; m &#x3D; new SoftReference&lt;&gt;(new byte[1024*1024*10]);</span><br><span class="line">m.get();  &#x2F;&#x2F; 打印字节数组的内存地址</span><br><span class="line">System.gc();</span><br><span class="line">&#x2F;&#x2F; 其他操作，导致内存不足</span><br><span class="line">m.get();  &#x2F;&#x2F; 打印 null</span><br></pre></td></tr></table></figure><p><strong>弱</strong></p><p>作用： 缓存，没有容器引用指向的时候需要清除缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;M&gt; m = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>]);</span><br></pre></td></tr></table></figure><ul><li>ThreadLocal</li><li>WeakHashMap</li></ul><img src="/2021/05/18/%E9%A9%AC%E8%80%81%E5%B8%88/01/image-20210527073417772.png" class="" title="image-20210527073417772"><p><strong>虚</strong></p><h2 id="JUC同步工具"><a href="#JUC同步工具" class="headerlink" title="JUC同步工具"></a>JUC同步工具</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>condition</p><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>countDown</p><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>await</p><h3 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h3><p>bulkRegister</p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>readLock</p><p>writeLock</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>acquire</p><p>release</p><h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><img src="/2021/05/18/%E9%A9%AC%E8%80%81%E5%B8%88/01/image-20210525232330177.png" class="" title="image-20210525232330177"><blockquote><p>模板方法设计模式</p><p>AbstractQueuedSynchronizer</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li></ul></blockquote><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal线程局部变量，是使用空间换时间</p><p><code>ThreadLocal.ThreadLocalMap = Thread.threadLocals</code></p><h2 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><p>有序</p><blockquote><p>跳表</p><img src="/2021/05/18/%E9%A9%AC%E8%80%81%E5%B8%88/01/image-20210527221734109.png" class="" title="image-20210527221734109"></blockquote><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>add方法加锁</p><p>读多写少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>无界队列</p><p>链表</p><p>非阻塞</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>无界队列</p><p>链表</p><p>阻塞</p><blockquote><p>put方法，如果队列满了会阻塞住</p><p>take方法，如果队列空了会阻塞住</p></blockquote><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>有界队列</p><p>数组</p><p>阻塞</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>按照等待时间排序</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>容量为0</p><p>线程之间传递</p><ul><li>put 方法 ：阻塞等待消费者消费</li><li>take 方法：阻塞等待生产者生产</li></ul><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>线程之间传递</p><ul><li>transfer 方法 ：阻塞等待消费者消费</li><li>take 方法：阻塞等待生产者生产</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="主要接口"><a href="#主要接口" class="headerlink" title="主要接口"></a>主要接口</h3><div class="mermaid">classDiagram      Executor &lt;|-- ExecutorService      ExecutorService &lt;|-- ThreadPoolExecutor</div><blockquote><p>CompletableFuture : 可以用来管理多个线程返回Future</p></blockquote><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="跟马老师学编程" scheme="http://universeinheart.github.io/categories/%E8%B7%9F%E9%A9%AC%E8%80%81%E5%B8%88%E5%AD%A6%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="http://universeinheart.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="http://universeinheart.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>08.Web 进阶开发</title>
    <link href="http://universeinheart.github.io/2021/05/17/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/08/"/>
    <id>http://universeinheart.github.io/2021/05/17/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/08/</id>
    <published>2021-05-17T15:28:37.000Z</published>
    <updated>2021-05-16T09:09:13.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计好的-RESTful-Web-Service"><a href="#设计好的-RESTful-Web-Service" class="headerlink" title="设计好的 RESTful Web Service"></a>设计好的 RESTful Web Service</h2><h2 id="什么是-HATEOAS"><a href="#什么是-HATEOAS" class="headerlink" title="什么是 HATEOAS"></a>什么是 HATEOAS</h2><h2 id="使⽤-Spring-Data-REST-实现简单的超媒体服务"><a href="#使⽤-Spring-Data-REST-实现简单的超媒体服务" class="headerlink" title="使⽤ Spring Data REST 实现简单的超媒体服务"></a>使⽤ Spring Data REST 实现简单的超媒体服务</h2><h2 id="分布式环境中如何解决-Session-的问题"><a href="#分布式环境中如何解决-Session-的问题" class="headerlink" title="分布式环境中如何解决 Session 的问题"></a>分布式环境中如何解决 Session 的问题</h2><h2 id="使⽤-WebFlux-代替-Spring-MVC"><a href="#使⽤-WebFlux-代替-Spring-MVC" class="headerlink" title="使⽤ WebFlux 代替 Spring MVC"></a>使⽤ WebFlux 代替 Spring MVC</h2>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="Web" scheme="http://universeinheart.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>07.Web 资源</title>
    <link href="http://universeinheart.github.io/2021/05/17/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/07/"/>
    <id>http://universeinheart.github.io/2021/05/17/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/07/</id>
    <published>2021-05-17T15:27:37.000Z</published>
    <updated>2021-05-16T09:07:51.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过-RestTemplate-访问-Web-资源"><a href="#通过-RestTemplate-访问-Web-资源" class="headerlink" title="通过 RestTemplate 访问 Web 资源"></a>通过 RestTemplate 访问 Web 资源</h2><h2 id="RestTemplate-的⾼阶⽤法"><a href="#RestTemplate-的⾼阶⽤法" class="headerlink" title="RestTemplate 的⾼阶⽤法"></a>RestTemplate 的⾼阶⽤法</h2><h2 id="简单定制-RestTemplate"><a href="#简单定制-RestTemplate" class="headerlink" title="简单定制 RestTemplate"></a>简单定制 RestTemplate</h2><h2 id="通过-WebClient-访问-Web-资源"><a href="#通过-WebClient-访问-Web-资源" class="headerlink" title="通过 WebClient 访问 Web 资源"></a>通过 WebClient 访问 Web 资源</h2>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="Web" scheme="http://universeinheart.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>06.Web</title>
    <link href="http://universeinheart.github.io/2021/05/17/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/06/"/>
    <id>http://universeinheart.github.io/2021/05/17/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/06/</id>
    <published>2021-05-17T15:26:37.000Z</published>
    <updated>2021-05-27T01:13:28.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-MVC-实践"><a href="#Spring-MVC-实践" class="headerlink" title="Spring MVC 实践"></a>Spring MVC 实践</h2><h3 id="认识-Spring-MVC"><a href="#认识-Spring-MVC" class="headerlink" title="认识 Spring MVC"></a>认识 Spring MVC</h3><p><strong>DispatcherServlet</strong></p><ul><li>Controller</li><li>xxxResolver<ul><li>ViewResolver</li><li>HandlerExceptionResolver</li><li>MultipartResolver</li></ul></li><li>HandlerMapping</li></ul><h3 id="Spring-MVC-中的常⽤注解"><a href="#Spring-MVC-中的常⽤注解" class="headerlink" title="Spring MVC 中的常⽤注解"></a>Spring MVC 中的常⽤注解</h3><ul><li>@Controller / @RestController</li><li>@RequestMapping<ul><li>@GetMapping</li><li>@PostMapping</li><li>@PutMapping</li><li>@DeleteMapping</li></ul></li><li>@RequestBody / @ResponseBody / @ResponseStatus</li></ul><h2 id="理解-Spring-的应⽤上下⽂"><a href="#理解-Spring-的应⽤上下⽂" class="headerlink" title="理解 Spring 的应⽤上下⽂"></a>理解 Spring 的应⽤上下⽂</h2><img src="/2021/05/17/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/06/image-20210527090546362.png" class="" title="image-20210527090546362"><p>上下⽂常⽤的接⼝</p><ul><li>BeanFactory <ul><li>DefaultListableBeanFactory</li></ul></li><li>ApplicationContext<ul><li>ClassPathXmlApplicationContext</li><li>FileSystemXmlApplicationContext</li><li>AnnotationConfigApplicationContext </li></ul></li><li>WebApplicationContext</li></ul><blockquote><p>应用上下文存在层级关系，使用不当可能导致AOP未生效</p></blockquote><h2 id="Spring-MVC-中的各种机制"><a href="#Spring-MVC-中的各种机制" class="headerlink" title="Spring MVC 中的各种机制"></a>Spring MVC 中的各种机制</h2><p>file:///E:/2021/ideaProject/geektime-spring-family/PDF/%E7%AC%AC6%E7%AB%A0.pdf</p><h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><h3 id="视图处理"><a href="#视图处理" class="headerlink" title="视图处理"></a>视图处理</h3><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h2 id="如何定义处理⽅法"><a href="#如何定义处理⽅法" class="headerlink" title="如何定义处理⽅法"></a>如何定义处理⽅法</h2><h2 id="Spring-MVC-中的常⽤视图"><a href="#Spring-MVC-中的常⽤视图" class="headerlink" title="Spring MVC 中的常⽤视图"></a>Spring MVC 中的常⽤视图</h2><h2 id="静态资源与缓存"><a href="#静态资源与缓存" class="headerlink" title="静态资源与缓存"></a>静态资源与缓存</h2><h2 id="了解-Spring-MVC-的切⼊点"><a href="#了解-Spring-MVC-的切⼊点" class="headerlink" title="了解 Spring MVC 的切⼊点"></a>了解 Spring MVC 的切⼊点</h2>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="Web" scheme="http://universeinheart.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>05.数据访问进阶</title>
    <link href="http://universeinheart.github.io/2021/05/16/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/05/"/>
    <id>http://universeinheart.github.io/2021/05/16/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/05/</id>
    <published>2021-05-16T15:26:37.000Z</published>
    <updated>2021-05-16T09:01:42.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reactor-核⼼的概念"><a href="#Reactor-核⼼的概念" class="headerlink" title="Reactor 核⼼的概念"></a>Reactor 核⼼的概念</h2><p><strong>Operators - Publisher / Subscriber</strong></p><ul><li>Nothing Happens Until You subscribe()</li><li><code>Flux</code> [ 0..N ] - onNext()、onComplete()、onError()</li><li><code>Mono</code> [ 0..1 ] - onNext()、onComplete()、onError()</li></ul><p><strong>Backpressure</strong></p><ul><li>Subscription</li><li>onRequest()、onCancel()、onDispose()</li></ul><p><strong>线程调度Schedulers</strong></p><ul><li>immediate() / single() / newSingle()</li><li>elastic() / parallel() / newParallel() </li></ul><p><strong>错误处理</strong> </p><ul><li>onError / onErrorReturn / onErrorResume</li><li>doOnError / doFinally</li></ul><h2 id="通过-Reactive-的⽅式访问"><a href="#通过-Reactive-的⽅式访问" class="headerlink" title="通过 Reactive 的⽅式访问"></a>通过 Reactive 的⽅式访问</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><strong>Lettuce 能够⽀持 Reactive ⽅式</strong></p><p><strong>Spring Data Redis 中主要的⽀持</strong></p><ul><li>ReactiveRedisConnection</li><li>ReactiveRedisConnectionFactory</li><li>ReactiveRedisTemplate</li></ul><h2 id="通过-AOP-打印数据访问层摘要"><a href="#通过-AOP-打印数据访问层摘要" class="headerlink" title="通过 AOP 打印数据访问层摘要"></a>通过 AOP 打印数据访问层摘要</h2><img src="/2021/05/16/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/05/image-20210516161410468.png" class="" title="image-20210516161410468"><p><strong>Spring事务实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableTransactionManagement</span><br><span class="line"></span><br><span class="line">ProxyTransactionManagementConfiguration</span><br><span class="line"></span><br><span class="line">TransactionInterceptor</span><br><span class="line"></span><br><span class="line">org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction</span><br></pre></td></tr></table></figure><p><strong>常⽤注解</strong></p><ul><li>@EnableAspectJAutoProxy</li><li>@Aspect</li><li>@Pointcut</li><li>@Before</li><li>@After / @AfterReturning / @AfterThrowing</li><li>@Around</li><li>@Order</li></ul>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://universeinheart.github.io/tags/SpringBoot/"/>
    
    <category term="JDBC" scheme="http://universeinheart.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>03.NoSQL 实践</title>
    <link href="http://universeinheart.github.io/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/"/>
    <id>http://universeinheart.github.io/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/</id>
    <published>2021-05-13T15:26:37.000Z</published>
    <updated>2021-05-16T16:09:43.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过-Docker-辅助开发"><a href="#通过-Docker-辅助开发" class="headerlink" title="通过 Docker 辅助开发"></a>通过 Docker 辅助开发</h2><h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234130722.png" class="" title="image-20210513234130722"><h3 id="认识-Docker"><a href="#认识-Docker" class="headerlink" title="认识 Docker"></a>认识 Docker</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234119641.png" class="" title="image-20210513234119641"><h3 id="Docker-常⽤命令"><a href="#Docker-常⽤命令" class="headerlink" title="Docker 常⽤命令"></a>Docker 常⽤命令</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234104049.png" class="" title="image-20210513234104049"><h3 id="docker-run-的常⽤选项"><a href="#docker-run-的常⽤选项" class="headerlink" title="docker run 的常⽤选项"></a>docker run 的常⽤选项</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234032281.png" class="" title="image-20210513234032281"><h3 id="国内-Docker-镜像配置"><a href="#国内-Docker-镜像配置" class="headerlink" title="国内 Docker 镜像配置"></a>国内 Docker 镜像配置</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234048018.png" class="" title="image-20210513234048018"><h3 id="通过-Docker-启动-Redis"><a href="#通过-Docker-启动-Redis" class="headerlink" title="通过 Docker 启动 Redis"></a>通过 Docker 启动 Redis</h3><p><strong>官⽅指引</strong></p><ul><li><a href="https://hub.docker.com/_/redis">https://hub.docker.com/_/redis</a> </li></ul><p><strong>获取镜像</strong></p><ul><li>docker pull redis </li></ul><p><strong>启动 Redis</strong></p><ul><li>docker run –name redis -d -p 6379:6379 redis</li></ul><h2 id="在-Spring-中访问-Redis"><a href="#在-Spring-中访问-Redis" class="headerlink" title="在 Spring 中访问 Redis"></a>在 Spring 中访问 Redis</h2><ul><li>⽀持的客户端 <code>Jedis</code> / <code>Lettuce</code></li><li><code>RedisTemplate</code></li><li><code>Repository</code> ⽀持</li></ul><p><strong>Jedis 客户端</strong></p><ul><li><code>Jedis</code> 不是线程安全的</li><li>通过 <code>JedisPool</code> 获得 <code>Jedis</code> 实例</li><li>直接使⽤ <code>Jedis</code> 中的⽅法</li></ul><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210515122625375.png" class="" title="image-20210515122625375"><p><strong>Lettuce 客户端</strong></p><p>目前主流推荐驱动，基于Netty NIO，API线程安全</p><p><strong>Redission 客户端</strong></p><p>基于Netty NIO，API线程安全,大量分布式功能特性，JUC线程安全集合和工具的安全的分布式版本，分布式的数据结构和锁</p><h2 id="Redis-的哨兵与集群模式"><a href="#Redis-的哨兵与集群模式" class="headerlink" title="Redis 的哨兵与集群模式"></a>Redis 的哨兵与集群模式</h2><p><code>Redis Sentinel</code> 是 <code>Redis</code> 的⼀种⾼可⽤⽅案</p><ul><li>监控、通知、⾃动故障转移、服务发现</li></ul><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210515170904613.png" class="" title="image-20210515170904613"><p><code>JedisSentinelPool</code> </p><ul><li>继承  Pool</li><li>HostAndPort initSentinels(Set<String> sentinels, final String masterName) <ul><li>遍历sentinels 找到master</li><li>遍历sentinels 为每个sentinel增加 MasterListener，以便后面做切换</li></ul></li><li>initPool</li></ul><p>Redis Cluster</p><ul><li>数据⾃动分⽚（分成16384个 Hash Slot ）</li><li> 在部分节点失效时有⼀定可⽤性 </li></ul><p>JedisCluster</p><ul><li>Jedis 只从 Master 读数据，如果想要⾃动读写分离，可以定制</li></ul><h2 id="了解-Spring-的缓存抽象"><a href="#了解-Spring-的缓存抽象" class="headerlink" title="了解 Spring 的缓存抽象"></a>了解 Spring 的缓存抽象</h2><h3 id="Spring-的缓存抽象"><a href="#Spring-的缓存抽象" class="headerlink" title="Spring 的缓存抽象"></a>Spring 的缓存抽象</h3><p>为不同的缓存提供⼀层抽象</p><ul><li>为 <code>Java</code> ⽅法增加缓存，缓存执⾏结果</li><li>⽀持<code>ConcurrentMap</code>、<code>EhCache</code>、<code>Caffeine</code>、<code>JCache</code>（JSR-107）</li><li>接⼝<ul><li><code>org.springframework.cache.Cache</code></li><li><code>org.springframework.cache.CacheManager</code></li></ul></li></ul><h3 id="基于注解的缓存"><a href="#基于注解的缓存" class="headerlink" title="基于注解的缓存"></a>基于注解的缓存</h3><p><strong>@EnableCaching</strong>  //  开启缓存</p><ul><li>@Cacheable</li><li>@CacheEvict </li><li>@CachePut </li><li>@Caching </li><li>@CacheConfig</li></ul><h2 id="Redis-在-Spring-中的其他⽤法"><a href="#Redis-在-Spring-中的其他⽤法" class="headerlink" title="Redis 在 Spring 中的其他⽤法"></a>Redis 在 Spring 中的其他⽤法</h2>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://universeinheart.github.io/tags/SpringBoot/"/>
    
    <category term="JDBC" scheme="http://universeinheart.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>Java 动态代理</title>
    <link href="http://universeinheart.github.io/2021/05/13/Java/000/"/>
    <id>http://universeinheart.github.io/2021/05/13/Java/000/</id>
    <published>2021-05-13T15:18:37.000Z</published>
    <updated>2021-05-13T15:36:21.747Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是字节码增强技术"><a href="#什么是字节码增强技术" class="headerlink" title="什么是字节码增强技术"></a>什么是字节码增强技术</h3><p>java字节码生成之后，**运行期 **对其进行修改，增强其功能</p><h3 id="运行期"><a href="#运行期" class="headerlink" title="运行期"></a>运行期</h3><h3 id="字节码相关技术"><a href="#字节码相关技术" class="headerlink" title="字节码相关技术"></a>字节码相关技术</h3><ul><li>动态代理</li><li>CGLIB</li><li>javassist</li><li>asm</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li>实质上动态生成字节码与反射机制结合</li><li>运行期根据不同的入参生成不同的字节码文件，继承于Proxy对象，实现传入对象的实现接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyObject</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        object=o;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),o.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalArgumentException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before invoke ...&quot;</span>);</span><br><span class="line">        Object result= method.invoke(object,args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after invoke ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理的步骤"><a href="#动态代理的步骤" class="headerlink" title="动态代理的步骤"></a>动态代理的步骤</h3><p><strong>创建一个实现 <code>InvocationHandler</code>  的类，必须实现 <code>Invoke</code> 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object proxyObject;</span><br><span class="line"></span><br><span class="line">    MyInvocationHandler(Object proxyObject) &#123;</span><br><span class="line">        <span class="keyword">this</span>.proxyObject = proxyObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before invoke ...&quot;</span> + method);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != args) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object o : args) &#123;</span><br><span class="line">                System.out.println(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Object invoke = method.invoke(proxyObject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after invoke ...&quot;</span> + method);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建被代理的类以及接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;18&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;18&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过<code>Proxy</code>的静态方法  <code>newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h) </code>创建一个代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxyObject</span><span class="params">(Object realObject)</span> </span>&#123;</span><br><span class="line">    MyInvocationHandler myInvocationHandler = <span class="keyword">new</span> MyInvocationHandler(realObject);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object proxyInstance = Proxy.newProxyInstance(</span><br><span class="line">                realObject.getClass().getClassLoader(),</span><br><span class="line">                realObject.getClass().getInterfaces(),</span><br><span class="line">                myInvocationHandler);</span><br><span class="line">        <span class="keyword">return</span> proxyInstance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过代理调用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List proxyList = (List) getProxyObject(<span class="keyword">new</span> Vector());</span><br><span class="line">proxyList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">proxyList.add(<span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是字节码增强技术&quot;&gt;&lt;a href=&quot;#什么是字节码增强技术&quot; class=&quot;headerlink&quot; title=&quot;什么是字节码增强技术&quot;&gt;&lt;/a&gt;什么是字节码增强技术&lt;/h3&gt;&lt;p&gt;java字节码生成之后，**运行期 **对其进行修改，增强其功能&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://universeinheart.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://universeinheart.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>03.O/R Mapping 实践</title>
    <link href="http://universeinheart.github.io/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/"/>
    <id>http://universeinheart.github.io/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/</id>
    <published>2021-05-11T15:26:37.000Z</published>
    <updated>2021-05-12T23:26:15.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识-Spring-Data-JPA"><a href="#认识-Spring-Data-JPA" class="headerlink" title="认识 Spring Data JPA"></a>认识 Spring Data JPA</h2><h3 id="Java-Persistence-API"><a href="#Java-Persistence-API" class="headerlink" title="Java Persistence API"></a>Java Persistence API</h3><p>JPA 为对象关系映射提供了⼀种基于 POJO 的持久化模型</p><ul><li>简化数据持久化代码的开发⼯作</li><li>为 Java 社区屏蔽不同持久化 API 的差异</li></ul><h3 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h3><p>在保留底层存储特性的同时，提供相对⼀致的、基于 Spring 的编程模型</p><p>主要模块</p><ul><li>Spring Data Commons</li><li>Spring Data JDBC</li><li><strong>Spring Data JPA</strong></li><li>Spring Data Redis</li></ul><img src="/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/image-20210511011936375.png" class="" title="image-20210511011936375"><h2 id="定义-JPA-实体对象"><a href="#定义-JPA-实体对象" class="headerlink" title="定义 JPA 实体对象"></a>定义 JPA 实体对象</h2><h3 id="常⽤-JPA-注解"><a href="#常⽤-JPA-注解" class="headerlink" title="常⽤ JPA 注解"></a>常⽤ JPA 注解</h3><p><strong>实体</strong></p><ul><li><code>@Entity</code>  注明这个类是一个实体</li><li><code>@MappedSuperclass</code> </li><li><code>@Table(name)</code>  实体和表关联</li></ul><p><strong>主键</strong></p><ul><li><code>@Id</code><ul><li><code>@GeneratedValue(strategy, generator)</code> </li><li><code>@SequenceGenerator(name, sequenceName)</code></li></ul></li></ul><img src="/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/image-20210511012943447.png" class="" title="image-20210511012943447"><p><strong>映射</strong></p><ul><li><code>@Column(name, nullable, length, insertable, updatable)</code> </li><li><code>@JoinTable(name)</code>、<code>@JoinColumn(name)</code> </li></ul><p><strong>关系</strong> </p><ul><li><code>@OneToOne</code>、<code>@OneToMany</code>、<code>@ManyToOne</code>、<code>@ManyToMany</code></li><li><code>@OrderBy</code></li></ul><h2 id="通过-Spring-Data-JPA-操作数据库"><a href="#通过-Spring-Data-JPA-操作数据库" class="headerlink" title="通过 Spring Data JPA 操作数据库"></a>通过 Spring Data JPA 操作数据库</h2><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p><code>@EnableJpaRepositories</code> 注解，自动发现 <code>Repository</code> 的扩展</p><p><strong><code>Repository</code> 接⼝</strong></p><ul><li><code>CrudRepository&lt;T,ID&gt;</code></li><li><code>PagingAndSortingRepository&lt;T,ID&gt;</code></li><li><code>JpaRepository&lt;T,ID&gt;</code></li></ul><h3 id="定义查询"><a href="#定义查询" class="headerlink" title="定义查询"></a>定义查询</h3><p>根据⽅法名定义查询</p><ul><li>find…By… / read…By… / query…By… / get…By… </li><li>count…By… </li><li>…OrderBy…[Asc / Desc] </li><li>And / Or / IgnoreCase </li><li>Top / First / Distinct</li></ul><h3 id="分⻚查询"><a href="#分⻚查询" class="headerlink" title="分⻚查询"></a>分⻚查询</h3><ul><li>PagingAndSortingRepository &lt;T, ID&gt;</li><li>Pageable / Sort </li><li>Slice / Page&lt;T, ID&gt;</li></ul><h3 id="保存实体"><a href="#保存实体" class="headerlink" title="保存实体"></a>保存实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Coffee latte = Coffee.builder().name(<span class="string">&quot;latte&quot;</span>).price(Money.of(CurrencyUnit.of(<span class="string">&quot;CNY&quot;</span>), <span class="number">30.0</span>)).build();</span><br><span class="line">coffeeRepository.save(latte);</span><br><span class="line"></span><br><span class="line">CoffeeOrder order = CoffeeOrder.builder()</span><br><span class="line">.customer(<span class="string">&quot;Li Lei&quot;</span>)</span><br><span class="line">.items(Collections.singletonList(espresso))</span><br><span class="line">.state(OrderState.INIT)</span><br><span class="line">.build();</span><br><span class="line">orderRepository.save(order);</span><br></pre></td></tr></table></figure><h3 id="查询实体"><a href="#查询实体" class="headerlink" title="查询实体"></a>查询实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseRepository</span>&lt;<span class="title">T</span>, <span class="title">Long</span>&gt; <span class="keyword">extends</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findTop3ByOrderByUpdateTimeDescIdAsc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoffeeOrderRepository</span> <span class="keyword">extends</span> <span class="title">BaseRepository</span>&lt;<span class="title">CoffeeOrder</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;CoffeeOrder&gt; <span class="title">findByCustomerOrderById</span><span class="params">(String customer)</span></span>;</span><br><span class="line">    <span class="function">List&lt;CoffeeOrder&gt; <span class="title">findByItems_Name</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">coffeeRepository.findAll(Sort.by(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>)).forEach(c -&gt; log.info(<span class="string">&quot;Loading &#123;&#125;&quot;</span>, c));</span><br><span class="line"></span><br><span class="line">List&lt;CoffeeOrder&gt; list = orderRepository.findTop3ByOrderByUpdateTimeDescIdAsc();</span><br><span class="line">log.info(<span class="string">&quot;findTop3ByOrderByUpdateTimeDescIdAsc: &#123;&#125;&quot;</span>, JSON.toJSONString(list));</span><br><span class="line"></span><br><span class="line">list = orderRepository.findByCustomerOrderById(<span class="string">&quot;Li Lei&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;findByCustomerOrderById: &#123;&#125;&quot;</span>, JSON.toJSONString(list));</span><br><span class="line"><span class="comment">// 不开启事务会因为没Session而报LazyInitializationException</span></span><br><span class="line">list.forEach(o -&gt; &#123;</span><br><span class="line">log.info(<span class="string">&quot;Order &#123;&#125;&quot;</span>, o.getId());</span><br><span class="line">o.getItems().forEach(i -&gt; log.info(<span class="string">&quot;  Item &#123;&#125;&quot;</span>, i));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">list = orderRepository.findByItems_Name(<span class="string">&quot;latte&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;findByItems_Name: &#123;&#125;&quot;</span>, JSON.toJSONString(list));</span><br></pre></td></tr></table></figure><h2 id="Repository-是怎么从接⼝变成-Bean-的"><a href="#Repository-是怎么从接⼝变成-Bean-的" class="headerlink" title="Repository 是怎么从接⼝变成 Bean 的"></a>Repository 是怎么从接⼝变成 Bean 的</h2><h3 id="Repository-Bean-是如何创建的"><a href="#Repository-Bean-是如何创建的" class="headerlink" title="Repository Bean 是如何创建的"></a>Repository Bean 是如何创建的</h3><p><strong>JpaRepositoriesRegistrar</strong></p><ul><li>激活了 <code>@EnableJpaRepositories</code></li><li>返回了 <code>JpaRepositoryConfigExtension</code> </li></ul><p><strong>RepositoryBeanDefinitionRegistrarSupport.registerBeanDefinitions</strong></p><ul><li>注册 <code>Repository Bean</code>（类型是 <code>JpaRepositoryFactoryBean</code> ） </li></ul><p><strong>RepositoryConfigurationDelegate.registerRepositoriesIn</strong></p><ul><li>注册找到的 repositories</li></ul><p><strong>RepositoryConfigurationExtensionSupport.getRepositoryConfigurations</strong> </p><ul><li>取得 <code>Repository</code> 配置 </li></ul><p><strong>JpaRepositoryFactory.getTargetRepository</strong> </p><ul><li>创建了 <code>Repository</code></li></ul><h3 id="接⼝中的⽅法是如何被解释的"><a href="#接⼝中的⽅法是如何被解释的" class="headerlink" title="接⼝中的⽅法是如何被解释的"></a>接⼝中的⽅法是如何被解释的</h3><p><strong>RepositoryFactorySupport.getRepository 添加了Advice</strong></p><ul><li><code>DefaultMethodInvokingMethodInterceptor</code></li><li><code>QueryExecutorMethodInterceptor</code></li></ul><p><strong><code>AbstractJpaQuery.execute</code> 执⾏具体的查询</strong> </p><p><strong>语法解析在 <code>Part/PartTree</code> 中</strong></p><h2 id="通过-MyBatis-操作数据库"><a href="#通过-MyBatis-操作数据库" class="headerlink" title="通过 MyBatis 操作数据库"></a>通过 MyBatis 操作数据库</h2><h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><ul><li>mybatis.mapper-locations = classpath*:mapper/**/*.xml</li><li>mybatis.type-aliases-package = 类型别名的包名</li><li>mybatis.type-handlers-package = TypeHandler扫描包名（类型转换处理器）</li><li>mybatis.configuration.map-underscore-to-camel-case = true  </li></ul><h3 id="Mapper-的定义与扫描"><a href="#Mapper-的定义与扫描" class="headerlink" title="Mapper 的定义与扫描"></a>Mapper 的定义与扫描</h3><ul><li><code>@MapperScan</code> 配置扫描位置</li><li><code>@Mapper</code> 定义接⼝</li><li>映射的定义—— XML 与注解</li></ul><img src="/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/image-20210512231958054.png" class="" title="image-20210512231958054"><h3 id="MyBatis-Generator"><a href="#MyBatis-Generator" class="headerlink" title="MyBatis Generator"></a>MyBatis Generator</h3><h3 id="MyBatis-PageHelper"><a href="#MyBatis-PageHelper" class="headerlink" title="MyBatis PageHelper"></a>MyBatis PageHelper</h3>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://universeinheart.github.io/tags/SpringBoot/"/>
    
    <category term="JDBC" scheme="http://universeinheart.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>07、复杂度来源：低成本、安全、规模</title>
    <link href="http://universeinheart.github.io/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/07/"/>
    <id>http://universeinheart.github.io/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/07/</id>
    <published>2021-05-03T12:14:59.000Z</published>
    <updated>2021-05-03T13:50:35.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="低成本"><a href="#低成本" class="headerlink" title="低成本"></a>低成本</h2><p>当我们的架构方案只涉及几台或者十几台服务器时，一般情况下成本并不是我们重点关注的目标，但如果架构方案涉及几百上千甚至上万台服务器，成本就会变成一个非常重要的架构设计考虑点。</p><p>当我们设计“高性能”“高可用”的架构时，通用的手段都是增加更多服务器来满足“高性能”和“高可用”的要求；而低成本正好与此相反，我们需要减少服务器的数量才能达成低成本的目标。因此，低成本本质上是与高性能和高可用冲突的，所以低成本很多时候不会是架构设计的首要目标，而是架构设计的附加约束。</p><p>低成本给架构设计带来的主要复杂度体现在，<strong>往往只有“创新”才能达到低成本目标</strong>。这里的“创新”既包括开创一个全新的技术领域（这个要求对绝大部分公司太高），也包括引入新技术，如果没有找到能够解决自己问题的新技术，那么就真的需要自己创造新技术了。</p><ul><li><p><code>NoSQL</code>（<code>Memcache</code>、<code>Redis</code> 等）的出现是为了解决关系型数据库无法应对高并发访问带来的访问压力。</p></li><li><p>全文搜索引擎（<code>Sphinx</code>、<code>Elasticsearch</code>、<code>Solr</code>）的出现是为了解决关系型数据库 <strong>like 搜索的低效</strong>的问题。</p></li><li><p><code>Hadoop</code> 的出现是为了解决传统文件系统无法应对海量数据存储和计算的问题。</p></li><li><p><code>Facebook</code> 为了解决 PHP 的低效问题，刚开始的解决方案是 HipHop PHP，可以将 PHP 语言翻译为 C++ 语言执行，后来改为 HHVM，将 PHP 翻译为字节码然后由虚拟机执行，和 Java 的 JVM 类似。</p></li><li><p>新浪微博将传统的 Redis/MC + MySQL 方式，扩展为 Redis/MC + SSD Cache + MySQL 方式，SSD Cache 作为 L2 缓存使用，既解决了 MC/Redis 成本过高，容量小的问题，也解决了穿透 DB 带来的数据库访问压力</p></li><li><p><code>Linkedin</code> 为了处理每天 5 千亿的事件，开发了高效的 Kafka 消息系统。</p></li><li><p>其他类似将 Ruby on Rails 改为 Java、Lua + redis 改为 Go 语言实现的例子还有很多。</p></li></ul><p>无论是引入新技术，还是自己创造新技术，都是一件复杂的事情。引入新技术的主要复杂度在于需要去熟悉新技术，并且将新技术与已有技术结合起来；创造新技术的主要复杂度在于需要自己去创造全新的理念和技术，并且新技术跟旧技术相比，需要有质的飞跃。</p><p>相比来说，创造新技术复杂度更高，因此一般中小公司基本都是靠引入新技术来达到低成本的目标；而大公司更有可能自己去创造新的技术来达到低成本的目标，因为大公司才有足够的资源、技术和时间去创造新技术。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>安全本身是一个庞大而又复杂的技术领域，并且一旦出问题，对业务和企业形象影响非常大。正因为经常能够看到或者听到各类安全事件，所以大部分技术人员和架构师，对安全这部分会多一些了解和考虑。</p><p>从技术的角度来讲，安全可以分为两类：一类是功能上的安全，一类是架构上的安全。</p><ol><li>功能安全</li></ol><p>例如，常见的 XSS 攻击、CSRF 攻击、SQL 注入、Windows 漏洞、密码破解等，本质上是因为系统实现有漏洞，黑客有了可乘之机。黑客会利用各种漏洞潜入系统，这种行为就像小偷一样，黑客和小偷的手法都是利用系统或家中不完善的地方潜入，并进行破坏或者盗取。因此形象地说，<strong>功能安全其实就是“防小偷”</strong>。</p><p>从实现的角度来看，功能安全更多地是和具体的编码相关，与架构关系不大。现在很多开发框架都内嵌了常见的安全功能，能够大大减少安全相关功能的重复开发，但框架只能预防常见的安全漏洞和风险（常见的 XSS 攻击、CSRF 攻击、SQL 注入等），无法预知新的安全问题，而且框架本身很多时候也存在漏洞（例如，流行的 Apache Struts2 就多次爆出了调用远程代码执行的高危漏洞，给整个互联网都造成了一定的恐慌）。所以功能安全是一个逐步完善的过程，而且往往都是在问题出现后才能有针对性的提出解决方案，我们永远无法预测系统下一个漏洞在哪里，也不敢说自己的系统肯定没有任何问题。换句话讲，功能安全其实也是一个“攻”与“防”的矛盾，只能在这种攻防大战中逐步完善，不可能在系统架构设计的时候一劳永逸地解决。</p><ol start="2"><li>架构安全</li></ol><p>如果说功能安全是“防小偷”，那么<strong>架构安全就是“防强盗”</strong>。强盗会直接用大锤将门砸开，或者用炸药将围墙炸倒；小偷是偷东西，而强盗很多时候就是故意搞破坏，对系统的影响也大得多。因此架构设计时需要特别关注架构安全，尤其是互联网时代，理论上来说系统部署在互联网上时，全球任何地方都可以发起攻击。</p><p>传统的架构安全主要依靠防火墙，防火墙最基本的功能就是隔离网络，通过将网络划分成不同的区域，制定出不同区域之间的<strong>访问控制策略</strong>来控制不同信任程度区域间传送的数据流。</p><p>例如，下图是一个典型的银行系统的安全架构。</p><img src="/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/07/image-20210503213404249.png" class="" title="image-20210503213404249"><p>从图中你可以看到，整个系统根据不同的分区部署了多个防火墙来保证系统的安全。</p><p>防火墙的功能虽然强大，但性能一般，所以在传统的银行和企业应用领域应用较多。但在互联网领域，防火墙的应用场景并不多。因为互联网的业务具有海量用户访问和高并发的特点，防火墙的性能不足以支撑；尤其是互联网领域的 DDoS 攻击，轻则几 GB，重则几十 GB。这种规模的攻击，如果用防火墙来防，则需要部署大量的防火墙，成本会很高。例如，中高端一些的防火墙价格 10 万元，每秒能抗住大约 25GB 流量，那么应对这种攻击就需要将近 30 台防火墙，成本将近 300 万元，这还不包括维护成本，而这些防火墙设备在没有发生攻击的时候又没有什么作用。也就是说，如果花费几百万元来买这么一套设备，有可能几年都发挥不了任何作用。</p><p>就算是公司对钱不在乎，一般也不会堆防火墙来防 DDoS 攻击，因为 DDoS 攻击最大的影响是大量消耗机房的出口总带宽。不管防火墙处理能力有多强，当出口带宽被耗尽时，整个业务在用户看来就是不可用的，因为用户的正常请求已经无法到达系统了。防火墙能够保证内部系统不受冲击，但用户也是进不来的。对于用户来说，业务都已经受到影响了，至于是因为用户自己进不去，还是因为系统出故障，用户其实根本不会关心。</p><p>基于上述原因，互联网系统的架构安全目前并没有太好的设计手段来实现，更多地是依靠运营商或者云服务商强大的带宽和流量清洗的能力，较少自己来设计和实现。</p><h2 id="规模"><a href="#规模" class="headerlink" title="规模"></a>规模</h2><p>很多企业级的系统，既没有高性能要求，也没有双中心高可用要求，也不需要什么扩展性，但往往我们一说到这样的系统，很多人都会脱口而出：这个系统好复杂！为什么这样说呢？关键就在于这样的系统往往功能特别多，逻辑分支特别多。特别是有的系统，发展时间比较长，不断地往上面叠加功能，后来的人由于不熟悉整个发展历史，可能连很多功能的应用场景都不清楚，或者细节根本无法掌握，面对的就是一个黑盒系统，看不懂、改不动、不敢改、修不了，复杂度自然就感觉很高了。</p><p><strong>规模带来复杂度的主要原因就是“量变引起质变”</strong>，当数量超过一定的阈值后，复杂度会发生质的变化。</p><p>常见的规模带来的复杂度有：</p><ol><li>功能越来越多，导致系统复杂度指数级上升</li><li>数据越来越多，系统复杂度发生质变</li></ol>]]></content>
    
    
    <summary type="html">架构</summary>
    
    
    
    <category term="从零开始学架构" scheme="http://universeinheart.github.io/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://universeinheart.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>06、复杂度来源：可扩展性</title>
    <link href="http://universeinheart.github.io/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/06/"/>
    <id>http://universeinheart.github.io/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/06/</id>
    <published>2021-05-03T11:14:59.000Z</published>
    <updated>2021-05-03T12:50:40.780Z</updated>
    
    <content type="html"><![CDATA[<p>可扩展性指系统为了<strong>应对将来需求变化</strong>而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。</p><p>在软件开发领域，面向对象思想的提出，就是为了解决可扩展性带来的问题；后来的设计模式，更是将可扩展性做到了极致。得益于设计模式的巨大影响力，几乎所有的技术人员对于可扩展性都特别重视。</p><p>设计具备良好可扩展性的系统，有两个基本条件：<strong>正确预测变化</strong>、<strong>完美封装变化</strong>。</p><h2 id="预测变化"><a href="#预测变化" class="headerlink" title="预测变化"></a>预测变化</h2><p>软件系统与硬件或者建筑相比，有一个很大的差异：软件系统在发布后还可以不断地修改和演进，这就意味着<strong>不断有新的需求需要实现</strong>。</p><blockquote><p>唯一不变的是变化</p></blockquote><p>对于架构师来说，如何把握预测的程度和提升预测结果的准确性，是一件很复杂的事情，而且没有通用的标准可以简单套上去，更多是靠自己的经验、直觉，所以架构设计评审的时候经常会出现两个设计师对某个判断争得面红耳赤的情况，原因就在于没有明确标准，不同的人理解和判断有偏差，而最终又只能选择一个判断。</p><h2 id="应对变化"><a href="#应对变化" class="headerlink" title="应对变化"></a>应对变化</h2><p>第一种应对变化的常见方案是<strong>将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”</strong>。无论是变化层依赖稳定层，还是稳定层依赖变化层都是可以的，需要根据具体业务情况来设计。</p><p>例如，如果系统需要支持 XML、JSON、ProtocolBuffer 三种接入方式，那么最终的架构就是上面图中的“形式 1”架构，也就是下面这样。</p><img src="/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/06/image-20210503202856173.png" class="" title="image-20210503202856173"><p>如果系统需要支持 MySQL、Oracle、DB2 数据库存储，那么最终的架构就变成了“形式 2”的架构了，你可以看下面这张图。</p><img src="/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/06/image-20210503202914502.png" class="" title="image-20210503202914502"><p>无论采取哪种形式，通过剥离变化层和稳定层的方式应对变化，都会带来两个主要的复杂性相关的问题。</p><ol><li>系统需要拆分出变化层和稳定层</li></ol><p>对于哪些属于变化层，哪些属于稳定层，很多时候并不是像前面的示例（不同接口协议或者不同数据库）那样明确，不同的人有不同的理解，导致架构设计评审的时候可能吵翻天。</p><ol start="2"><li>需要设计变化层和稳定层之间的接口</li></ol><p>接口设计同样至关重要，对于稳定层来说，接口肯定是越稳定越好；但对于变化层来说，在有差异的多个实现方式中找出共同点，并且还要保证当加入新的功能时原有的接口设计不需要太大修改，这是一件很复杂的事情。例如，<code>MySQL</code> 的 <code>REPLACE INTO</code> 和 <code>Oracle</code> 的 <code>MERGE INTO</code> 语法和功能有一些差异，那存储层如何向稳定层提供数据访问接口呢？是采取 MySQL 的方式，还是采取 Oracle 的方式，还是自适应判断？如果再考虑 DB2 的情况呢？相信你看到这里就已经能够大致体会到接口设计的复杂性了。</p><hr><p>第二种常见的应对变化的方案是<strong>提炼出一个“抽象层”和一个“实现层”</strong>。抽象层是稳定的，实现层可以根据具体业务需要定制开发，当加入新的功能时，只需要增加新的实现，无须修改抽象层。这种方案典型的实践就是<strong>设计模式</strong>和<strong>规则引擎</strong>。考虑到绝大部分技术人员对设计模式都非常熟悉，我以设计模式为例来说明这种方案的复杂性。</p><p>以设计模式的“<strong>装饰者</strong>”模式来分析，下面是装饰者模式的类关系图。</p><img src="/2021/05/03/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/06/image-20210503204626263.png" class="" title="image-20210503204626263"><p>图中的 <code>Component</code> 和 <code>Decorator</code> 就是抽象出来的规则，这个规则包括几部分：</p><ol><li><code>Component</code> 和 <code>Decorator</code> 类。</li><li><code>Decorator</code> 类继承 <code>Component</code> 类</li><li><code>Decorator</code> 类聚合了 <code>Component</code> 类。</li></ol><p>这个规则一旦抽象出来后就固定了，不能轻易修改。例如，把规则 3 去掉，就无法实现装饰者模式的目的了。</p><p>装饰者模式相比传统的继承来实现功能，确实灵活很多。例如，《设计模式》中装饰者模式的样例“TextView”类的实现，用了装饰者之后，能够灵活地给 TextView 增加额外更多功能，比如可以增加边框、滚动条、背景图片等，这些功能上的组合不影响规则，只需要按照规则实现即可。但装饰者模式相对普通的类实现模式，明显要复杂多了。本来一个函数或者一个类就能搞定的事情，现在要拆分成多个类，而且多个类之间必须按照装饰者模式来设计和调用。</p><p>规则引擎和设计模式类似，都是通过灵活的设计来达到可扩展的目的，但“灵活的设计”本身就是一件复杂的事情，不说别的，光是把 23 种设计模式全部理解和备注，都是一件很困难的事情。</p>]]></content>
    
    
    <summary type="html">架构</summary>
    
    
    
    <category term="从零开始学架构" scheme="http://universeinheart.github.io/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://universeinheart.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>05、复杂度来源：高可用</title>
    <link href="http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/05/"/>
    <id>http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/05/</id>
    <published>2021-05-02T11:14:59.000Z</published>
    <updated>2021-05-03T12:20:52.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>高可用 : 系统<strong>无中断</strong>地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。</p><p><strong>高性能增加机器目的在于“扩展”处理性能；</strong></p><p><strong>高可用增加机器目的在于“冗余”处理单元</strong>。</p></blockquote><h2 id="计算高可用"><a href="#计算高可用" class="headerlink" title="计算高可用"></a>计算高可用</h2><p>这里的“计算”指的是业务的逻辑处理。计算有一个特点就是<strong>无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的</strong>，所以将计算从一台机器迁移到另外一台机器，对业务并没有什么影响。</p><img src="/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/05/image-20210503001438346.png" class="" title="image-20210503001438346"><p>高可用集群分配算法更加复杂，可以是 1 主 3 备、2 主 2 备、3 主 1 备、4 主 0 备，具体应该采用哪种方式，需要结合实际业务需求来分析和判断，并不存在某种算法就一定优于另外的算法。例如，ZooKeeper 采用的就是 1 主多备，而 Memcached 采用的就是全主 0 备。</p><h2 id="存储高可用"><a href="#存储高可用" class="headerlink" title="存储高可用"></a>存储高可用</h2><p>对于需要存储数据的系统来说，整个系统的高可用设计关键点和难点就在于“存储高可用”。存储与计算相比，有一个本质上的区别：<strong>将数据从一台机器搬到到另一台机器，需要经过线路进行传输</strong>。线路传输的速度是毫秒级别，同一机房内部能够做到几毫秒；分布在不同地方的机房，传输耗时需要几十甚至上百毫秒。例如，从广州机房到北京机房，稳定情况下 ping 延时大约是 50ms，不稳定情况下可能达到 1s 甚至更多。</p><p>虽然毫秒对于人来说几乎没有什么感觉，但是对于高可用系统来说，就是本质上的不同，这意味着整个系统在某个时间点上，数据肯定是不一致的。按照“<strong>数据 + 逻辑 = 业务</strong>”这个公式来套的话，数据不一致，即使逻辑一致，最后的业务表现就不一样了。</p><p>以最经典的银行储蓄业务为例，假设用户的数据存在北京机房，用户存入了 1 万块钱，然后他查询的时候被路由到了上海机房，北京机房的数据没有同步到上海机房，用户会发现他的余额并没有增加 1 万块。想象一下，此时用户肯定会背后一凉，马上会怀疑自己的钱被盗了，然后赶紧打客服电话投诉，甚至打 110 报警，即使最后发现只是因为传输延迟导致的问题，站在用户的角度来说，这个过程的体验肯定很不好。</p><img src="/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/05/image-20210503001623102.png" class="" title="image-20210503001623102"><p>除了物理上的传输速度限制，传输线路本身也存在可用性问题，传输线路可能中断、可能拥塞、可能异常（错包、丢包），并且传输线路的故障时间一般都特别长，短的十几分钟，长的几个小时都是可能的。例如，2015 年支付宝因为光缆被挖断，业务影响超过 4 个小时；2016 年中美海底光缆中断 3 小时等。在传输线路中断的情况下，就意味着存储无法进行同步，在这段时间内整个系统的数据是不一致的。</p><p>综合分析，无论是正常情况下的传输延迟，还是异常情况下的传输中断，都会导致系统的数据在某个时间点或者时间段是不一致的，而数据的不一致又会导致业务问题；但如果完全不做冗余，系统的整体高可用又无法保证，所以<strong>存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响</strong>。</p><p>分布式领域里面有一个著名的 <strong>CAP 定理</strong>，从理论上论证了存储高可用的复杂度。也就是说，存储高可用不可能同时满足“<strong>一致性</strong>、<strong>可用性</strong>、<strong>分区容错性</strong>”，最多满足其中两个，这就要求我们在做架构设计时结合业务进行取舍。</p><h2 id="高可用状态决策"><a href="#高可用状态决策" class="headerlink" title="高可用状态决策"></a>高可用状态决策</h2><p>无论是计算高可用还是存储高可用，其基础都是“<strong>状态决策</strong>”，即系统需要能够判断当前的状态是正常还是异常，如果出现了异常就要采取行动来保证高可用。如果状态决策本身都是有错误或者有偏差的，那么后续的任何行动和处理无论多么完美也都没有意义和价值。但在具体实践的过程中，恰好存在一个本质的矛盾：<strong>通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确</strong>。</p><p>下面我基于几种常见的决策方式进行详细分析。</p><h3 id="独裁式"><a href="#独裁式" class="headerlink" title="独裁式"></a>独裁式</h3><p>独裁式决策指的是存在一个独立的决策主体，我们姑且称它为“决策者”，负责收集信息然后进行决策；所有冗余的个体，我们姑且称它为“上报者”，都将状态信息发送给决策者。独裁式的决策方式不会出现决策混乱的问题，因为只有一个决策者，但问题也正是在于只有一个决策者。当决策者本身故障时，整个系统就无法实现准确的状态决策。如果决策者本身又做一套状态决策，那就陷入一个递归的死循环了。</p><h3 id="协商式"><a href="#协商式" class="headerlink" title="协商式"></a>协商式</h3><p>协商式决策指的是两个独立的个体通过交流信息，然后根据规则进行决策，<strong>最常用的协商式决策就是主备决策</strong>。</p><p>这个架构的基本协商规则可以设计成：</p><ul><li>2 台服务器启动时都是备机。</li><li>2 台服务器建立连接。</li><li>2 台服务器交换状态信息。</li><li>某 1 台服务器做出决策，成为主机；另一台服务器继续保持备机身份。</li></ul><p>协商式决策的架构不复杂，规则也不复杂，其难点在于，如果两者的信息交换出现问题（比如主备连接中断），此时状态决策应该怎么做。</p><ul><li>如果备机在连接中断的情况下认为主机故障，那么备机需要升级为主机，但实际上此时主机并没有故障，那么系统就出现了两个主机，这与设计初衷（1 主 1 备）是不符合的。</li><li>如果备机在连接中断的情况下不认为主机故障，则此时如果主机真的发生故障，那么系统就没有主机了，这同样与设计初衷（1 主 1 备）是不符合的。</li><li>如果为了规避连接中断对状态决策带来的影响，可以增加更多的连接。例如，双连接、三连接。这样虽然能够降低连接中断对状态带来的影响（注意：只能降低，不能彻底解决），但同时又引入了这几条连接之间信息取舍的问题，即如果不同连接传递的信息不同，应该以哪个连接为准？实际上这也是一个无解的答案，无论以哪个连接为准，在特定场景下都可能存在问题。</li></ul><h3 id="民主式"><a href="#民主式" class="headerlink" title="民主式"></a>民主式</h3><p>民主式决策指的是多个独立的个体通过投票的方式来进行状态决策。</p><p>例如，ZooKeeper 集群在选举 leader 时就是采用这种方式。</p><img src="/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/05/image-20210503002341224.png" class="" title="image-20210503002341224"><p>民主式决策和协商式决策比较类似，其基础都是独立的个体之间交换信息，每个个体做出自己的决策，然后按照“<strong>多数取胜</strong>”的规则来确定最终的状态。不同点在于民主式决策比协商式决策要复杂得多，ZooKeeper 的选举算法 Paxos，绝大部分人都看得云里雾里，更不用说用代码来实现这套算法了。</p><p>除了算法复杂，民主式决策还有一个固有的缺陷：脑裂。这个词来源于医学，指人体左右大脑半球的连接被切断后，左右脑因为无法交换信息，导致各自做出决策，然后身体受到两个大脑分别控制，会做出各种奇怪的动作。</p><p>脑裂的根本原因是，原来统一的集群因为连接中断，造成了两个独立分隔的子集群，每个子集群单独进行选举，于是选出了 2 个主机，相当于人体有两个大脑了。</p><p>为了解决脑裂问题，民主式决策的系统一般都采用“<strong>投票节点数必须超过系统总节点数一半</strong>”规则来处理。这种方式虽然解决了脑裂问题，但同时降低了系统整体的可用性，即如果系统不是因为脑裂问题导致投票节点数过少，而真的是因为节点故障，此时系统也不会选出主节点，整个系统就相当于宕机了，尽管此时还有节点 4 和节点 5 是正常的。</p>]]></content>
    
    
    <summary type="html">架构</summary>
    
    
    
    <category term="从零开始学架构" scheme="http://universeinheart.github.io/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://universeinheart.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>04、复杂度来源：高性能</title>
    <link href="http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/04/"/>
    <id>http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/04/</id>
    <published>2021-05-02T11:14:57.000Z</published>
    <updated>2021-05-02T15:24:35.040Z</updated>
    
    <content type="html"><![CDATA[<p>软件系统中高性能带来的复杂度主要体现在两方面，一方面是<strong>单台计算机内部为了高性能带来的复杂度</strong>；另一方面是<strong>多台计算机集群为了高性能带来的复杂度</strong>。</p><h2 id="单机复杂度"><a href="#单机复杂度" class="headerlink" title="单机复杂度"></a>单机复杂度</h2><p>计算机内部复杂度最关键的地方就是操作系统。计算机性能的发展本质上是由硬件发展驱动的，尤其是 CPU 的性能发展。著名的“摩尔定律”表明了 CPU 的处理能力每隔 18 个月就翻一番；而将硬件性能充分发挥出来的关键就是操作系统，所以操作系统本身其实也是跟随硬件的发展而发展的，操作系统是软件系统的运行环境，<strong>操作系统的复杂度直接决定了软件系统的复杂度</strong>。</p><p>操作系统和性能最相关的就是<strong>进程</strong>和<strong>线程</strong>。用进程来对应一个任务，每个任务都有自己独立的内存空间，进程间互不相关，由操作系统来进行调度。此时的 CPU 还没有多核和多线程的概念，为了达到多进程并行运行的目的，采取了分时的方式，即把 CPU 的时间分成很多片段，每个片段只能执行某个进程中的指令。虽然从操作系统和 CPU 的角度来说还是串行处理的，但是由于 CPU 的处理速度很快，从用户的角度来看，感觉是多进程在并行处理。</p><p>多进程虽然要求每个任务都有独立的内存空间，进程间互不相关，但从用户的角度来看，两个任务之间能够在运行过程中就进行通信，会让任务设计变得更加灵活高效。否则如果两个任务运行过程中不能通信，只能是 A 任务将结果写到存储，B 任务再从存储读取进行处理，不仅效率低，而且任务设计更加复杂。为了解决这个问题，进程间通信的各种方式被设计出来了，包括<strong>管道</strong>、<strong>消息队列</strong>、<strong>信号量</strong>、<strong>共享存储</strong>等。</p><p>多进程让多任务能够并行处理任务，但本身还有缺点，单个进程内部只能串行处理，而实际上很多进程内部的子任务并不要求是严格按照时间顺序来执行的，也需要并行处理。例如，一个餐馆管理进程，排位、点菜、买单、服务员调度等子任务必须能够并行处理，否则就会出现某个客人买单时间比较长（比如说信用卡刷不出来），其他客人都不能点菜的情况。为了解决这个问题，人们又发明了<strong>线程</strong>，线程是进程内部的子任务，但这些子任务都共享同一份进程数据。为了保证数据的正确性，又发明了互斥锁机制。<strong>有了多线程后，操作系统调度的最小单位就变成了线程，而进程变成了操作系统分配资源的最小单位。</strong></p><p>多进程多线程虽然让多任务并行处理的性能大大提升，但本质上还是分时系统，并不能做到时间上真正的并行。解决这个问题的方式显而易见，就是让多个 CPU 能够同时执行计算任务，从而实现真正意义上的多任务并行。</p><p>操作系统发展到现在，如果我们要完成一个高性能的软件系统，需要考虑如多进程、多线程、进程间通信、多线程并发等技术点，而且这些技术<strong>并不是最新的就是最好的，也不是非此即彼的选择</strong>。</p><h2 id="集群的复杂度"><a href="#集群的复杂度" class="headerlink" title="集群的复杂度"></a>集群的复杂度</h2><p>虽然计算机硬件的性能快速发展，但和业务的发展速度相比，还是小巫见大巫了，尤其是进入互联网时代后，业务的发展速度远远超过了硬件的发展速度。例如：</p><p>2016 年“双 11”支付宝每秒峰值达 12 万笔支付。</p><p>2017 年春节微信红包收发红包每秒达到 76 万个。</p><p>要支持支付和红包这种复杂的业务，单机的性能无论如何是无法支撑的，必须采用机器集群的方式来达到高性能。例如，支付宝和微信这种规模的业务系统，后台系统的机器数量都是万台级别的。</p><p>通过大量机器来提升性能，并不仅仅是增加机器这么简单，让多台机器配合起来达到高性能的目的，是一个复杂的任务，我针对常见的几种方式简单分析一下。</p><h3 id="1、任务分配"><a href="#1、任务分配" class="headerlink" title="1、任务分配"></a>1、任务分配</h3><p>任务分配的意思是指每台机器都可以处理完整的业务任务，不同的任务分配到不同的机器上执行。</p><p>我从最简单的一台服务器变两台服务器开始，来讲任务分配带来的复杂性，整体架构示意图如下。</p><img src="/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/04/image-20210502231221916.png" class="" title="image-20210502231221916"><p>从图中可以看到，1 台服务器演变为 2 台服务器后，架构上明显要复杂多了，主要体现在：</p><ul><li>需要增加一个<strong>任务分配器</strong>，这个分配器可能是硬件网络设备（例如，F5、交换机等），可能是软件网络设备（例如，LVS），也可能是负载均衡软件（例如，Nginx、HAProxy），还可能是自己开发的系统。选择合适的任务分配器也是一件复杂的事情，需要综合考虑性能、成本、可维护性、可用性等各方面的因素。</li><li>任务分配器和真正的业务服务器之间有连接和交互（即图中任务分配器到业务服务器的连接线），需要选择合适的<strong>连接方式</strong>，并且对连接进行管理。例如，连接建立、连接检测、连接中断后如何处理等。</li><li>任务分配器需要增加<strong>分配算法</strong>。例如，是采用轮询算法，还是按权重分配，又或者按照负载进行分配。如果按照服务器的负载进行分配，则业务服务器还要能够上报自己的状态给任务分配器。</li></ul><p>我们假设单台业务服务器每秒能够处理 5000 次业务请求，那么这个架构理论上能够支撑 10000 次请求，实际上的性能一般按照 8 折计算，大约是 8000 次左右。如果我们的性能要求继续提高，假设要求每秒提升到 10 万次，上面这个架构会出现什么问题呢？是不是将业务服务器增加到 25 台就可以了呢？显然不是，因为随着性能的增加，任务分配器本身又会成为性能瓶颈，当业务请求达到每秒 10 万次的时候，单台任务分配器也不够用了，任务分配器本身也需要扩展为多台机器，这时的架构又会演变成这个样子。</p><img src="/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/04/image-20210502231424201.png" class="" title="image-20210502231424201"><p>这个架构比 2 台业务服务器的架构要复杂，主要体现在：</p><ul><li>任务分配器从 1 台变成了多台，这个变化带来的复杂度就是需要将不同的用户分配到不同的任务分配器上（即图中的虚线“用户分配”部分），常见的方法包括 <strong>DNS 轮询</strong>、<strong>智能 DNS</strong>、<strong>CDN</strong>（Content Delivery Network，内容分发网络）、<strong>GSLB</strong> 设备（Global Server Load Balance，全局负载均衡）等。</li><li>任务分配器和业务服务器的连接从简单的“1 对多”变成了“多对多”（多台任务分配器连接多台业务服务器）的网状结构。</li><li>机器数量从 3 台扩展到 30 台（一般任务分配器数量比业务服务器要少，这里我们假设业务服务器为 25 台，任务分配器为 5 台），状态管理、故障处理复杂度也大大增加。</li></ul><p>上面这两个例子都是以业务处理为例，实际上“任务”涵盖的范围很广，<strong>可以指完整的业务处理，也可以单指某个具体的任务</strong>。例如，“存储”“运算”“缓存”等都可以作为一项任务，因此存储系统、运算系统、缓存系统都可以按照任务分配的方式来搭建架构。此外，“任务分配器”也并不一定只能是物理上存在的机器或者一个独立运行的程序，也可以是嵌入在其他程序中的算法，例如 Memcache 的集群架构。</p><h3 id="2、任务分解"><a href="#2、任务分解" class="headerlink" title="2、任务分解"></a>2、任务分解</h3><p>通过任务分解的方式，能够把原来大一统但复杂的业务系统，拆分成小而简单但需要多个系统配合的业务系统。从业务的角度来看，任务分解既不会减少功能，也不会减少代码量（事实上代码量可能还会增加，因为从代码内部调用改为通过服务器之间的接口调用），那为何通过任务分解就能够提升性能呢？</p><p>主要有几方面的因素：</p><p>1、<strong>简单的系统更加容易做到高性能</strong></p><p>系统的功能越简单，影响性能的点就越少，就更加容易进行有针对性的优化。而系统很复杂的情况下，首先是比较难以找到关键性能点，因为需要考虑和验证的点太多；其次是即使花费很大力气找到了，修改起来也不容易，因为可能将 A 关键性能点提升了，但却无意中将 B 点的性能降低了，整个系统的性能不但没有提升，还有可能会下降。</p><p>2、<strong>可以针对单个任务进行扩展</strong></p><p>当各个逻辑任务分解到独立的子系统后，整个系统的性能瓶颈更加容易发现，而且发现后只需要针对有瓶颈的子系统进行性能优化或者提升，不需要改动整个系统，风险会小很多。以微信的后台架构为例，如果用户数增长太快，注册登录子系统性能出现瓶颈的时候，只需要优化登录注册子系统的性能（可以是代码优化，也可以简单粗暴地加机器），消息逻辑、LBS 逻辑等其他子系统完全不需要改动。</p><p>既然将一个大一统的系统分解为多个子系统能够提升性能，那是不是划分得越细越好呢？其实不然，这样做性能不仅不会提升，反而还会下降，最主要的原因是如果系统拆分得太细，为了完成某个业务，系统间的调用次数会呈指数级别上升，而系统间的调用通道目前都是通过网络传输的方式，性能远比系统内的函数调用要低得多。</p><p>虽然系统拆分可能在某种程度上能提升业务处理性能，但提升性能也是有限的，不可能系统不拆分的时候业务处理耗时为 50ms，系统拆分后业务处理耗时只要 1ms，因为最终决定业务处理性能的还是业务逻辑本身，业务逻辑本身没有发生大的变化下，理论上的性能是有一个上限的，系统拆分能够让性能逼近这个极限，但无法突破这个极限。因此，任务分解带来的性能收益是有一个度的，并不是任务分解越细越好，而对于架构设计来说，如何把握这个粒度就非常关键了。</p>]]></content>
    
    
    <summary type="html">架构</summary>
    
    
    
    <category term="从零开始学架构" scheme="http://universeinheart.github.io/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://universeinheart.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>03、架构设计的目的</title>
    <link href="http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/03/"/>
    <id>http://universeinheart.github.io/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/03/</id>
    <published>2021-05-02T11:14:56.000Z</published>
    <updated>2021-05-02T15:04:18.900Z</updated>
    
    <content type="html"><![CDATA[<p>通过回顾架构产生的历史背景和原因，我们可以基本推导出答案：<strong>架构设计的主要目的是为了解决软件系统复杂度带来的问题</strong>。</p><blockquote><p>问：“这么多需求，从哪里开始下手进行架构设计呢？”</p><p>答：通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。</p><p>问：“架构设计要考虑高性能、高可用、高扩展……这么多高 XX，全部设计完成估计要 1 个月，但老大只给了 1 周时间”</p><p>答：架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点然后有针对性地解决问题。</p><p>问：“业界 A 公司的架构是 X，B 公司的方案是 Y，两个差别比较大，该参考哪一个呢？”</p><p>答：理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。</p><p>问：“我们的系统一定要做到每秒 TPS 10 万”</p><p>答：如果系统的复杂度不是在性能这部分，TPS 做到 10 万并没有什么用。</p><p>问：“淘宝的架构是这么做的，我们也要这么做”</p><p>答：淘宝的架构是为了解决淘宝业务的复杂度而设计的，淘宝的业务复杂度并不就是我们的业务复杂度，绝大多数业务的用户量都不可能有淘宝那么大。</p><p>问：“Docker 现在很流行，我们的架构应该将 Docker 应用进来”</p><p>答：Docker 不是万能的，只是为了解决资源重用和动态分配而设计的，如果我们的系统复杂度根本不是在这方面，引入 Docker 没有什么意义。</p></blockquote><h2 id="简单的复杂度分析案例"><a href="#简单的复杂度分析案例" class="headerlink" title="简单的复杂度分析案例"></a>简单的复杂度分析案例</h2><p> 假设我们需要设计一个大学的学生管理系统，其基本功能包括登录、注册、成绩管理、课程管理等。</p><p>当我们对这样一个系统进行架构设计的时候，首先应识别其复杂度到底体现在哪里。</p><p><strong>性能</strong>：一个学校的学生大约 1 ~ 2 万人，学生管理系统的访问频率并不高，平均每天单个学生的访问次数平均不到 1 次，因此性能这部分并不复杂，存储用 MySQL 完全能够胜任，缓存都可以不用，Web 服务器用 Nginx 绰绰有余。</p><p><strong>可扩展性</strong>：学生管理系统的功能比较稳定，可扩展的空间并不大，因此可扩展性也不复杂。</p><p><strong>高可用</strong>：学生管理系统即使宕机 2 小时，对学生管理工作影响并不大，因此可以不做负载均衡，更不用考虑异地多活这类复杂的方案了。但是，如果学生的数据全部丢失，修复是非常麻烦的，只能靠人工逐条修复，这个很难接受，因此需要考虑存储高可靠，这里就有点复杂了。我们需要考虑多种异常情况：机器故障、机房故障，针对机器故障，我们需要设计 MySQL 同机房主备方案；针对机房故障，我们需要设计 MySQL 跨机房同步方案。</p><p><strong>安全性</strong>：学生管理系统存储的信息有一定的隐私性，例如学生的家庭情况，但并不是和金融相关的，也不包含强隐私（例如玉照、情感）的信息，因此安全性方面只要做 3 个事情就基本满足要求了：Nginx 提供 ACL 控制、用户账号密码管理、数据库访问权限控制。</p><img src="/2021/05/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/03/image-20210502223059420.png" class="" title="image-20210502223059420">]]></content>
    
    
    <summary type="html">架构</summary>
    
    
    
    <category term="从零开始学架构" scheme="http://universeinheart.github.io/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://universeinheart.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
