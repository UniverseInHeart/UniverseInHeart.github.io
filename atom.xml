<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HelloWorld</title>
  
  
  <link href="http://universeinheart.github.io/atom.xml" rel="self"/>
  
  <link href="http://universeinheart.github.io/"/>
  <updated>2021-09-08T15:04:56.672Z</updated>
  <id>http://universeinheart.github.io/</id>
  
  <author>
    <name>xjf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>00.如何高效学习算法及数据结构和算法总览</title>
    <link href="http://universeinheart.github.io/2021/09/06/%E7%AE%97%E6%B3%95/01/"/>
    <id>http://universeinheart.github.io/2021/09/06/%E7%AE%97%E6%B3%95/01/</id>
    <published>2021-09-06T15:26:37.000Z</published>
    <updated>2021-09-08T15:04:56.672Z</updated>
    
    <content type="html"><![CDATA[<p>三分理解，七分练习</p><p>五分钟想不出来，直接看题解或者高票答案，使用五毒神掌变成自己的东西，敢于死记硬背代码</p><p>《异类：不一样的成功启示录》</p><blockquote><p>如何精通一个领域</p><ul><li>Chunk it up 切碎知识点 </li><li>Deliberate Practicing 刻意练习</li><li>Feedback 反馈</li></ul></blockquote><blockquote><p>切题四件套</p><p>Clarification 看清题目，和面试官沟通清楚</p><p>Possible solutions  思考所有的解法</p><p>Coding </p><p>Test cases</p></blockquote><blockquote><p>五毒神掌</p><ul><li>第一遍：10分钟：读题+思考，没有思路直接看解法，比较解法优劣，背诵默写好的解法</li><li>第二遍：马上自己写，leetcode提交，多种解法比较体会，优化</li><li>过一天后，再重复做题，不熟练的题目进行专项练习</li><li>过一周后，反复回来练习相同的题目</li><li>面试前一周恢复性训练</li></ul></blockquote>]]></content>
    
    
    <summary type="html">算法</summary>
    
    
    
    <category term="算法" scheme="http://universeinheart.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://universeinheart.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>21.适配器模式</title>
    <link href="http://universeinheart.github.io/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21/"/>
    <id>http://universeinheart.github.io/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21/</id>
    <published>2021-07-11T15:35:37.000Z</published>
    <updated>2021-07-10T14:04:40.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">代理、适配器、桥接、装饰，这四个模式有何区别？</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>20.装饰器模式</title>
    <link href="http://universeinheart.github.io/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20/"/>
    <id>http://universeinheart.github.io/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20/</id>
    <published>2021-07-11T15:34:37.000Z</published>
    <updated>2021-07-10T14:04:10.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">通过剖析Java IO类库源码学习装饰器模式</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>19.桥接模式</title>
    <link href="http://universeinheart.github.io/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19/"/>
    <id>http://universeinheart.github.io/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19/</id>
    <published>2021-07-11T15:33:37.000Z</published>
    <updated>2021-07-10T14:55:42.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">如何实现支持不同类型和渠道的消息推送系统</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>17.原型模式</title>
    <link href="http://universeinheart.github.io/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17/"/>
    <id>http://universeinheart.github.io/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17/</id>
    <published>2021-07-11T15:32:37.000Z</published>
    <updated>2021-07-10T13:52:25.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="原型模式的原理与应用"><a href="#原型模式的原理与应用" class="headerlink" title="原型模式的原理与应用"></a>原型模式的原理与应用</h2><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式 （Prototype Design Pattern），简称原型模式。</p><blockquote><p>什么对象的创建成本比较大？ </p><p>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间， 或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。 </p><p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作</p></blockquote><h2 id="原型模式的实现方式：深拷贝和浅拷贝"><a href="#原型模式的实现方式：深拷贝和浅拷贝" class="headerlink" title="原型模式的实现方式：深拷贝和浅拷贝"></a>原型模式的实现方式：深拷贝和浅拷贝</h2><p>在内存中，用散列表组织的搜索关键词信息是如何存储的。我画了一张示意图， 大致结构如下所示。</p><p>从图中我们可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中。</p><img src="/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17/image-20210710145558340.png" class="" title="image-20210710145558340"><blockquote><p>浅拷贝和深拷贝的区别在于</p><p>浅拷贝只会复制图中的索引（散列表），不会复制数据 （SearchWord 对象）本身。</p><p>相反，深拷贝不仅仅会复制索引，还会复制数据本身。</p></blockquote><p>浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据 （SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。</p><img src="/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17/image-20210710145702241.png" class="" title="image-20210710145702241"><img src="/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17/image-20210710145715872.png" class="" title="image-20210710145715872"><p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</p><blockquote><p>如何实现深拷贝?</p><ol><li>如何实现深拷贝</li><li>先将对象序列化，然后再反序列化成新的对象</li></ol></blockquote>]]></content>
    
    
    <summary type="html">如何最快速地clone一个HashMap散列表？</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>18.代理模式</title>
    <link href="http://universeinheart.github.io/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18/"/>
    <id>http://universeinheart.github.io/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18/</id>
    <published>2021-07-11T15:32:37.000Z</published>
    <updated>2021-07-10T14:35:23.111Z</updated>
    
    <content type="html"><![CDATA[<p><strong>代理模式（Proxy Design Pattern</strong>）在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p><p><strong>动态代理（Dynamic Proxy）</strong>，就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后 在系统中用代理类替换掉原始类。</p><p>那如何实现动态代理呢？动态代理底层依赖的就是 Java 的反射语法</p><p>Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</p><h2 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h2><p><strong>业务系统的非功能性需求开发</strong></p><p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、 统计、鉴权、限流、事务、幂等、日志。</p><p>我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。</p><p>如果你熟悉 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完成的。Spring AOP 底层的实现原理就是基于动态代理</p><p><strong>代理模式在 RPC中的应用</strong></p><p>实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。</p><p>通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的 时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p><p><strong>代理模式在缓存中的应用</strong></p><p>如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间） 等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段 （比如 http://…?..&amp;cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。</p>]]></content>
    
    
    <summary type="html">代理在RPC、缓存、监控等场景中的应用</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>16.建造者模式</title>
    <link href="http://universeinheart.github.io/2021/07/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16/"/>
    <id>http://universeinheart.github.io/2021/07/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16/</id>
    <published>2021-07-10T15:32:37.000Z</published>
    <updated>2021-07-10T06:32:49.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要建造者模式？"><a href="#为什么需要建造者模式？" class="headerlink" title="为什么需要建造者模式？"></a>为什么需要建造者模式？</h2><p>创建对象的时候，如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</p><p>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、 maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。</p><p>如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</p><blockquote><p>建造者模式登场</p><p>可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 <code>build()</code> 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。</p><p>除此之外，我们把 <code>ResourcePoolConfig</code> 的构造函数改为 private 私有权限。 这样我们就只能通过建造者来创建 <code>ResourcePoolConfig</code> 类对象。并且， <code>ResourcePoolConfig</code> 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象 了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ResourcePoolConfig</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">        <span class="keyword">this</span>.maxTotal = builder.maxTotal;</span><br><span class="line">        <span class="keyword">this</span>.maxIdle = builder.maxIdle;</span><br><span class="line">        <span class="keyword">this</span>.minIdle = builder.minIdle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...省略getter方法...</span></span><br><span class="line">    <span class="comment">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span></span><br><span class="line">    <span class="comment">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ResourcePoolConfig <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxIdle &gt; maxTotal) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((minIdle &gt; maxTotal) || (minIdle &gt; maxIdle)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResourcePoolConfig(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setMaxTotal</span><span class="params">(<span class="keyword">int</span> maxTotal)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setMaxIdle</span><span class="params">(<span class="keyword">int</span> maxIdle)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setMinIdle</span><span class="params">(<span class="keyword">int</span> minIdle)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span></span><br><span class="line">ResourcePoolConfig config = <span class="keyword">new</span> ResourcePoolConfig.Builder()</span><br><span class="line">.setName(<span class="string">&quot;dbconnectionpool&quot;</span>)</span><br><span class="line">.setMaxTotal(<span class="number">16</span>)</span><br><span class="line">.setMaxIdle(<span class="number">10</span>)</span><br><span class="line">.setMinIdle(<span class="number">12</span>)</span><br><span class="line">.build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="与工厂模式有何区别？"><a href="#与工厂模式有何区别？" class="headerlink" title="与工厂模式有何区别？"></a>与工厂模式有何区别？</h2><p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子 类），由给定的参数来决定创建哪种类型的对象。</p><p>建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p>]]></content>
    
    
    <summary type="html">详解构造函数、set方法、建造者模式三种对象创建方式</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>14.单例模式</title>
    <link href="http://universeinheart.github.io/2021/07/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14/"/>
    <id>http://universeinheart.github.io/2021/07/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14/</id>
    <published>2021-07-06T15:32:37.000Z</published>
    <updated>2021-07-07T15:35:41.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用单例？"><a href="#为什么要使用单例？" class="headerlink" title="为什么要使用单例？"></a>为什么要使用单例？</h2><blockquote><p>一个类只允许创建一个对 象（或者实例），那这个类就是一个单例类</p></blockquote><h3 id="实战案例一：处理资源访问冲突"><a href="#实战案例一：处理资源访问冲突" class="headerlink" title="实战案例一：处理资源访问冲突"></a>实战案例一：处理资源访问冲突</h3><p>例子中，我们自定义实现了一个往文件中打印日志的 Logger 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的日志都写入到同一个文件，如果创建多个Logger对象,多线程并发执行log方法，同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。</p><p>解决方案1：加类级别的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Logger.class) &#123; <span class="comment">// 类级别的锁</span></span><br><span class="line">writer.write(mesasge);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案2：单例，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger instance = <span class="keyword">new</span> Logger();</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实战案例二：表示全局唯一类"><a href="#实战案例二：表示全局唯一类" class="headerlink" title="实战案例二：表示全局唯一类"></a>实战案例二：表示全局唯一类</h3><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。 比如，配置信息类，唯一递增 ID 号码生成器</p><h2 id="如何实现一个单例？"><a href="#如何实现一个单例？" class="headerlink" title="如何实现一个单例？"></a>如何实现一个单例？</h2><ul><li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例； </li><li>考虑对象创建时的线程安全问题； </li><li>考虑是否支持延迟加载； </li><li>考虑 getInstance() 性能是否高（是否加锁）</li></ul><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我觉的这是一种最合适的方式，有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多或初始化耗时长 ，提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。 如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作， 会导致此请求的响应时间变长，甚至超时）。<strong>采用饿汉式实现方式，将耗时的初始化操作， 提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题</strong></p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉式相对于饿汉式的优势是支持延迟加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给 getInstance() 方法加锁 （synchronzed），导致这个函数的并发度很低，如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p><h3 id="双重检测"><a href="#双重检测" class="headerlink" title="双重检测"></a>双重检测</h3><p>既支持延迟加载、又支持高并发的双重检测实现方式。</p><p>在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (IdGenerator.class) &#123; <span class="comment">// 此处为类级别的锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>SingletonHolder</code> 是一个静态内部类，当外部类 <code>IdGenerator</code> 被加载的时候，并不会创建 <code>SingletonHolder</code> 实例对象。只有当调用 <code>getInstance()</code> 方法时，<code>SingletonHolder</code> 才会被加载，这个时候才会创建 <code>instance</code>。<code>insance</code> 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如何理解单例模式中的唯一性？"><a href="#如何理解单例模式中的唯一性？" class="headerlink" title="如何理解单例模式中的唯一性？"></a>如何理解单例模式中的唯一性？</h2><p>单例模式创建的对象是进程唯一的</p><p>实际上，对于 Java 语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class Loader）</p><h2 id="如何实现线程唯一的单例？"><a href="#如何实现线程唯一的单例？" class="headerlink" title="如何实现线程唯一的单例？"></a>如何实现线程唯一的单例？</h2><p>假设 <code>IdGenerator</code> 是一个线程唯一的单例类。在线程 A 内，我们可以创建一个单例对象 a。因为线程内唯一，在线程 A 内就不能再创建新的 <code>IdGenerator</code> 对象了，而线程间可以不唯一，所以，在另外一个线程 B 内，我们还可以重新创建一个新的单例对象 b。 </p><p>尽管概念理解起来比较复杂，但线程唯一单例的代码实现很简单，如下所示。在代码中，我通过一个 <code>HashMap</code> 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。</p><p>实际上，Java 语言本身提供了 <code>ThreadLocal</code> 工具类，可以更加轻松地实现线程唯一单例。不过，<code>ThreadLocal</code> 底层实现原理也是基于下面代码中所示的 <code>HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances= <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long currentThreadId = Thread.currentThread().getId();</span><br><span class="line">        instances.putIfAbsent(currentThreadId, <span class="keyword">new</span> IdGenerator());</span><br><span class="line">        <span class="keyword">return</span> instances.get(currentThreadId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如何实现集群环境下的单例？"><a href="#如何实现集群环境下的单例？" class="headerlink" title="如何实现集群环境下的单例？"></a>如何实现集群环境下的单例？</h2><p>具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。 </p><p>为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。</p><h2 id="如何实现一个多例模式？"><a href="#如何实现一个多例模式？" class="headerlink" title="如何实现一个多例模式？"></a>如何实现一个多例模式？</h2>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>15.工厂模式</title>
    <link href="http://universeinheart.github.io/2021/07/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15/"/>
    <id>http://universeinheart.github.io/2021/07/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15/</id>
    <published>2021-07-06T15:32:37.000Z</published>
    <updated>2021-07-10T05:29:20.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h2><p>根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">      IRuleConfigParser parser = createParser(ruleConfigFileExtension);</span><br><span class="line">        <span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(</span><br><span class="line">                    <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath</span><br><span class="line">        &#125;</span><br><span class="line">        String configText = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">        RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;<span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> IRuleConfigParser <span class="title">createParser</span><span class="params">(String configFormat)</span> </span>&#123;</span><br><span class="line">        IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让类的职责更加单一、代码更加清晰，我们可将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。</p><p>而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">        IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">        <span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(</span><br><span class="line">                    <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath;</span><br><span class="line">        &#125;</span><br><span class="line">        String configText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">        RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title">createParser</span><span class="params">(String configFormat)</span> </span>&#123;</span><br><span class="line">        IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码实现中，我们每次调用 <code>RuleConfigParserFactory</code> 的 <code>createParser()</code> 的时候，都要创建一个新的 <code>parser</code>。实际上，如果 <code>parser</code> 可以复用，为了节省内存和对象创建的时间，我们可以将 <code>parser</code> 事先创建好缓存起来。当调用 <code>createParser()</code> 函数的时候，我 们从缓存中取出 <code>parser</code> 对象直接使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cachedParsers.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> JsonRuleConfigParser());</span><br><span class="line">        cachedParsers.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> XmlRuleConfigParser());</span><br><span class="line">        cachedParsers.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> YamlRuleConfigParser());</span><br><span class="line">        cachedParsers.put(<span class="string">&quot;properties&quot;</span>, <span class="keyword">new</span> PropertiesRuleConfigParser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title">createParser</span><span class="params">(String configFormat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (configFormat == <span class="keyword">null</span> || configFormat.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//返回null还是IllegalArgumentException全凭你自己说了算</span></span><br><span class="line">        &#125;</span><br><span class="line">        IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">IRuleConfigParser <span class="title">createParser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFact</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是工厂方法模式的典型代码实现。这样当我们新增一种 <code>parser</code> 的时候，只需 要新增一个实现了 <code>IRuleConfigParserFactory</code> 接口的 <code>Factory</code> 类即可。所以，<strong>工厂方法模式比起简单工厂模式更加符合开闭原则</strong>。</p><p>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式 简单好用，比工方法厂模式更加合适。</p><blockquote><p><strong>那什么时候该用工厂方法模式，而非简单工厂模式呢？</strong></p><p>我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。 </p><p>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p></blockquote><h2 id="工厂模式和-DI-容器有何区别？"><a href="#工厂模式和-DI-容器有何区别？" class="headerlink" title="工厂模式和 DI 容器有何区别？"></a>工厂模式和 DI 容器有何区别？</h2><p>实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。</p><p>DI 容器相当于一个大的工厂 类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p><h2 id="DI-容器的核心功能有哪些？"><a href="#DI-容器的核心功能有哪些？" class="headerlink" title="DI 容器的核心功能有哪些？"></a>DI 容器的核心功能有哪些？</h2><p>一个简单的 DI 容器的核心功能一般有三个：<strong>配置解析</strong>、<strong>对象创建</strong>、<strong>对象生命周期管理</strong></p><h3 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h3><p>将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对</p><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加， 这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到 一个工厂类中完成就可以了，比如 <code>BeansFactory</code>。</p><p>如果要创建的类对象非常多，<code>BeansFactory</code> 中的代码会不会线性膨胀呢？实际上并不会。反射”这种机制，能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象， <code>BeansFactory</code> 工厂类代码都是一样的。</p><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>单例or原型</p><p>懒加载</p><p> <code>init-method</code> </p><p> <code>destroy-method</code></p>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>12.实战一、ID生成器开发</title>
    <link href="http://universeinheart.github.io/2021/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12/"/>
    <id>http://universeinheart.github.io/2021/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12/</id>
    <published>2021-07-04T15:32:37.000Z</published>
    <updated>2021-07-06T14:52:13.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ID-生成器需求背景介绍"><a href="#ID-生成器需求背景介绍" class="headerlink" title="ID 生成器需求背景介绍"></a>ID 生成器需求背景介绍</h2><p>软件开发中，ID 常用来表示一些业务信息的唯一标识，比如订单的单号或者数据库中的唯一主键，比如地址表中的 ID 字段</p><p>为了方便在请求出错时排查问题，我们在编写代码的时候会在关键路径上打印日志。某个请求出错之后，我们希望能搜索出这个请求对应的 所有日志，以此来查找问题的原因。这听起来有点像微服务中的调用链追踪。不过，微服务中的调用链追踪是服务间的追踪，我们现在要实现的是服务内的追踪</p><p>借鉴微服务调用链追踪的实现思路，我们可以给每个请求分配一个唯一ID，并且保存在请求的上下文（Context）中，比如，处理请求的工作线程的局部变量中。在Java语言中，我们可以将ID存储在Servlet线程的<code>ThreadLocal</code>中，或者利用<code>Slf4j</code>日志框架的<code>MDC（MappedDiagnosticContexts）</code>来实现（实际上底层原理也是基于线程的<code>ThreadLocal</code>）。每次打印日志的时候，我们从请求上下文中取出请求ID，跟日志一块输出。这样，同一个请求的所有日志都包含同样的请求ID信息，我们就可以通过请求ID来搜索同一个请求的所有日志了。</p><img src="/2021/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12/image-20210704173030462.png" class="" title="image-20210704173030462"><img src="/2021/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12/image-20210704173049750.png" class="" title="image-20210704173049750">]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>11.如何通过封装、抽象、模块化、中间层等解耦代码？</title>
    <link href="http://universeinheart.github.io/2021/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11/"/>
    <id>http://universeinheart.github.io/2021/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11/</id>
    <published>2021-07-04T15:31:37.000Z</published>
    <updated>2021-07-04T08:58:59.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="“解耦”为何如此重要？"><a href="#“解耦”为何如此重要？" class="headerlink" title="“解耦”为何如此重要？"></a>“解耦”为何如此重要？</h2><p>软件设计与开发最重要的工作之一就是<strong>应对复杂性</strong>。人处理复杂性的能力是有限的。过于复 杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是<strong>解耦</strong>，保证代码松耦合、高内聚。</p><p>如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。</p><p>不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修 改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码 改动比较集中，引入 bug 的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易 mock 或者很少需要 mock 外部依赖的模块或者类。</p><h2 id="代码是否需要“解耦”？"><a href="#代码是否需要“解耦”？" class="headerlink" title="代码是否需要“解耦”？"></a>代码是否需要“解耦”？</h2><p>把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们 就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。</p><h2 id="如何给代码“解耦”？"><a href="#如何给代码“解耦”？" class="headerlink" title="如何给代码“解耦”？"></a>如何给代码“解耦”？</h2><ol><li>封装与抽象</li></ol><p>封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。</p><p>比如，Unix 系统提供的 open() 文件操作函数，我们用起来非常简单，但是底层实现却非常复杂，涉及权限控制、并发控制、物理存储等等。我们通过将其封装成一个抽象的 open() 函数，能够有效控制代码复杂性的蔓延，将复杂性封装在局部代码中</p><ol start="2"><li>中间层</li></ol><p>引入中间层能简化模块或类之间的依赖关系。</p><img src="/2021/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11/image-20210704164750656.png" class="" title="image-20210704164750656"><ol start="3"><li>模块化</li></ol><p><strong>模块化是构建复杂系统常用的手段</strong>。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不 同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块， 让整个系统有效运转。</p><p>不同的模块之间通过 API 来进行通信，每个模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发，最终像搭积木一样将各个模块组装起来，构建成一个超级复杂的系统。</p><ol start="4"><li>其他设计思想和原则</li></ol><p><strong>单一职责原则</strong></p><p>模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。</p><p><strong>基于接口而非实现编程</strong></p><p>能通过接口这样一个中间层，隔离变化和具体的实现。</p><p>在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。</p><p><strong>依赖注入</strong></p><p>尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么 紧密，容易做到插拔替换。</p><p><strong>多用组合少用继承</strong></p><p>继承是强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一 发而动全身，父类的每一次改动都会影响所有的子类。</p><p>组合关系是弱依赖关系， 这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段</p><p><strong>迪米特法则</strong></p><p>迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽 量只依赖必要的接口。</p>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>10.重构，单元测试</title>
    <link href="http://universeinheart.github.io/2021/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10/"/>
    <id>http://universeinheart.github.io/2021/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10/</id>
    <published>2021-07-04T15:28:37.000Z</published>
    <updated>2021-07-04T08:28:39.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么情况下要重构？到底重构什么？又该如何重构？"><a href="#什么情况下要重构？到底重构什么？又该如何重构？" class="headerlink" title="什么情况下要重构？到底重构什么？又该如何重构？"></a>什么情况下要重构？到底重构什么？又该如何重构？</h2><blockquote><p>重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低</p></blockquote><h3 id="重构的目的：为什么要重构（why）？"><a href="#重构的目的：为什么要重构（why）？" class="headerlink" title="重构的目的：为什么要重构（why）？"></a>重构的目的：为什么要重构（why）？</h3><p>首先重构是时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步。项目在演进，代码不停地在堆砌。如果没有人为代码的质量负责任，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。</p><p>其次，优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。我们无法 100% 遇见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单，所以，随着系统的演进，重构代码也是不可避免的。</p><p>最后，重构是避免过度设计的有效手段。在我们维护代码的过程中，真正遇到问题的时候， 再对代码进行重构，能有效避免前期投入太多时间做过度的设计，做到有的放矢。</p><h3 id="重构的对象：到底重构什么（what）？"><a href="#重构的对象：到底重构什么（what）？" class="headerlink" title="重构的对象：到底重构什么（what）？"></a>重构的对象：到底重构什么（what）？</h3><p>根据重构的规模，我们可以笼统地分为<strong>大规模高层次重构</strong>和<strong>小规模低层次的重构</strong>。</p><p>大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入bug的风险也会相对比较大。</p><p>小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。小型重构更多的是利用我们能后面要讲到的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入bug的风险相对来说也会比较小。你只需要熟练掌握各种编码规范，就可以做到得心应手。</p><h3 id="重构的时机：什么时候重构（when）？"><a href="#重构的时机：什么时候重构（when）？" class="headerlink" title="重构的时机：什么时候重构（when）？"></a>重构的时机：什么时候重构（when）？</h3><p>持续重构</p><p>时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降。</p><h3 id="重构的方法：又该如何重构（how）？"><a href="#重构的方法：又该如何重构（how）？" class="headerlink" title="重构的方法：又该如何重构（how）？"></a>重构的方法：又该如何重构（how）？</h3><p>在进行大型重构的时候，我们要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，我们都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，我们才能让每一阶段的重构都不至于耗时太长，不至于与新的功能开发相冲突。</p><p>大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时都可以去做。实际上，除了人工去发现低层次的质量问题，我们还可以借助很多成熟的静态代码分析工具（比如CheckStyle、FindBugs、PMD），来自动发现代码中的问题，然后针对性地进行重构优化。</p><p>对于重构这件事情，资深的工程师、项目 leader 要负起责任来，没事就重构一下代码，时刻保证代码质量处在一个良好的状态。否则，一旦出现“破窗效应”，一个人往里堆了一些烂代码，之后就会有更多的人往里堆更烂的代码。毕竟往项目里堆砌烂代码的成本太低了。 不过，保持代码质量最好的方法还是打造一种好的技术氛围，以此来驱动大家主动去关注代码质量，持续重构代码。</p><h2 id="为了保证重构不出错，有哪些非常能落地的技术手段？"><a href="#为了保证重构不出错，有哪些非常能落地的技术手段？" class="headerlink" title="为了保证重构不出错，有哪些非常能落地的技术手段？"></a>为了保证重构不出错，有哪些非常能落地的技术手段？</h2><p>最可落地执行、最有效的保证重构不出错的手段应该就是<strong>单元测试（Unit Testing）</strong></p><h3 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h3><p>单元测试相对于<strong>集成测试</strong>（Integration Testing）来说，测试的粒度更小一些。</p><p>集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端（end to end）的测试。</p><p>而单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。</p><h3 id="为什么要写单元测试？"><a href="#为什么要写单元测试？" class="headerlink" title="为什么要写单元测试？"></a>为什么要写单元测试？</h3><p>单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另 一个是 Code Review）。</p><ol><li><p>单元测试能有效地帮你发现代码中的 bug</p></li><li><p>写单元测试能帮你发现代码设计上的问题</p><p>如果很难 为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才 能完成，那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函 数、全局变量、代码高度耦合等</p></li><li><p>写单元测试的过程本身就是代码重构的过程</p><p>编写单元测试就相当于对代码的一次自我 Code Review，在这个过程中，我们可以 发现一些设计上的问题（比如代码设计的不可测试）以及代码编写方面的问题（比如一些边 界条件处理不当）等，然后针对性的进行重构</p></li></ol><h3 id="单元测试为何难落地执行？"><a href="#单元测试为何难落地执行？" class="headerlink" title="单元测试为何难落地执行？"></a>单元测试为何难落地执行？</h3><p>一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写；另一方面，国 内研发比较偏向“快、糙、猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾。最 后，关键问题还是团队没有建立对单元测试正确的认识，觉得可有可无，单靠督促很难执行 得很好</p><h2 id="什么是代码的可测试性？如何写出可测试性好的代码？"><a href="#什么是代码的可测试性？如何写出可测试性好的代码？" class="headerlink" title="什么是代码的可测试性？如何写出可测试性好的代码？"></a>什么是代码的可测试性？如何写出可测试性好的代码？</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>08. MVC 三层开发 &amp; BO、VO、Entity 存在的意义</title>
    <link href="http://universeinheart.github.io/2021/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08/"/>
    <id>http://universeinheart.github.io/2021/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08/</id>
    <published>2021-07-04T15:26:37.000Z</published>
    <updated>2021-07-04T07:37:00.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要分-MVC-三层开发？"><a href="#为什么要分-MVC-三层开发？" class="headerlink" title="为什么要分 MVC 三层开发？"></a>为什么要分 MVC 三层开发？</h2><ol><li>分层能起到代码复用的作用</li></ol><p>同一个<code>Repository</code>可能会被多个<code>Service</code>来调用，同一个<code>Service</code>可能会被多个<code>Controller</code>调用。比如，UserService中的getUserById() 接口封装了通过ID获取用户信息的逻辑，这部分逻辑可能会被UserController和AdminController等多个Controller使用。如果没有Service层，每个Controller都要重复实现这部分逻辑，显然会违反DRY原则。</p><ol start="2"><li>分层能起到隔离变化的作用</li></ol><p>分层体现了一种抽象和封装的设计思想。比如，<code>Repository</code>层封装了对数据库访问的操作，提供了抽象的数据访问接口。基于接口而非实现编程的设计思想，<code>Service</code>层使用<code>Repository</code>层提供的接口，并不关心其底层依赖的是哪种具体的数据库。当我们需要替换数据库的时候，比如从MySQL到Oracle，从Oracle到Redis，只需要改动<code>Repository</code>层的代码，<code>Service</code>层的代码完全不需要修改。</p><p>除此之外，<code>Controller</code>、<code>Service</code>、<code>Repository</code>三层代码的稳定程度不同、引起变化的原因不同，所以分成三层来组织代码，能有效地隔离变化。比如，<code>Repository</code>层基于数据库表，而数据库表改动的可能性很小，所以<code>Repository</code>层的代码最稳定，而<code>Controller</code>层提供适配给外部使用的接口，代码经常会变动。分层之后，<code>Controller</code>层中代码的频繁改动并不会影响到稳定的<code>Repository</code>层</p><ol start="3"><li>分层能起到隔离关注点的作用</li></ol><p><code>Repository</code>层只关注数据的读写。<code>Service</code>层只关注业务逻辑，不关注数据的来源。<code>Controller</code>层只关注与外界打交道，数据校验、封装、格式转换，并不关心业务逻辑。三层之间的关注点不同，分层之后，职责分明，更加符合单一职责原则，代码的内聚性更好。</p><ol start="4"><li>分层能提高代码的可测试性</li></ol><p>后面讲单元测试的时候，我们会讲到，单元测试不依赖不可控的外部组件，比如数据库。分层之后，<code>Repsitory</code>层的代码通过依赖注入的方式供<code>Service</code>层使用，当要测试包含核心业务逻辑的<code>Service</code>层代码的时候，我们可以用<code>mock</code>的数据源替代真实的数据库，注入到<code>Service</code>层代码中。</p><ol start="5"><li>分层能应对系统的复杂性</li></ol><p>所有的代码都放到一个类中，那这个类的代码就会因为需求的迭代而无限膨胀。我们知道，当一个类或一个函数的代码过多之后，可读性、可维护性就会变差。那我们就要想办法拆分。拆分有垂直和水平两个方向。水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层。还是那句话，不管是分层、模块化，还是OOP、DDD，以及各种设计模式、原则和思想，都是为了应对复杂系统，应对系统的复杂性。对于简单系统来说，其实是发挥不了作用的，就是俗话说的“杀鸡焉用牛刀”。</p><h2 id="BO、VO、Entity-存在的意义是什么？"><a href="#BO、VO、Entity-存在的意义是什么？" class="headerlink" title="BO、VO、Entity 存在的意义是什么？"></a>BO、VO、Entity 存在的意义是什么？</h2><p>针对<code>Controller</code>、<code>Service</code>、<code>Repository</code>三层，每层都会定义相应的数据对象，它们分别是<strong>VO（ViewObject）</strong>、<strong>BO（BusinessObject）</strong>、<strong>Entity</strong>，例如<code>UserVo</code>、<code>UserBo</code>、<code>UserEntity</code>。在实际的开发中，VO、BO、Entity可能存在大量的重复字段，甚至三者包含的字段完全一样。在开发的过程中，我们经常需要重复定义三个几乎一样的类，显然是一种重复劳动。</p><p>相对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？实际上，我更加推荐每层都定义各自的数据对象这种设计思路，主要有以下3个方面的原因。</p><ul><li><code>VO、BO、Entity</code> 并非完全一样。比如，我们可以在UserEntity、UserBo中定义Password字段，但显然不能在UserVo中定义Password字段，否则就会将用户的密码暴露出去。</li><li><code>VO、BO、Entity</code>三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背DRY原则。在前面讲到DRY原则的时候，针对这种情况，如果合并为同一个类，那也会存在后期因为需求的变化而需要再拆分的问题。</li><li>为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！</li></ul><p><strong>既然VO、BO、Entity不能合并，那如何解决代码重复的问题呢？</strong></p><p>从设计的角度来说，<code>VO、BO、Entity</code>的设计思路并不违反DRY原则，为了分层清晰、减少耦合，多维护几个类的成本也并不是不能接受的。但是，如果你真的有代码洁癖，对于代码重复的问题，我们也有一些办法来解决。我们前面讲到，继承可以解决代码重复问题。我们可以将公共的字段定义在父类中，让VO、BO、Entity都继承这个父类，各自只定义特有的字段。因为这里的继承层次很浅，也不复杂，所以使用继承并不会影响代码的可读性和可维护性。后期如果因为业务的需要，有些字段需要从父类移动到子类，或者从子类提取到父类，代码改起来也并不复杂。</p><p>前面在讲“多用组合，少用继承”设计思想的时候，我们提到，组合也可以解决代码重复的问题，所以，这里我们还可以将公共的字段抽取到公共的类中，VO、BO、Entity通过组合关系来复用这个类的代码。</p><p><strong>代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？</strong></p><p>当下一层的数据通过接口调用传递到上一层之后，我们需要将它转化成上一层对应的数据对象类型。比如，<code>Service</code>层从<code>Repository</code>层获取的<code>Entity</code>之后，将其转化成<code>BO</code>，再继续业务逻辑的处理。所以，整个开发的过程会涉及“Entity到BO”和“BO到VO”这两种转化.最简单的转化方式是手动复制。自己写代码在两个对象之间，一个字段一个字段的赋值。但这样的做法显然是没有技术含量的低级劳动。Java中提供了多种数据对象转化工具，比如<code>BeanUtils</code>、<code>Dozer</code>等，可以大大简化繁琐的对象转化工作。 </p><p>VO、BO、Entity都是基于贫血模型的，而且为了兼容框架或开发库（比如MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的set方法。这些都违背OOP的封装特性，会导致数据被随意修改。那到底该怎么办好呢？前面我们也提到过，Entity和VO的生命周期是有限的，都仅限在本层范围内。而对应的Repository层和Controller层也都不包含太多业务逻辑，所以也不会有太多代码随意修改数据，即便设计成贫血、定义每个字段的set方法，相对来说也是安全的。</p><p>不过，Service层包含比较多的业务逻辑代码，所以BO就存在被任意修改的风险了。但是，设计的问题本身就没有最优解，只有权衡。为了使用方便，我们只能做一些妥协，放弃BO的封装特性，由程序员自己来负责这些数据对象的不被错误使用。</p><img src="/2021/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08/image-20210704145125561.png" class="" title="image-20210704145125561">]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>07.实战-业务系统的开发，如何做需求分析和设计？</title>
    <link href="http://universeinheart.github.io/2021/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07/"/>
    <id>http://universeinheart.github.io/2021/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07/</id>
    <published>2021-06-27T15:26:37.000Z</published>
    <updated>2021-07-04T04:30:40.038Z</updated>
    
    <content type="html"><![CDATA[<p>有独立负责一个系统的能力，开发一个完整的系统。</p><p>这其中的工作就包括：</p><ul><li>前期的需求沟通分析</li><li>中期的代码设计实现</li><li>后期的系统上线维护等</li></ul><h2 id="业务系统的开发，如何做需求分析和设计？"><a href="#业务系统的开发，如何做需求分析和设计？" class="headerlink" title="业务系统的开发，如何做需求分析和设计？"></a>业务系统的开发，如何做需求分析和设计？</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>积分是一种常见的营销手段，很多产品都会通过它来促进消费、增加用户粘性，比如淘宝积分、信用卡积分、商场消费积分等等</p><p>作为技术人，我该怎么做产品设计呢？首先，一定不要自己一个人闷头想。一方面，这样做很难想全面。另一方面，从零开始设计也比较浪费时间。所以，我们要 学会“借鉴”。</p><blockquote><p>爱因斯坦说过，“创造的一大秘诀是要懂得如何隐藏你的来源”。</p></blockquote><p>找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中。你可以自己亲自用用淘宝，看看积分是怎么使用的，也可以直接百度一下“淘宝 积分规则”。基于这两个输入，我们基本上就大致能摸清楚积分系统该如何设计了。除此之外，我们还要充分了解自己公司的产品，将借鉴来的东西糅合在我们自己的产品中，并做适当的微创新。</p><p>笼统地来讲，积分系统无外乎就两个大的功能点，一个是赚取积分，另一个是消费积分。</p><p>赚取积分功能包括积分赚取渠道，比如下订单、每日签到、评论等；还包括积分兑换规则，比如订单金额与积分的兑换比例，每日签到赠送多少积分等。</p><p>消费积分功能包括积分消费渠 道，比如抵扣订单金额、兑换优惠券、积分换购、参与活动扣积分等；还包括积分兑换规则，比如多少积分可以换算成抵扣订单的多少金额，一张优惠券需要多少积分来兑换等等</p><p>刚刚给出的只是非常笼统、粗糙的功能需求。在实际情况中，肯定还有一些业务细节需要考虑，比如积分的有效期问题。对于这些业务细节，还是那句话，闷头拍脑袋想是想不全面的。以防遗漏，我们还是要有方法可寻。那除了刚刚讲的“借鉴”的思路之外，我还喜欢通过产品的线框图、<strong>用户故事</strong>（user story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。</p><p>用户故事类似我们后面要讲的单元测试用例。它侧重情景化，其实就是模拟用户如何使用我们的产品，描述用户在一个特定的应用场景里的一个完整的业务操作流程。所以，它包含更多的细节，且更加容易被人理解。</p><p>比如，有关积分有效期的用户用例，我们可以进行如下的设计：</p><ul><li>用户在<strong>获取积分</strong>的时候，会告知积分的有效期； </li><li>用户在<strong>使用积分</strong>的时候，会优先使用快过期的积分； </li><li>用户在<strong>查询积分明细</strong>的时候，会显示积分的有效期和状态（是否过期）； </li><li>用户在<strong>查询总可用积分</strong>的时候，会排除掉过期的积分。</li></ul><h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><h4 id="合理地将功能划分到不同模块"><a href="#合理地将功能划分到不同模块" class="headerlink" title="合理地将功能划分到不同模块"></a>合理地将功能划分到不同模块</h4><p>系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。</p><p>对于前面罗列的所有功能点，我们有下面三种模块划分方法。</p><p>第一种划分方式是：积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护（增删改查），不划分到积分系统中，而是放到更上层的营销系统中。这样积分系统就会变得非常简单，只需要负责增加积分、减少积分、查询积分、查询积分明细等这几个工作。</p><p>我举个例子解释一下。比如，用户通过下订单赚取积分。订单系统通过异步发送消息或者同步调用接口的方式，告知营销系统订单交易成功。营销系统根据拿到的订单信息，查询订单对应的积分兑换规则（兑换比例、有效期等），计算得到订单可兑换的积分数量，然后调用积分系统的接口给用户增加积分。</p><p>第二种划分方式是：积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护，分散在各个相关业务系统中，比如订单系统、评论系统、签到系统、换购商城、优惠券系统等。还是刚刚那个下订单赚取积分的例子，在这种情况下，用户下订单成功之后，订单系统根据商品对应的积分兑换比例，计算所能兑换的积分数量，然后直接调用积分系统给用户增加积分。</p><p>第三种划分方式是：所有的功能都划分到积分系统中，包括积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护。还是同样的例子，用户下订单成功之后，订单系统直接告知积分系统订单交易成功，积分系统根据订单信息查询积分兑换规则，给用户增加积分。</p><p>怎么判断哪种模块划分合理呢？</p><p>实际上，我们可以反过来通过看它是否符合高内聚、低耦合特性来判断。如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，那说明模块划分的不够合理，职责不够清晰，耦合过于严重。除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。</p><p>所以，综合考虑，我们更倾向于第一种和第二种模块划分方式。但是，不管选择这两种中的哪一种，积分系统所负责的工作是一样的，只包含积分的增、减、查询，以及积分明细的记录和查询。</p><h4 id="设计模块与模块之间的交互关系"><a href="#设计模块与模块之间的交互关系" class="headerlink" title="设计模块与模块之间的交互关系"></a>设计模块与模块之间的交互关系</h4><p>比较常见的系统之间的交互方式有两种，一种是同步接口调用，另一种是利用消息中间件异步调用。第一种方式简单直接，第二种方式的解耦效果更好。</p><p>比如，用户下订单成功之后，订单系统推送一条消息到消息中间件，营销系统订阅订单成功消息，触发执行相应的积分兑换逻辑。这样订单系统就跟营销系统完全解耦，订单系统不需要知道任何跟积分相关的逻辑，而营销系统也不需要直接跟订单系统交互。除此之外，<strong>上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用</strong>。比如，营销系统和积分系统是上下层关系，它们之间就比较推荐使用同步接口调用。</p><h4 id="设计模块的接口、数据库、业务模型"><a href="#设计模块的接口、数据库、业务模型" class="headerlink" title="设计模块的接口、数据库、业务模型"></a>设计模块的接口、数据库、业务模型</h4><p>数据库和接口的设计非常重要，一旦设计好并投入使用之后，这两部分都不能轻易改动。</p><ul><li>改动数据库表结构，需要涉及数据的迁移和适配；</li><li>改动接口，需要推动接口的使用者作相应的代码修改。</li></ul><p>这两种情况，即便是微小的改动，执行起来都会非常麻烦。因此，我们在设计接口和数据库的时候，一定要多花点心思和时间，切不可过于随意。相反，业务逻辑代码侧重内部实现，不涉及被外部依赖的接口，也不包含持久化的数据，所以对改动的容忍性更大。</p><p><strong>如何设计数据库</strong> </p><p>数据库的设计比较简单。实际上，我们只需要一张记录积分流水明细的表就可以了。表中记录积分的赚取和消费流水。用户积分的各种统计数据，比如总积分、总可用积分等，都可以 通过这张表来计算得到。</p><img src="/2021/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07/image-20210704122015552.png" class="" title="image-20210704122015552"><p><strong>如何设计积分系统的接口</strong></p><p>接口设计要符合单一职责原则，粒度越小通用性就越好。但是，接口粒度太小也会带来一些问题。比如，一个功能的实现要调用多个小接口，一方面如果接口调用走网络（特别是公网），多次远程接口调用会影响性能；另一方面，本该在一个接口中完成的原子操作，现在 分拆成多个小接口来完成，就可能会涉及分布式事务的数据一致性问题（一个接口执行成功 了，但另一个接口执行失败了）。所以，为了兼顾易用性和性能，我们可以借鉴 <strong>facade（外观）设计模式</strong>，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。 对于积分系统来说，我们需要设计如下这样几个接口。</p><img src="/2021/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07/image-20210704122038660.png" class="" title="image-20210704122038660"><p><strong>业务模型的设计</strong></p><p>前面我们讲到，从代码实现角度来说，大部分业务系统的开发都可以分为 Controller、 Service、Repository 三层。Controller 层负责接口暴露，Repository 层负责数据读写， Service 层负责核心业务逻辑，也就是这里说的业务模型。 </p><p>除此之外，前面我们还提到两种开发模式，基于贫血模型的传统开发模式和基于充血模型的 DDD 开发模式。前者是一种面向过程的编程风格，后者是一种面向对象的编程风格。不管是 DDD 还是 OOP，高级开发模式的存在一般都是为了应对复杂系统，应对系统的复杂 性。对于我们要开发的积分系统来说，因为业务相对比较简单，所以，选择简单的基于贫血模型的传统开发模式就足够了。 </p><p>从开发的角度来说，我们可以把积分系统作为一个独立的项目，来独立开发，也可以跟其他业务代码（比如营销系统）放到同一个项目中进行开发。从运维的角度来说，我们可以将它跟其他业务一块部署，也可以作为一个微服务独立部署。具体选择哪种开发和部署方式，我 们可以参考公司当前的技术架构来决定。</p><p> 实际上，积分系统业务比较简单，代码量也不多，我更倾向于将它跟营销系统放到一个项目中开发部署。只要我们做好代码的模块化和解耦，让积分相关的业务代码跟其他业务代码之间边界清晰，没有太多耦合，后期如果需要将它拆分成独立的项目来开发部署，那也并不困难。</p>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>06.原则理论</title>
    <link href="http://universeinheart.github.io/2021/06/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06/"/>
    <id>http://universeinheart.github.io/2021/06/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06/</id>
    <published>2021-06-22T15:26:37.000Z</published>
    <updated>2021-06-27T15:20:09.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><strong>对扩展开放、对修改关闭</strong></p><p>在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变 更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整 体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩 展开放、对修改关闭”。 还有，在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化， 提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。</p><h2 id="里式替换原则（LSP）"><a href="#里式替换原则（LSP）" class="headerlink" title="里式替换原则（LSP）"></a>里式替换原则（LSP）</h2><p><strong>子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</strong></p><p>举例：父类 <code>Transporter</code> 使用 <code>org.apache.http</code> 库中的 <code>HttpClient</code> 类来传输网络数据。子类 <code>SecurityTransporter</code> 继承父类 <code>Transporter</code>，增加了额外的功能，支持传输 <code>appId</code> 和 <code>appToken</code> 安全认证信息。子类 <code>SecurityTransporter</code> 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。</p><blockquote><p>里氏替换原则和多态的区别</p><p>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。</p><p>里式替换是一种设计原则，是用来指导继承关系中，子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p></blockquote><p>违反里式替换原则举例</p><p><strong>子类违背父类声明要实现的功能</strong></p><p>父类中提供的 <code>sortOrdersByAmount()</code> 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 <code>sortOrdersByAmount()</code> 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p><p><strong>子类违背父类对输入、输出、异常的约定</strong></p><p><strong>子类违背父类注释中所罗列的任何特殊说明</strong></p><p>父类中定义的 <code>withdraw()</code> 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 <code>withdraw()</code> 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的</p><blockquote><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。</p><p>那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。</p><p>这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至 包括注释中所罗列的任何特殊说明。</p></blockquote><h2 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a>接口隔离原则(ISP)</h2><p><strong>接口的调用者或者使用者不应该强迫依赖它不需要的接口</strong></p><p>在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使 用，而不是强迫其他调用者也依赖这部分不会被用到的接口。</p><p>函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现</p><h2 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h2><h3 id="控制反转（IOC）"><a href="#控制反转（IOC）" class="headerlink" title="控制反转（IOC）"></a>控制反转（IOC）</h3><p>控制反转并不是一种具体的实现技巧，而是 一个比较笼统的设计思想，一般用来指导框架层面的设计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (doTest()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Test succeed.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Test failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doTest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitApplication</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;TestCase&gt; testCases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(TestCase testCase)</span> </span>&#123;</span><br><span class="line">testCases.add(testCase);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (TestCase <span class="keyword">case</span>: testCases) &#123;</span><br><span class="line"><span class="keyword">case</span>.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用 register()</span></span><br><span class="line">JunitApplication.register(<span class="keyword">new</span> UserServiceTest();</span><br></pre></td></tr></table></figure><p>上面举的这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的 执行。这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架</p><h3 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h3><p>不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递 （或注入）给类使用。</p><h3 id="依赖注入框架（DI-Framework）"><a href="#依赖注入框架（DI-Framework）" class="headerlink" title="依赖注入框架（DI Framework）"></a>依赖注入框架（DI Framework）</h3><p>只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><h3 id="依赖反转原则（DIP）"><a href="#依赖反转原则（DIP）" class="headerlink" title="依赖反转原则（DIP）"></a>依赖反转原则（DIP）</h3><blockquote><p>High-level modules shouldn’t depend on low-level modules. </p><p>Both modules should depend on abstractions. </p><p>In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p></blockquote><p>举例</p><blockquote><p>Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Sevlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。</p></blockquote><h2 id="KISS、YAGNI原则"><a href="#KISS、YAGNI原则" class="headerlink" title="KISS、YAGNI原则"></a>KISS、YAGNI原则</h2><h3 id="KISS原则"><a href="#KISS原则" class="headerlink" title="KISS原则"></a>KISS原则</h3><blockquote><p>Keep It Simple and Stupid.</p></blockquote><h3 id="YAGNI原则"><a href="#YAGNI原则" class="headerlink" title="YAGNI原则"></a>YAGNI原则</h3><blockquote><p>You Ain’t Gonna Need It</p></blockquote><p>直译就是：你不会需要它。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。</p><p>实际上，这条原则的核心思想就是：<strong>不要做过度设计</strong>。</p><h2 id="DRY"><a href="#DRY" class="headerlink" title="DRY"></a>DRY</h2><blockquote><p>Don’t Repeat Yourself</p></blockquote><p>将它应用在编程中，可以理解为：<strong>不要写重复的代码</strong></p><blockquote><p>实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。</p><p>实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。</p><p>除此之外，代码执行重复也算是违反 DRY 原则。</p></blockquote><h3 id="代码复用性（Code-Reusability）"><a href="#代码复用性（Code-Reusability）" class="headerlink" title="代码复用性（Code Reusability）"></a>代码复用性（Code Reusability）</h3><p>代码的复用性是评判代码质量的一个非常重要的标准</p><blockquote><p>怎么提高代码复用性？</p><ol><li>减少代码耦合</li><li>满足单一职责原则</li><li>模块化</li><li>业务与非业务逻辑分离</li><li>继承、多态、抽象、封装</li><li>通用代码下沉</li><li>应用模板等设计模式</li></ol></blockquote><h2 id="迪米特法则（LOD）"><a href="#迪米特法则（LOD）" class="headerlink" title="迪米特法则（LOD）"></a>迪米特法则（LOD）</h2><p><strong>最小知识原则</strong></p><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性， 缩小功能改动导致的代码改动范围。</p><p>“高内聚”用来指导类本身的设计，“松耦合”用来指 导类与类之间依赖关系的设计。 </p><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。</p><p>所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p><blockquote><p>如何理解迪米特法则?</p><p>不该有直接依赖关系的类之间，不要有依赖</p><p>有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）</p></blockquote>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>聊天</title>
    <link href="http://universeinheart.github.io/2021/06/21/%E5%B0%8F%E5%86%8C%E5%AD%90/%E8%81%8A%E5%A4%A9/"/>
    <id>http://universeinheart.github.io/2021/06/21/%E5%B0%8F%E5%86%8C%E5%AD%90/%E8%81%8A%E5%A4%A9/</id>
    <published>2021-06-21T15:26:37.000Z</published>
    <updated>2021-06-21T16:00:12.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>交流难度和交流环境、交流者的关系成正比，语境越复杂，关系越陌生，交流越困难</p><blockquote><p>打完招呼在完成一两句对话，挑起话题可以从身边的事情开始，这样双方都可以参与其中，打破陌生感</p></blockquote><p>聊天过程中不要轻易说结论性语言，聊天是不需要总结的，发散就好</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;交流难度和交流环境、交流者的关系成正比，语境越复杂，关系越陌生，交流越困难&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;打完招呼在完成一两句对话，挑起话题可以从</summary>
      
    
    
    
    <category term="聊天" scheme="http://universeinheart.github.io/categories/%E8%81%8A%E5%A4%A9/"/>
    
    
    <category term="聊天" scheme="http://universeinheart.github.io/tags/%E8%81%8A%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>05.对接口鉴权功能开发做面向对象分析</title>
    <link href="http://universeinheart.github.io/2021/06/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05/"/>
    <id>http://universeinheart.github.io/2021/06/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05/</id>
    <published>2021-06-21T15:26:37.000Z</published>
    <updated>2021-06-21T14:08:00.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>整个的分析过程分为了循序渐进的四轮。每一轮都是对上一轮的迭代优化，最后形成一个可执行、可落地的需求列表。</p><h3 id="第一轮基础分析"><a href="#第一轮基础分析" class="headerlink" title="第一轮基础分析"></a>第一轮基础分析</h3><p>最简单的解决方案就是，通过用户名加密码来做认证。给每个允许访问我们服务的调用方，派发一个应用名（或者叫应用 ID、AppID）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的 AppID 和密码。微服务在接收到接口调用请求之后，会解析出 AppID 和密码，跟存储在微服务端的 AppID 和密码进行比对。如果一致，说明认证成功，则允许接口调用请求；否则，就拒绝 接口调用请求。</p><h3 id="第二轮分析优化"><a href="#第二轮分析优化" class="headerlink" title="第二轮分析优化"></a>第二轮分析优化</h3><p>不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的。那如果我们借助加密算法（比如 SHA），对密码进行加密之后，再传递到微服务端验证，是不是就可以了呢？实际上，这样也是不安全的，因为加密之后的密码及 AppID，照样可以被未 认证系统（或者说黑客）截获，未认证系统可以携带这个加密之后的密码以及对应的 AppID，伪装成已认证系统来访问我们的接口。这就是典型的“<strong>重放攻击</strong>”。</p><p>调用方将请求接口的 URL 跟 AppID、密码拼接在一起， 然后进行加密，生成一个 token。调用方在进行接口请求的的时候，将这个 token 及 AppID，随 URL 一块传递给微服务端。微服务端接收到这些数据之后，根据 AppID 从数 据库中取出对应的密码，并通过同样的 token 生成算法，生成另外一个 token。用这个新 生成的 token 跟调用方传递过来的 token 对比。如果一致，则允许接口调用请求；否则， 就拒绝接口调用请求。</p><img src="/2021/06/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05/image-20210621201913103.png" class="" title="image-20210621201913103"><h3 id="第三轮分析优化"><a href="#第三轮分析优化" class="headerlink" title="第三轮分析优化"></a>第三轮分析优化</h3><p>不过，这样的设计仍然存在重放攻击的风险，还是不够安全。每个 URL 拼接上 AppID、密 码生成的 token 都是固定的。未认证系统截获 URL、token 和 AppID 之后，还是可以通过重放攻击的方式。</p><p>为了解决这个问题，我们可以进一步优化 token 生成算法，引入一个<strong>随机变量</strong>，让每次接口请求生成的 token 都不一样。我们可以选择<strong>时间戳</strong>作为随机变量。将 URL、AppID、密码、时间戳四者进行加密来生成 token。调用方在进行接口请求的时候，将 token、AppID、时间戳，随 URL 一并传递给微服务端。 微服务端在收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的<strong>时间窗口</strong>内（比如一分钟）。如果超过一分钟，则判定 token 过期，拒绝接口请求。如果没有超过一分钟，则说明 token 没有过期，就再通过同样的 token 生成算法，在服务端生成新的 token，与调用方传递过来的 token 比对，看是否一致。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p><img src="/2021/06/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05/image-20210621203212342.png" class="" title="image-20210621203212342"><h3 id="第四轮分析优化"><a href="#第四轮分析优化" class="headerlink" title="第四轮分析优化"></a>第四轮分析优化</h3><p>不过，你可能会说，这样还是不够安全啊。未认证系统还是可以在这一分钟的 token 失效窗口内，通过截获请求、重放请求，来调用我们的接口啊！ 你说得没错。不过，攻与防之间，本来就没有绝对的安全。我们能做的就是，尽量提高攻击的成本。这个方案虽然还有漏洞，但是实现起来足够简单，而且不会过度影响接口本身的性能（比如响应时间）。所以，权衡安全性、开发成本、对系统性能的影响，这个方案算是比 较折中、比较合理的了</p><p>需求一般都比较 抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具象化，最终产 生清晰的、可落地的需求定义。需求定义是否清晰、合理，直接影响了后续的设计、编码实 现是否顺畅。需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的 解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这 样一个思考过程能让我们摆脱无从下手的窘境。</p><h2 id="如何进行面向对象设计？"><a href="#如何进行面向对象设计？" class="headerlink" title="如何进行面向对象设计？"></a>如何进行面向对象设计？</h2><p>根据需求描述，拆解成小的功能点，一条一条罗列下来。</p><p>注意，拆解出来的每个功能点要尽可能的小。每个功能点只负责做一件很小的事情</p><ol><li>把 URL、AppID、密码、时间戳拼接为一个字符串；</li><li>对字符串通过加密算法加密生成 token</li><li>将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li><li>解析 URL，得到 token、AppID、时间戳等信息； </li><li>从存储中取出 AppID 和对应的密码； </li><li>根据时间戳判断 token 是否过期失效； </li><li>验证两个 token 是否匹配</li></ol><p>从上面的功能列表中，我们发现，1、2、6、7 都是跟 token 有关，负责 token 的生成、 验证；3、4 都是在处理 URL，负责 URL 的拼接、解析；5 是操作 AppID 和密码，负责从 存储中读取 AppID 和密码。所以，我们可以粗略地得到三个核心的类：AuthToken、 Url、CredentialStorage。AuthToken 负责实现 1、2、6、7 这四个操作；Url 负责 3、4 两个操作；CredentialStorage 负责 5 这个操作。</p><p>如果我们面对的是更加大型的软件开发、更加 复杂的需求开发，涉及的功能点可能会很多，对应的类也会比较多，像刚刚那样根据需求逐 句罗列功能点的方法，最后会得到一个长长的列表，就会有点凌乱、没有规律。针对这种复 杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功 能模块，然后再在模块内部，应用我们刚刚讲的方法，进行面向对象设计。而模块的划分和 识别，跟类的划分和识别，是类似的套路。</p>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://universeinheart.github.io/2021/06/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09/"/>
    <id>http://universeinheart.github.io/2021/06/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09/</id>
    <published>2021-06-21T06:02:01.212Z</published>
    <updated>2021-07-04T07:36:20.389Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>04.贫血模型和充血模型</title>
    <link href="http://universeinheart.github.io/2021/06/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04/"/>
    <id>http://universeinheart.github.io/2021/06/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04/</id>
    <published>2021-06-20T15:26:37.000Z</published>
    <updated>2021-06-21T06:01:29.510Z</updated>
    
    <content type="html"><![CDATA[<p>只包含数据，不包含业务逻辑的类，就叫作<strong>贫血模型</strong>（Anemic Domain Model），比较适合业务比较简单的系统开发。</p><p><strong>充血模型</strong>（Rich Domain Model） ，数据和对应的业务逻辑被封装到同一个类中，更适合业务复杂的系统开发。比如，包含各种利息 计算模型、还款模型等复杂业务的金融系统</p><p>领域驱动设计，即 DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。</p><h2 id="虚拟钱包业务背景介绍"><a href="#虚拟钱包业务背景介绍" class="headerlink" title="虚拟钱包业务背景介绍"></a>虚拟钱包业务背景介绍</h2><h3 id="充值"><a href="#充值" class="headerlink" title="充值"></a>充值</h3><p>用户通过三方支付渠道，把自己银行卡账户内的钱，充值到虚拟钱包账号中。这整个过程， 我们可以分解为三个主要的操作流程：</p><ul><li>第一个操作是从用户的银行卡账户转账到应用的公共银行卡账户；</li><li>第二个操作是将用户的充值金额加到虚拟钱包余额上；</li><li>第三个操作是记录刚刚这笔交易流水</li></ul><h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h3><p>用户用钱包内的余额，支付购买应用内的商品。实际上，支付的过程就是一个转账的过程， 从用户的虚拟钱包账户划钱到商家的虚拟钱包账户上，然后触发真正的银行转账操作，从应用的公共银行账户转钱到商家的银行账户（注意，这里并不是从用户的银行账户转钱到商家的银行账户）。除此之外，我们也需要记录这笔支付的交易流水信息。</p><h3 id="提现"><a href="#提现" class="headerlink" title="提现"></a>提现</h3><p>除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户。同样，我们也需要记录这笔提现的交易流水信息。</p><h3 id="查询余额"><a href="#查询余额" class="headerlink" title="查询余额"></a>查询余额</h3><p>查询余额功能比较简单，我们看一下虚拟钱包中的余额数字即可。</p><h3 id="查询交易流水"><a href="#查询交易流水" class="headerlink" title="查询交易流水"></a>查询交易流水</h3><p>查询交易流水也比较简单。我们只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，我们会记录相应的交易信息。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可。</p><h2 id="钱包系统的设计思路"><a href="#钱包系统的设计思路" class="headerlink" title="钱包系统的设计思路"></a>钱包系统的设计思路</h2><p>可以把整个钱包系统的业务划分为两部分， 其中一部分单纯跟应用内的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。我们基 于这样一个业务划分，给系统解耦，将整个钱包系统拆分为两个子系统：<strong>虚拟钱包系统</strong>和<strong>三方支付系统</strong>。接来下只聚焦于虚拟钱包系统的设计与实现。对于三方支付系统以及整个钱包系统的设计与实现，不做讲解。</p><blockquote><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 <code>Service</code> 层。在基于充血模型的开发模式下，我们将部分原来在 <code>Service</code> 类中的业务逻辑移动到了一 个充血的 <code>Domain</code> 领域模型中，让 <code>Service</code> 类的实现依赖这个 <code>Domain</code> 类。 </p></blockquote><blockquote><p>在基于充血模型的 DDD 开发模式下，<code>Service</code> 类并不会完全移除，而是负责一些不适合放 在 <code>Domain</code> 类中的功能。比如，负责与 <code>Repository</code> 层打交道、跨领域模型的业务聚合功 能、幂等事务等非功能性的工作。 </p></blockquote>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>03.接口vs抽象类的区别？为什么基于接口而非实现编程？</title>
    <link href="http://universeinheart.github.io/2021/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03/"/>
    <id>http://universeinheart.github.io/2021/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03/</id>
    <published>2021-06-19T15:26:37.000Z</published>
    <updated>2021-06-19T16:31:05.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口vs抽象类的区别？"><a href="#接口vs抽象类的区别？" class="headerlink" title="接口vs抽象类的区别？"></a>接口vs抽象类的区别？</h2><p>使用接口来实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则</p><p>使用抽象类来实现面向对象的继承特性和模板设计模式等等</p><h3 id="抽象类和接口的语法特性"><a href="#抽象类和接口的语法特性" class="headerlink" title="抽象类和接口的语法特性"></a>抽象类和接口的语法特性</h3><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现， 也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。</p><p>接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p><h3 id="抽象类和接口存在的意义"><a href="#抽象类和接口存在的意义" class="headerlink" title="抽象类和接口存在的意义"></a>抽象类和接口存在的意义</h3><p>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。</p><p>接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性</p><h3 id="抽象类和接口的应用场景区别"><a href="#抽象类和接口的应用场景区别" class="headerlink" title="抽象类和接口的应用场景区别"></a>抽象类和接口的应用场景区别</h3><p>什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关 系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><h2 id="为什么基于接口而非实现编程？"><a href="#为什么基于接口而非实现编程？" class="headerlink" title="为什么基于接口而非实现编程？"></a>为什么基于接口而非实现编程？</h2><p>接口和实现分离，<strong>封装不稳定的实现</strong>，<strong>暴露稳定的接口</strong>。</p><p>上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p><p>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对</p><blockquote><p> 基于接口要做到下面 3 点</p><ol><li>函数的命名不能暴露任何实现细节</li><li>封装具体的实现细节</li><li>为实现类定义抽象的接口</li></ol><p>在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</p></blockquote><h2 id="如何决定该用组合还是继承？"><a href="#如何决定该用组合还是继承？" class="headerlink" title="如何决定该用组合还是继承？"></a>如何决定该用组合还是继承？</h2><p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承</strong> ,继承层次过深、过复杂，会影响到代码的可维护性</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="设计模式之美" scheme="http://universeinheart.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/"/>
    
    
    <category term="设计模式" scheme="http://universeinheart.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
