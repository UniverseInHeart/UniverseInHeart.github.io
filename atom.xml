<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HelloWorld</title>
  
  
  <link href="http://universeinheart.github.io/atom.xml" rel="self"/>
  
  <link href="http://universeinheart.github.io/"/>
  <updated>2021-05-13T15:41:55.635Z</updated>
  <id>http://universeinheart.github.io/</id>
  
  <author>
    <name>xjf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>03.NoSQL 实践</title>
    <link href="http://universeinheart.github.io/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/"/>
    <id>http://universeinheart.github.io/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/</id>
    <published>2021-05-13T15:26:37.000Z</published>
    <updated>2021-05-13T15:41:55.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过-Docker-辅助开发"><a href="#通过-Docker-辅助开发" class="headerlink" title="通过 Docker 辅助开发"></a>通过 Docker 辅助开发</h2><h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234130722.png" class="" title="image-20210513234130722"><h3 id="认识-Docker"><a href="#认识-Docker" class="headerlink" title="认识 Docker"></a>认识 Docker</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234119641.png" class="" title="image-20210513234119641"><h3 id="Docker-常⽤命令"><a href="#Docker-常⽤命令" class="headerlink" title="Docker 常⽤命令"></a>Docker 常⽤命令</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234104049.png" class="" title="image-20210513234104049"><h3 id="docker-run-的常⽤选项"><a href="#docker-run-的常⽤选项" class="headerlink" title="docker run 的常⽤选项"></a>docker run 的常⽤选项</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234032281.png" class="" title="image-20210513234032281"><h3 id="国内-Docker-镜像配置"><a href="#国内-Docker-镜像配置" class="headerlink" title="国内 Docker 镜像配置"></a>国内 Docker 镜像配置</h3><img src="/2021/05/13/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/04/image-20210513234048018.png" class="" title="image-20210513234048018"><h3 id="通过-Docker-启动-Redis"><a href="#通过-Docker-启动-Redis" class="headerlink" title="通过 Docker 启动 Redis"></a>通过 Docker 启动 Redis</h3><p><strong>官⽅指引</strong></p><ul><li><a href="https://hub.docker.com/_/redis">https://hub.docker.com/_/redis</a> </li></ul><p><strong>获取镜像</strong></p><ul><li>docker pull redis </li></ul><p><strong>启动 Redis</strong></p><ul><li>docker run –name redis -d -p 6379:6379 redis</li></ul><h2 id="在-Spring-中访问-Redis"><a href="#在-Spring-中访问-Redis" class="headerlink" title="在 Spring 中访问 Redis"></a>在 Spring 中访问 Redis</h2><h2 id="Redis-的哨兵与集群模式"><a href="#Redis-的哨兵与集群模式" class="headerlink" title="Redis 的哨兵与集群模式"></a>Redis 的哨兵与集群模式</h2><h2 id="了解-Spring-的缓存抽象"><a href="#了解-Spring-的缓存抽象" class="headerlink" title="了解 Spring 的缓存抽象"></a>了解 Spring 的缓存抽象</h2><h2 id="Redis-在-Spring-中的其他⽤法"><a href="#Redis-在-Spring-中的其他⽤法" class="headerlink" title="Redis 在 Spring 中的其他⽤法"></a>Redis 在 Spring 中的其他⽤法</h2>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://universeinheart.github.io/tags/SpringBoot/"/>
    
    <category term="JDBC" scheme="http://universeinheart.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>Java 动态代理</title>
    <link href="http://universeinheart.github.io/2021/05/13/Java/000/"/>
    <id>http://universeinheart.github.io/2021/05/13/Java/000/</id>
    <published>2021-05-13T15:18:37.000Z</published>
    <updated>2021-05-13T15:36:21.747Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是字节码增强技术"><a href="#什么是字节码增强技术" class="headerlink" title="什么是字节码增强技术"></a>什么是字节码增强技术</h3><p>java字节码生成之后，**运行期 **对其进行修改，增强其功能</p><h3 id="运行期"><a href="#运行期" class="headerlink" title="运行期"></a>运行期</h3><h3 id="字节码相关技术"><a href="#字节码相关技术" class="headerlink" title="字节码相关技术"></a>字节码相关技术</h3><ul><li>动态代理</li><li>CGLIB</li><li>javassist</li><li>asm</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li>实质上动态生成字节码与反射机制结合</li><li>运行期根据不同的入参生成不同的字节码文件，继承于Proxy对象，实现传入对象的实现接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyObject</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        object=o;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),o.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalArgumentException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before invoke ...&quot;</span>);</span><br><span class="line">        Object result= method.invoke(object,args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after invoke ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理的步骤"><a href="#动态代理的步骤" class="headerlink" title="动态代理的步骤"></a>动态代理的步骤</h3><p><strong>创建一个实现 <code>InvocationHandler</code>  的类，必须实现 <code>Invoke</code> 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object proxyObject;</span><br><span class="line"></span><br><span class="line">    MyInvocationHandler(Object proxyObject) &#123;</span><br><span class="line">        <span class="keyword">this</span>.proxyObject = proxyObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before invoke ...&quot;</span> + method);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != args) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object o : args) &#123;</span><br><span class="line">                System.out.println(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Object invoke = method.invoke(proxyObject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after invoke ...&quot;</span> + method);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建被代理的类以及接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;18&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;18&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过<code>Proxy</code>的静态方法  <code>newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h) </code>创建一个代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxyObject</span><span class="params">(Object realObject)</span> </span>&#123;</span><br><span class="line">    MyInvocationHandler myInvocationHandler = <span class="keyword">new</span> MyInvocationHandler(realObject);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object proxyInstance = Proxy.newProxyInstance(</span><br><span class="line">                realObject.getClass().getClassLoader(),</span><br><span class="line">                realObject.getClass().getInterfaces(),</span><br><span class="line">                myInvocationHandler);</span><br><span class="line">        <span class="keyword">return</span> proxyInstance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过代理调用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List proxyList = (List) getProxyObject(<span class="keyword">new</span> Vector());</span><br><span class="line">proxyList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">proxyList.add(<span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是字节码增强技术&quot;&gt;&lt;a href=&quot;#什么是字节码增强技术&quot; class=&quot;headerlink&quot; title=&quot;什么是字节码增强技术&quot;&gt;&lt;/a&gt;什么是字节码增强技术&lt;/h3&gt;&lt;p&gt;java字节码生成之后，**运行期 **对其进行修改，增强其功能&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://universeinheart.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://universeinheart.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>03.O/R Mapping 实践</title>
    <link href="http://universeinheart.github.io/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/"/>
    <id>http://universeinheart.github.io/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/</id>
    <published>2021-05-11T15:26:37.000Z</published>
    <updated>2021-05-12T23:26:15.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识-Spring-Data-JPA"><a href="#认识-Spring-Data-JPA" class="headerlink" title="认识 Spring Data JPA"></a>认识 Spring Data JPA</h2><h3 id="Java-Persistence-API"><a href="#Java-Persistence-API" class="headerlink" title="Java Persistence API"></a>Java Persistence API</h3><p>JPA 为对象关系映射提供了⼀种基于 POJO 的持久化模型</p><ul><li>简化数据持久化代码的开发⼯作</li><li>为 Java 社区屏蔽不同持久化 API 的差异</li></ul><h3 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h3><p>在保留底层存储特性的同时，提供相对⼀致的、基于 Spring 的编程模型</p><p>主要模块</p><ul><li>Spring Data Commons</li><li>Spring Data JDBC</li><li><strong>Spring Data JPA</strong></li><li>Spring Data Redis</li></ul><img src="/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/image-20210511011936375.png" class="" title="image-20210511011936375"><h2 id="定义-JPA-实体对象"><a href="#定义-JPA-实体对象" class="headerlink" title="定义 JPA 实体对象"></a>定义 JPA 实体对象</h2><h3 id="常⽤-JPA-注解"><a href="#常⽤-JPA-注解" class="headerlink" title="常⽤ JPA 注解"></a>常⽤ JPA 注解</h3><p><strong>实体</strong></p><ul><li><code>@Entity</code>  注明这个类是一个实体</li><li><code>@MappedSuperclass</code> </li><li><code>@Table(name)</code>  实体和表关联</li></ul><p><strong>主键</strong></p><ul><li><code>@Id</code><ul><li><code>@GeneratedValue(strategy, generator)</code> </li><li><code>@SequenceGenerator(name, sequenceName)</code></li></ul></li></ul><img src="/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/image-20210511012943447.png" class="" title="image-20210511012943447"><p><strong>映射</strong></p><ul><li><code>@Column(name, nullable, length, insertable, updatable)</code> </li><li><code>@JoinTable(name)</code>、<code>@JoinColumn(name)</code> </li></ul><p><strong>关系</strong> </p><ul><li><code>@OneToOne</code>、<code>@OneToMany</code>、<code>@ManyToOne</code>、<code>@ManyToMany</code></li><li><code>@OrderBy</code></li></ul><h2 id="通过-Spring-Data-JPA-操作数据库"><a href="#通过-Spring-Data-JPA-操作数据库" class="headerlink" title="通过 Spring Data JPA 操作数据库"></a>通过 Spring Data JPA 操作数据库</h2><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p><code>@EnableJpaRepositories</code> 注解，自动发现 <code>Repository</code> 的扩展</p><p><strong><code>Repository</code> 接⼝</strong></p><ul><li><code>CrudRepository&lt;T,ID&gt;</code></li><li><code>PagingAndSortingRepository&lt;T,ID&gt;</code></li><li><code>JpaRepository&lt;T,ID&gt;</code></li></ul><h3 id="定义查询"><a href="#定义查询" class="headerlink" title="定义查询"></a>定义查询</h3><p>根据⽅法名定义查询</p><ul><li>find…By… / read…By… / query…By… / get…By… </li><li>count…By… </li><li>…OrderBy…[Asc / Desc] </li><li>And / Or / IgnoreCase </li><li>Top / First / Distinct</li></ul><h3 id="分⻚查询"><a href="#分⻚查询" class="headerlink" title="分⻚查询"></a>分⻚查询</h3><ul><li>PagingAndSortingRepository &lt;T, ID&gt;</li><li>Pageable / Sort </li><li>Slice / Page&lt;T, ID&gt;</li></ul><h3 id="保存实体"><a href="#保存实体" class="headerlink" title="保存实体"></a>保存实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Coffee latte = Coffee.builder().name(<span class="string">&quot;latte&quot;</span>).price(Money.of(CurrencyUnit.of(<span class="string">&quot;CNY&quot;</span>), <span class="number">30.0</span>)).build();</span><br><span class="line">coffeeRepository.save(latte);</span><br><span class="line"></span><br><span class="line">CoffeeOrder order = CoffeeOrder.builder()</span><br><span class="line">.customer(<span class="string">&quot;Li Lei&quot;</span>)</span><br><span class="line">.items(Collections.singletonList(espresso))</span><br><span class="line">.state(OrderState.INIT)</span><br><span class="line">.build();</span><br><span class="line">orderRepository.save(order);</span><br></pre></td></tr></table></figure><h3 id="查询实体"><a href="#查询实体" class="headerlink" title="查询实体"></a>查询实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseRepository</span>&lt;<span class="title">T</span>, <span class="title">Long</span>&gt; <span class="keyword">extends</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findTop3ByOrderByUpdateTimeDescIdAsc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoffeeOrderRepository</span> <span class="keyword">extends</span> <span class="title">BaseRepository</span>&lt;<span class="title">CoffeeOrder</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;CoffeeOrder&gt; <span class="title">findByCustomerOrderById</span><span class="params">(String customer)</span></span>;</span><br><span class="line">    <span class="function">List&lt;CoffeeOrder&gt; <span class="title">findByItems_Name</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">coffeeRepository.findAll(Sort.by(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>)).forEach(c -&gt; log.info(<span class="string">&quot;Loading &#123;&#125;&quot;</span>, c));</span><br><span class="line"></span><br><span class="line">List&lt;CoffeeOrder&gt; list = orderRepository.findTop3ByOrderByUpdateTimeDescIdAsc();</span><br><span class="line">log.info(<span class="string">&quot;findTop3ByOrderByUpdateTimeDescIdAsc: &#123;&#125;&quot;</span>, JSON.toJSONString(list));</span><br><span class="line"></span><br><span class="line">list = orderRepository.findByCustomerOrderById(<span class="string">&quot;Li Lei&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;findByCustomerOrderById: &#123;&#125;&quot;</span>, JSON.toJSONString(list));</span><br><span class="line"><span class="comment">// 不开启事务会因为没Session而报LazyInitializationException</span></span><br><span class="line">list.forEach(o -&gt; &#123;</span><br><span class="line">log.info(<span class="string">&quot;Order &#123;&#125;&quot;</span>, o.getId());</span><br><span class="line">o.getItems().forEach(i -&gt; log.info(<span class="string">&quot;  Item &#123;&#125;&quot;</span>, i));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">list = orderRepository.findByItems_Name(<span class="string">&quot;latte&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;findByItems_Name: &#123;&#125;&quot;</span>, JSON.toJSONString(list));</span><br></pre></td></tr></table></figure><h2 id="Repository-是怎么从接⼝变成-Bean-的"><a href="#Repository-是怎么从接⼝变成-Bean-的" class="headerlink" title="Repository 是怎么从接⼝变成 Bean 的"></a>Repository 是怎么从接⼝变成 Bean 的</h2><h3 id="Repository-Bean-是如何创建的"><a href="#Repository-Bean-是如何创建的" class="headerlink" title="Repository Bean 是如何创建的"></a>Repository Bean 是如何创建的</h3><p><strong>JpaRepositoriesRegistrar</strong></p><ul><li>激活了 <code>@EnableJpaRepositories</code></li><li>返回了 <code>JpaRepositoryConfigExtension</code> </li></ul><p><strong>RepositoryBeanDefinitionRegistrarSupport.registerBeanDefinitions</strong></p><ul><li>注册 <code>Repository Bean</code>（类型是 <code>JpaRepositoryFactoryBean</code> ） </li></ul><p><strong>RepositoryConfigurationDelegate.registerRepositoriesIn</strong></p><ul><li>注册找到的 repositories</li></ul><p><strong>RepositoryConfigurationExtensionSupport.getRepositoryConfigurations</strong> </p><ul><li>取得 <code>Repository</code> 配置 </li></ul><p><strong>JpaRepositoryFactory.getTargetRepository</strong> </p><ul><li>创建了 <code>Repository</code></li></ul><h3 id="接⼝中的⽅法是如何被解释的"><a href="#接⼝中的⽅法是如何被解释的" class="headerlink" title="接⼝中的⽅法是如何被解释的"></a>接⼝中的⽅法是如何被解释的</h3><p><strong>RepositoryFactorySupport.getRepository 添加了Advice</strong></p><ul><li><code>DefaultMethodInvokingMethodInterceptor</code></li><li><code>QueryExecutorMethodInterceptor</code></li></ul><p><strong><code>AbstractJpaQuery.execute</code> 执⾏具体的查询</strong> </p><p><strong>语法解析在 <code>Part/PartTree</code> 中</strong></p><h2 id="通过-MyBatis-操作数据库"><a href="#通过-MyBatis-操作数据库" class="headerlink" title="通过 MyBatis 操作数据库"></a>通过 MyBatis 操作数据库</h2><h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><ul><li>mybatis.mapper-locations = classpath*:mapper/**/*.xml</li><li>mybatis.type-aliases-package = 类型别名的包名</li><li>mybatis.type-handlers-package = TypeHandler扫描包名（类型转换处理器）</li><li>mybatis.configuration.map-underscore-to-camel-case = true  </li></ul><h3 id="Mapper-的定义与扫描"><a href="#Mapper-的定义与扫描" class="headerlink" title="Mapper 的定义与扫描"></a>Mapper 的定义与扫描</h3><ul><li><code>@MapperScan</code> 配置扫描位置</li><li><code>@Mapper</code> 定义接⼝</li><li>映射的定义—— XML 与注解</li></ul><img src="/2021/05/11/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/03/image-20210512231958054.png" class="" title="image-20210512231958054"><h3 id="MyBatis-Generator"><a href="#MyBatis-Generator" class="headerlink" title="MyBatis Generator"></a>MyBatis Generator</h3><h3 id="MyBatis-PageHelper"><a href="#MyBatis-PageHelper" class="headerlink" title="MyBatis PageHelper"></a>MyBatis PageHelper</h3>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://universeinheart.github.io/tags/SpringBoot/"/>
    
    <category term="JDBC" scheme="http://universeinheart.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>01.JDBC必知必会01</title>
    <link href="http://universeinheart.github.io/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/"/>
    <id>http://universeinheart.github.io/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/</id>
    <published>2021-04-28T15:26:37.000Z</published>
    <updated>2021-05-12T23:31:21.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何配置数据源"><a href="#如何配置数据源" class="headerlink" title="如何配置数据源"></a>如何配置数据源</h2><h3 id="Spring-Boot-的配置演示"><a href="#Spring-Boot-的配置演示" class="headerlink" title="Spring Boot 的配置演示"></a>Spring Boot 的配置演示</h3><ul><li>引⼊对应数据库驱动——H2</li><li>引⼊ JDBC 依赖——<code>spring-boot-starter-jdbc</code> </li><li>获取 DataSource Bean，打印信息 </li><li>可通过 /acturator/beans 查看 Bean</li></ul><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210428225118878.png" class="" title="image-20210428225118878"><blockquote><p>CommandLineRunner<code>接口实现的</code>run<code>方法，会在 </code>SpringApplication.run` 方法中执行、</p></blockquote><h3 id="直接配置所需的Bean"><a href="#直接配置所需的Bean" class="headerlink" title="直接配置所需的Bean"></a>直接配置所需的Bean</h3><ul><li>数据源相关：  <code>DataSource</code>（根据选择的连接池实现决定）</li><li>事务相关： <code>DataSourceTransactionManager</code></li><li><code>TransactionTemplate</code> 操作相关：  <code>JdbcTemplate</code></li></ul><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210428225031908.png" class="" title="image-20210428225031908"><h3 id="Spring-Boot-做了哪些配置"><a href="#Spring-Boot-做了哪些配置" class="headerlink" title="Spring Boot 做了哪些配置"></a>Spring Boot 做了哪些配置</h3><p><code>DataSourceTransactionManager</code> 配置 <code>DataSource</code></p><p><code>JdbcTemplateAutoConfiguration</code>配置 <code>JdbcTemplate</code></p><p><code>DataSourceTransactionManagerAutoConfiguration</code> 配置 <code>DataSourceAutoConfiguration</code></p><p><strong>符合条件时才进⾏配置</strong></p><h3 id="数据源相关配置属性"><a href="#数据源相关配置属性" class="headerlink" title="数据源相关配置属性"></a>数据源相关配置属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通用</span><br><span class="line">spring.datasource.url&#x3D;jdbc:h2:mem:testdb</span><br><span class="line">spring.datasource.username&#x3D;admin</span><br><span class="line">spring.datasource.password&#x3D;admin</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver（可选）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化内嵌数据库</span><br><span class="line">spring.datasource.initialization-mode&#x3D;embedded|always|never</span><br><span class="line">spring.datasource.platform&#x3D;hsqldb | h2 | oracle | mysql | postgresql（与前者对应)</span><br><span class="line">spring.datasource.schema&#x3D;classpath:schema.sql (初始化表结构)</span><br><span class="line">spring.datasource.data&#x3D;classpath:data.sql (初始化数据)</span><br></pre></td></tr></table></figure><h3 id="配置多数据源的注意事项"><a href="#配置多数据源的注意事项" class="headerlink" title="配置多数据源的注意事项"></a>配置多数据源的注意事项</h3><p><strong>不同数据源的配置要分开</strong></p><p> <strong>关注每次使⽤的数据源</strong></p><ul><li>有多个DataSource时系统如何判断</li><li>对应的设施（事务、ORM等）如何选择DataSource</li></ul><h3 id="Spring-Boot中的多数据源配置"><a href="#Spring-Boot中的多数据源配置" class="headerlink" title="Spring Boot中的多数据源配置"></a>Spring Boot中的多数据源配置</h3><p><strong>排除Spring Boot的⾃动配置</strong></p><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210428230608385.png" class="" title="image-20210428230608385"><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210428230744941.png" class="" title="image-20210428230744941"><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210428230534448.png" class="" title="image-20210428230534448"><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210428230509295.png" class="" title="image-20210428230509295"><h2 id="连接池-HikariCP"><a href="#连接池-HikariCP" class="headerlink" title="连接池 HikariCP"></a>连接池 HikariCP</h2><blockquote><p><code>HikariCP</code> 为什么快?</p><ul><li>字节码级别优化（很多⽅法通过 <code>JavaAssist</code> ⽣成）</li><li>⼤量⼩改进<ul><li>⽤ <code>FastStatementList</code> 代替 <code>ArrayList</code></li><li>⽆锁集合 <code>ConcurrentBag</code></li><li>代理类的优化（⽐如，⽤ <code>invokestatic</code> 代替了 <code>invokevirtual</code>）</li></ul></li></ul></blockquote><h3 id="在-Spring-Boot-中的配置"><a href="#在-Spring-Boot-中的配置" class="headerlink" title="在 Spring Boot 中的配置"></a>在 Spring Boot 中的配置</h3><p><strong>Spring Boot 2.x</strong></p><ul><li>默认使⽤ <code>HikariCP</code></li><li>配置 <code>spring.datasource.hikari.*</code> </li></ul><p>Spring Boot 1.x </p><ul><li>默认使⽤ <code>Tomcat</code> 连接池，需要移除 tomcat-jdbc 依赖</li><li>spring.datasource.type=com.zaxxer.hikari.HikariDataSource</li></ul><h3 id="常⽤-HikariCP-配置参数"><a href="#常⽤-HikariCP-配置参数" class="headerlink" title="常⽤ HikariCP 配置参数"></a>常⽤ HikariCP 配置参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">常⽤配置</span><br><span class="line">spring.datasource.hikari.maximumPoolSize&#x3D;5</span><br><span class="line">spring.datasource.hikari.minimumIdle&#x3D;5</span><br><span class="line">spring.datasource.hikari.idleTimeout&#x3D;600000</span><br><span class="line">spring.datasource.hikari.connectionTimeout&#x3D;30000</span><br><span class="line">spring.datasource.hikari.maxLifetime&#x3D;1800000</span><br><span class="line"></span><br><span class="line">其他配置详⻅ HikariCP 官⽹</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;brettwooldridge&#x2F;HikariCP</span><br></pre></td></tr></table></figure><h3 id="如何配置数据源属性"><a href="#如何配置数据源属性" class="headerlink" title="如何配置数据源属性"></a>如何配置数据源属性</h3><p><code>org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hikari DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(HikariDataSource.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DataSource.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;com.zaxxer.hikari.HikariDataSource&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hikari</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.hikari&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HikariDataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">HikariDataSource dataSource = createDataSource(properties,</span><br><span class="line">HikariDataSource.class);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(properties.getName())) &#123;</span><br><span class="line">dataSource.setPoolName(properties.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Alibaba-Druid"><a href="#Alibaba-Druid" class="headerlink" title="Alibaba Druid"></a>Alibaba Druid</h2><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>详细的监控（真的是全⾯）</li><li>ExceptionSorter，针对主流数据库的返回码都有⽀持</li><li>SQL 防注⼊</li><li>内置加密配置</li><li>众多扩展点，⽅便进⾏定制</li></ul><h4 id="如何用Druid"><a href="#如何用Druid" class="headerlink" title="如何用Druid"></a>如何用Druid</h4><p>需要排除掉HikariCP的包</p><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210509122207290.png" class="" title="image-20210509122207290"><ol><li>直接配置 <code>DruidDataSource</code></li><li>通过 <code>druid-spring-boot-starter</code>   配置：<code>spring.datasource.druid.*</code></li></ol><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210509121007744.png" class="" title="image-20210509121007744"><h4 id="Druid配置项"><a href="#Druid配置项" class="headerlink" title="Druid配置项"></a>Druid配置项</h4><ul><li>Filter 配置<ul><li>spring.datasource.druid.filters=stat,config,wall,log4j （全部使⽤默认值） </li></ul></li><li>密码加密<ul><li>spring.datasource.password=&lt;加密密码&gt; </li><li>spring.datasource.druid.filter.config.enabled=true</li><li>spring.datasource.druid.connection-properties=config.decrypt=true;config.decrypt.key= </li></ul></li><li>SQL 防注⼊<ul><li>spring.datasource.druid.filter.wall.enabled=true</li><li>spring.datasource.druid.filter.wall.db-type=h2</li><li>spring.datasource.druid.filter.wall.config.delete-allow=false</li><li>spring.datasource.druid.filter.wall.config.drop-table-allow=false</li></ul></li></ul><h4 id="Druid-Filter"><a href="#Druid-Filter" class="headerlink" title="Druid Filter"></a>Druid Filter</h4><ul><li>⽤于定制连接池操作的各种环节</li><li>可以继承 <code>FilterEventAdapter</code> 以便⽅便地实现 <code>Filter</code></li><li>修改 <code>META-INF/druid-filter.properties</code> 增加 <code>Filter</code> 配置</li></ul><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/01/image-20210509121912105.png" class="" title="image-20210509121912105">]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://universeinheart.github.io/tags/SpringBoot/"/>
    
    <category term="JDBC" scheme="http://universeinheart.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>02.JDBC必知必会02</title>
    <link href="http://universeinheart.github.io/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/"/>
    <id>http://universeinheart.github.io/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/</id>
    <published>2021-04-28T15:26:37.000Z</published>
    <updated>2021-05-12T23:31:10.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过-Spring-JDBC-访问数据库"><a href="#通过-Spring-JDBC-访问数据库" class="headerlink" title="通过 Spring JDBC 访问数据库"></a>通过 Spring JDBC 访问数据库</h2><ul><li><code>core</code>，<code>JdbcTemplate</code> 等相关核⼼接⼝和类</li><li><code>datasource</code>，数据源相关的辅助类 </li><li><code>object</code>，将基本的 JDBC 操作封装成对象 </li><li><code>support</code>，错误码等其他辅助⼯具</li></ul><h3 id="简单的-JDBC-操作"><a href="#简单的-JDBC-操作" class="headerlink" title="简单的 JDBC 操作"></a>简单的 JDBC 操作</h3><p>JdbcTemplate </p><ul><li><code>query</code> </li><li><code>queryForObject</code> </li><li><code>queryForList</code> </li><li><code>queryForMap</code></li><li><code>update</code> </li><li><code>execute</code></li></ul><p><code>NamedParameterJdbcTemplate</code>: SQL 按名称而不是按位置进行指定. 具名参数更易于维护, 也提升了可读性. 具名参数由框架类在运行时用占位符取代</p><h3 id="SQL-批处理"><a href="#SQL-批处理" class="headerlink" title="SQL 批处理"></a>SQL 批处理</h3><ul><li>JdbcTemplate<ul><li>batchUpdate<ul><li>BatchPreparedStatementSetter</li></ul></li></ul></li><li>NamedParameterJdbcTemplate <ul><li>batchUpdate<ul><li>SqlParameterSourceUtils.createBatch</li></ul></li></ul></li></ul><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210509131855838.png" class="" title="image-20210509131855838"><h2 id="了解-Spring-的抽象"><a href="#了解-Spring-的抽象" class="headerlink" title="了解 Spring 的抽象"></a>了解 Spring 的抽象</h2><h3 id="Spring-的事务抽象"><a href="#Spring-的事务抽象" class="headerlink" title="Spring 的事务抽象"></a>Spring 的事务抽象</h3><h4 id="事务抽象的核⼼接⼝"><a href="#事务抽象的核⼼接⼝" class="headerlink" title="事务抽象的核⼼接⼝"></a>事务抽象的核⼼接⼝</h4><ul><li>PlatformTransactionManager<ul><li>DataSourceTransactionManager</li><li>HibernateTransactionManager</li><li>JtaTransactionManager </li></ul></li><li>TransactionDefinition <ul><li>Propagation</li><li>Isolation</li><li>Timeout</li><li>Read-only status</li></ul></li></ul><h4 id="事务传播特性"><a href="#事务传播特性" class="headerlink" title="事务传播特性"></a>事务传播特性</h4><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210509133127418.png" class="" title="image-20210509133127418"><h4 id="事务隔离特性"><a href="#事务隔离特性" class="headerlink" title="事务隔离特性"></a>事务隔离特性</h4><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210509133148998.png" class="" title="image-20210509133148998"><h4 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h4><ul><li><strong>TransactionTemplate</strong><ul><li>TransactionCallback</li><li>TransactionCallbackWithoutResult </li></ul></li><li><strong>PlatformTransactionManager</strong>  <ul><li>可以传⼊TransactionDefinition进⾏定义</li></ul></li></ul><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210510132837890.png" class="" title="image-20210510132837890"><h4 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h4><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210510134107786.png" class="" title="image-20210510134107786"><p><code>Spring</code> 的声明式事务本质上是通过 <code>AOP</code> 来增强了类的功能，<code>AOP</code> 本质上就是为类做了⼀个代理，看似在调⽤⾃⼰写的类，实际⽤的是增强后的代理类</p><p><strong>基于注解的配置⽅式</strong></p><ul><li>开启事务注解的⽅式<ul><li><code>@EnableTransactionManagement</code></li><li><code>&lt;tx:annotation-driven/&gt;</code></li></ul></li><li>EnableTransactionManagement注解的配置、<ul><li>proxyTargetClass</li><li>mode</li><li>order </li></ul></li><li><code>@Transactional</code>  <ul><li>transactionManager</li><li>propagation</li><li>isolation</li><li>timeout</li><li>readOnly</li><li>怎么判断回滚</li></ul></li></ul><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210510134404080.png" class="" title="image-20210510134404080"><blockquote><p><code>invokeInsertThenRollback</code> 方法中调用<code>insertThenRollback</code>，外部调用<code>invokeInsertThenRollback</code> 并不存在事务，而是插入成功，没有回滚</p><p>原因是 <code>Spring</code> 是为类做了代理，需要调用代理类才能真正执行到被代理增强的方法，如果是在类内部做的调用，说明没有走到增强的代理方法</p><p>解决方案：</p><ol><li>把自己的实例注入进来，内部方法调用改为直接调用注入的实例。Spring创建了一个代理，我们调用代理就好了<img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210510135823823.png" class="" title="image-20210510135823823"></li><li>在当前类的方法中通过<code>AopContext.currentProxy()</code>获取当前类的代理对象，再调用的代理对象的方法<img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210510135852673.png" class="" title="image-20210510135852673"></li></ol></blockquote><h3 id="JDBC-异常抽象"><a href="#JDBC-异常抽象" class="headerlink" title="JDBC 异常抽象"></a>JDBC 异常抽象</h3><p>Spring 会将数据操作的异常转换为 <code>DataAccessException</code>  ⽆论使⽤何种数据访问⽅式，都能使⽤⼀样的异常</p><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210510223812309.png" class="" title="image-20210510223812309"><h4 id="Spring是怎么认识那些错误码的"><a href="#Spring是怎么认识那些错误码的" class="headerlink" title="Spring是怎么认识那些错误码的"></a>Spring是怎么认识那些错误码的</h4><p><strong>通过 <code>SQLErrorCodeSQLExceptionTranslator</code> 解析错误码</strong> </p><p><code>ErrorCode</code> 定义</p><ul><li>org/springframework/jdbc/support/sql-error-codes.xml</li><li>Classpath 下的 sql-error-codes.xml</li></ul><h4 id="定制错误码解析逻辑"><a href="#定制错误码解析逻辑" class="headerlink" title="定制错误码解析逻辑"></a>定制错误码解析逻辑</h4><img src="/2021/04/28/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/02/image-20210511000852039.png" class="" title="image-20210511000852039">]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="玩转Spring全家桶" scheme="http://universeinheart.github.io/categories/%E7%8E%A9%E8%BD%ACSpring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
    <category term="Spring" scheme="http://universeinheart.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://universeinheart.github.io/tags/SpringBoot/"/>
    
    <category term="JDBC" scheme="http://universeinheart.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>03.Kafka只是消息引擎系统吗？</title>
    <link href="http://universeinheart.github.io/2021/04/24/Kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/03/"/>
    <id>http://universeinheart.github.io/2021/04/24/Kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/03/</id>
    <published>2021-04-24T08:47:37.000Z</published>
    <updated>2021-04-24T09:45:26.069Z</updated>
    
    <content type="html"><![CDATA[<p><code>Apache Kafka</code> 是消息引擎系统，也是一个分布式流处理平台（<code>Distributed Streaming Platform</code>）</p><blockquote><p>Kafka 在设计之初就旨在提供三个方面的特性：</p><ul><li>提供一套 API 实现生产者和消费者；</li><li>降低网络传输和磁盘存储开销；</li><li>实现高伸缩性架构。</li></ul></blockquote><p><strong>流处理</strong>要最终替代它的“兄弟”<strong>批处理</strong>需要具备两点核心优势：<strong>要实现正确性和提供能够推导时间的工具</strong>。</p><p>实现正确性是流处理能够匹敌批处理的基石。正确性一直是批处理的强项，而实现正确性的基石则是要求框架能提供精确一次处理语义，即处理一条消息有且只有一次机会能够影响系统状态。</p><p>目前主流的大数据流处理框架都宣称实现了精确一次处理语义，但这是有限定条件的，即它们只能实现框架内的精确一次处理语义，无法实现端到端的。这是为什么呢？因为当这些框架与外部消息引擎系统结合使用时，它们无法影响到外部系统的处理语义，所以如果你搭建了一套环境使得 <code>Spark</code> 或 <code>Flink</code> 从 <code>Kafka</code> 读取消息之后进行有状态的数据计算，最后再写回 <code>Kafka</code>，那么你只能保证在 <code>Spark</code> 或 <code>Flink</code> 内部，这条消息对于状态的影响只有一次。但是计算结果有可能多次写入到 <code>Kafka</code>，因为它们不能控制 <code>Kafka</code> 的语义处理。相反地，<code>Kafka</code> 则不是这样，因为所有的数据流转和计算都在 <code>Kafka</code> 内部完成，故 <code>Kafka</code> 可以实现端到端的精确一次处理语义。</p>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="Kafka" scheme="http://universeinheart.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="http://universeinheart.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>02.Kafka术语</title>
    <link href="http://universeinheart.github.io/2021/04/24/Kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/02/"/>
    <id>http://universeinheart.github.io/2021/04/24/Kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/02/</id>
    <published>2021-04-24T08:46:37.000Z</published>
    <updated>2021-04-24T09:37:38.383Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Kafka</code> 中，发布订阅的对象是主题（<code>Topic</code>），你可以为每个业务、每个应用甚至是每类数据都创建专属的主题。</p><p>向主题发布消息的客户端应用程序称为生产者（<code>Producer</code>），生产者程序通常持续不断地向一个或多个主题发送消息，而订阅这些主题消息的客户端应用程序就被称为消费者（<code>Consumer</code>）。</p><p>和生产者类似，消费者也能够同时订阅多个主题的消息。我们把生产者和消费者统称为客户端（<code>Clients</code>）。你可以同时运行多个生产者和消费者实例，这些实例会不断地向 <code>Kafka</code> 集群中的多个主题生产和消费消息。</p><p><code>Kafka</code> 的服务器端由被称为 <code>Broker</code> 的服务进程构成，即一个 <code>Kafka</code> 集群由多个 <code>Broker</code> 组成，<code>Broker</code> 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。</p><p>虽然多个 <code>Broker</code> 进程能够运行在同一台机器上，但更常见的做法是将不同的 <code>Broker</code> 分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在它上面运行的所有 <code>Broker</code> 进程都挂掉了，其他机器上的 <code>Broker</code> 也依然能够对外提供服务。这其实就是 <code>Kafka</code> 提供高可用的手段之一。</p><p>实现高可用的另一个手段就是备份机制（<code>Replication</code>）。备份的思想很简单，就是把<strong>相同的数据拷贝到多台机器上</strong>，而这些相同的数据拷贝在 <code>Kafka</code> 中被称为副本（<code>Replica</code>）。副本的数量是可以配置的，这些副本保存着相同的数据，但却有不同的角色和作用。</p><p><code>Kafka</code> 定义了两类副本：<strong>领导者副本</strong>（<code>Leader Replica</code>）和<strong>追随者副本</strong>（<code>Follower Replica</code>）。前者对外提供服务，这里的对外指的是与客户端程序进行交互；而后者只是被动地追随领导者副本而已，不能与外界进行交互。当然了，你可能知道在很多其他系统中追随者副本是可以对外提供服务的，比如 <code>MySQL</code> 的从库是可以处理读操作的，但是在 <code>Kafka</code> 中<strong>追随者副本不会对外提供服务</strong>。 </p><p>副本的工作机制也很简单：生产者总是向领导者副本写消息；而消费者总是从领导者副本读消息。至于追随者副本，它只做一件事：向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步。</p><p>伸缩性即所谓的 <code>Scalability</code>，是分布式系统中非常重要且必须要谨慎对待的问题。什么是伸缩性呢？我们拿副本来说，虽然现在有了领导者副本和追随者副本，但倘若领导者副本积累了太多的数据以至于单台 <code>Broker</code> 机器都无法容纳了，此时应该怎么办呢？一个很自然的想法就是，能否把数据分割成多份保存在不同的 <code>Broker</code> 上？</p><p>如果你就是这么想的，那么恭喜你，<code>Kafka</code> 就是这么设计的。这种机制就是所谓的分区（<code>Partitioning</code>）。<code>Kafka</code> 中的分区机制指的是将<strong>每个主题划分成多个分区</strong>（<code>Partition</code>），<strong>每个分区是一组有序的消息日志</strong>。生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。</p><p>刚才提到的副本如何与这里的分区联系在一起呢？实际上，副本是在分区这个层级定义的。每个分区下可以配置若干个副本，其中只能有 1 个领导者副本和 N-1 个追随者副本。生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移（<code>Offset</code>）的数据来表征。分区位移总是从 0 开始，假设一个生产者向一个空分区写入了 10 条消息，那么这 10 条消息的位移依次是 0、1、2、……、9。</p><blockquote><p>完整地串联起 Kafka 的三层消息架构：</p><ul><li>第一层是<strong>主题层</strong>，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本。</li><li>第二层是<strong>分区层</strong>，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 N-1 个副本是追随者副本，只是提供数据冗余之用。</li><li>第三层是<strong>消息层</strong>，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。</li><li>最后，客户端程序只能与分区的领导者副本进行交互。</li></ul></blockquote><p><code>Kafka Broker</code> 是如何持久化数据的。总的来说，<code>Kafka</code> 使用<strong>消息日志</strong>（<code>Log</code>）来保存数据，一个日志就是磁盘上一个只能追加写（<code>Append-only</code>）消息的物理文件。因为只能追加写入，故避免了缓慢的随机 I/O 操作，改为性能较好的顺序 I/O 写操作，这也是实现 <code>Kafka</code> 高吞吐量特性的一个重要手段。</p><p>不过如果你不停地向一个日志写入消息，最终也会耗尽所有的磁盘空间，因此 <code>Kafka</code> 必然要定期地删除消息以回收磁盘。怎么删除呢？简单来说就是通过日志段（<code>Log Segment</code>）机制。在 <code>Kafka</code> 底层，一个日志又进一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，<code>Kafka</code> 会自动切分出一个新的日志段，并将老的日志段封存起来。<code>Kafka</code> 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</p><p>在 Kafka 中实现这种点对点模型（<code>Peer to Peer，P2P</code>）的方法就是引入了<strong>消费者组</strong>（<code>Consumer Group</code>）。所谓的消费者组，指的是<strong>多个消费者实例共同组成一个组来消费一组主题</strong>。这组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它。</p><p>为什么要引入消费者组呢？主要是为了<strong>提升消费者端的吞吐量</strong>。多个消费者实例同时消费，加速整个消费端的吞吐量（TPS）。消费者实例可以是运行消费者应用的进程，也可以是一个线程，它们都称为一个消费者实例（Consumer Instance）。</p><p>消费者组里面的所有消费者实例不仅“瓜分”订阅主题的数据，而且更酷的是它们还能彼此协助。假设组内某个实例挂掉了，<code>Kafka</code> 能够自动检测到，然后把这个 <code>Failed</code> 实例之前负责的分区转移给其他活着的消费者。这个过程就是 <code>Kafka</code> 中大名鼎鼎的“重平衡”（<code>Rebalance</code>）。嗯，其实既是大名鼎鼎，也是臭名昭著，因为由重平衡引发的消费者问题比比皆是。事实上，目前很多重平衡的 Bug 社区都无力解决。</p><p>每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上，这个字段就是<strong>消费者位移</strong>（<strong>Consumer Offset</strong>）。注意，这和上面所说的位移完全不是一个概念。上面的“位移”表征的是分区内的消息位置，它是不变的，即一旦消息被成功写入到一个分区上，它的位移值就是固定的了。而消费者位移则不同，它可能是随时变化的，毕竟它是消费者消费进度的指示器嘛。另外每个消费者有着自己的消费者位移，因此一定要区分这两类位移的区别。我个人把消息在分区中的位移称为分区位移，而把消费者端的位移称为消费者位移。</p><p>总结一下今天提到的所有名词术语：</p><ul><li><strong>消息</strong>：<code>Record</code>。<code>Kafka</code> 是消息引擎嘛，这里的消息就是指 <code>Kafka</code> 处理的主要对象。</li><li><strong>主题</strong>：<code>Topic</code>。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。</li><li><strong>分区</strong>：<code>Partition</code>。一个有序不变的消息序列。每个主题下可以有多个分区。</li><li><strong>消息位移</strong>：<code>Offset</code>。表示分区中每条消息的位置信息，是一个单调递增且不变的值。</li><li><strong>副本</strong>：<code>Replica</code>。<code>Kafka</code> 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。</li><li><strong>生产者</strong>：<code>Producer</code>。向主题发布新消息的应用程序。</li><li><strong>消费者</strong>：<code>Consumer</code>。从主题订阅新消息的应用程序。</li><li><strong>消费者位移</strong>：<code>Consumer Offset</code>。表征消费者消费进度，每个消费者都有自己的消费者位移。</li><li><strong>消费者组</strong>：<code>Consumer Group</code>。多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。</li><li><strong>重平衡</strong>：<code>Rebalance</code>。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。<code>Rebalance</code> 是 <code>Kafka</code> 消费者端实现高可用的重要手段。</li></ul><img src="/2021/04/24/Kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/02/image-20210424173638327.png" class="" title="image-20210424173638327">]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="Kafka" scheme="http://universeinheart.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="http://universeinheart.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>曾国藩修身十二法</title>
    <link href="http://universeinheart.github.io/2021/04/24/%E5%B0%8F%E5%86%8C%E5%AD%90/%E6%9B%BE%E5%9B%BD%E8%97%A9%E4%BF%AE%E8%BA%AB%E5%8D%81%E4%BA%8C%E6%B3%95/"/>
    <id>http://universeinheart.github.io/2021/04/24/%E5%B0%8F%E5%86%8C%E5%AD%90/%E6%9B%BE%E5%9B%BD%E8%97%A9%E4%BF%AE%E8%BA%AB%E5%8D%81%E4%BA%8C%E6%B3%95/</id>
    <published>2021-04-24T07:07:37.000Z</published>
    <updated>2021-04-24T15:47:19.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一法、主敬"><a href="#第一法、主敬" class="headerlink" title="第一法、主敬"></a>第一法、主敬</h2><p><strong>整齐严肃，无时不惧。无事时心在腔子里，应事时专一不杂。清明在躬，如日之升。</strong></p><blockquote><p>每天保证衣冠外貌整齐，心思神情端正严肃，时时刻刻都要警惕、检查自己的念头、举止中有无背离义理之处。</p><p>平日里，闲居无事的时候宁静安泰，投入事务中则专心致志，不存杂念。</p><p>永远让自己的精神状态保持清澈，就如同旭日东升般光彩照人。</p></blockquote><h2 id="第二法、静坐"><a href="#第二法、静坐" class="headerlink" title="第二法、静坐"></a>第二法、静坐</h2><p><strong>每日不拘何时，静坐四刻，体念来复之仁心，正位凝命，如鼎之镇。</strong></p><blockquote><p>每天，一定要抽出一段时间静坐，以修身养性，并反省体悟自己天性中隐现的仁义之心。</p><p>正襟危坐，凝然镇定，如同宝鼎一般沉稳。</p></blockquote><h2 id="第三法、早起"><a href="#第三法、早起" class="headerlink" title="第三法、早起"></a>第三法、早起</h2><p><strong>黎明即起，醒后勿粘恋</strong></p><h2 id="第四法、读书不二"><a href="#第四法、读书不二" class="headerlink" title="第四法、读书不二"></a>第四法、读书不二</h2><p><strong>一书未点完，不看他书。东翻西阅，徒务外为人，每日以十页为率</strong></p><blockquote><p>一本书没有读完时，不要再看其他书籍。</p><p>东翻西阅随意读书，对自己的道德学问毫无益处。</p></blockquote><h2 id="第五法、读史"><a href="#第五法、读史" class="headerlink" title="第五法、读史"></a>第五法、读史</h2><p><strong>丙申年购《二十三史》，大人曰：“尔借钱买书，吾不惮极力为尔弥缝，尔能圈点一遍，则不负我矣。”嗣后每日圈点十页，间断不孝。</strong></p><h2 id="第六法、谨言"><a href="#第六法、谨言" class="headerlink" title="第六法、谨言"></a>第六法、谨言</h2><p><strong>刻刻留心，第一功夫</strong></p><h2 id="第七法、养气"><a href="#第七法、养气" class="headerlink" title="第七法、养气"></a>第七法、养气</h2><p><strong>气藏丹田，无不可对人言之事</strong></p><h2 id="第八法、保身"><a href="#第八法、保身" class="headerlink" title="第八法、保身"></a>第八法、保身</h2><p><strong>十二月奉大人手谕：“节劳，节欲，节饮食。”时时当作养病。</strong></p><h2 id="第九法、日知所亡"><a href="#第九法、日知所亡" class="headerlink" title="第九法、日知所亡"></a>第九法、日知所亡</h2><p><strong>每日读书记录心得语，有求深意是徇人</strong></p><blockquote><p>每天读书，都要将心得体会记录下来，不要刻意地从书中谋求深意，否则，就是曲从于他人。</p></blockquote><h2 id="第十法、月无亡所能"><a href="#第十法、月无亡所能" class="headerlink" title="第十法、月无亡所能"></a>第十法、月无亡所能</h2><p><strong>每月做诗文数首，以验积理之多寡，养气之盛否。不可一味耽著，最易溺心丧志。</strong></p><h2 id="第十一法、作字"><a href="#第十一法、作字" class="headerlink" title="第十一法、作字"></a>第十一法、作字</h2><p><strong>早饭后做字半时。凡笔墨应酬，当作自己课程。凡事不待明日，愈积愈难清。</strong></p><h2 id="第十二法、夜不出门"><a href="#第十二法、夜不出门" class="headerlink" title="第十二法、夜不出门"></a>第十二法、夜不出门</h2><p><strong>旷功疲神，切戒切戒！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一法、主敬&quot;&gt;&lt;a href=&quot;#第一法、主敬&quot; class=&quot;headerlink&quot; title=&quot;第一法、主敬&quot;&gt;&lt;/a&gt;第一法、主敬&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;整齐严肃，无时不惧。无事时心在腔子里，应事时专一不杂。清明在躬，如日之升。&lt;/strong&gt;</summary>
      
    
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>01.消息引擎系统ABC</title>
    <link href="http://universeinheart.github.io/2021/04/24/Kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/01/"/>
    <id>http://universeinheart.github.io/2021/04/24/Kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/01/</id>
    <published>2021-04-24T06:46:37.000Z</published>
    <updated>2021-04-24T09:53:00.293Z</updated>
    
    <content type="html"><![CDATA[<p><code>Apache Kafka</code> 是一款开源的消息引擎系统</p><blockquote><p>消息引擎是用于在不同系统之间传输消息的，那么如何设计待传输消息的格式？</p><p>一个比较容易想到的是使用已有的一些成熟解决方案，比如使用 CSV、XML 亦或是 JSON；又或者你可能熟知国外大厂开源的一些序列化框架，比如 <code>Google</code> 的 <code>Protocol Buffer</code> 或 <code>Facebook</code> 的 <code>Thrift</code>。这些都是很酷的办法。那么现在我告诉你 Kafka 的选择：它使用的是<strong>纯二进制的字节序列</strong>。当然消息还是结构化的，只是在使用之前都要将其转换成二进制的字节序列。</p></blockquote><p>消息引擎系统还要设定具体的传输协议，即用什么方法把消息传输出去。</p><p>常见的有两种方法：</p><ul><li><strong>点对点模型</strong>：也叫消息队列模型。日常生活的例子比如电话客服就属于这种模型：同一个客户呼入电话只能被一位客服人员处理，第二个客服人员不能为该客户服务。</li><li><strong>发布 / 订阅模型</strong>：与上面不同的是，它有一个主题（<code>Topic</code>）的概念，你可以理解成逻辑语义相近的消息容器。该模型也有发送方和接收方，只不过提法不同。发送方也称为发布者（<code>Publisher</code>），接收方称为订阅者（<code>Subscriber</code>）。和点对点模型不同的是，这个模型可能存在多个发布者向相同的主题发送消息，而订阅者也可能存在多个，它们都能接收到相同主题的消息。生活中的报纸订阅就是一种典型的发布 / 订阅模型。</li></ul><blockquote><p><strong>削峰填谷</strong></p><p>缓冲上下游瞬时突发流量，使其更平滑。特别是对于那种发送能力很强的上游系统，如果没有消息引擎的保护，“脆弱”的下游系统可能会直接被压垮导致全链路服务“雪崩”。但是，一旦有了消息引擎，它能够有效地对抗上游的流量冲击，真正做到将上游的“峰”填满到“谷”中，避免了流量的震荡。</p><p><strong>松耦合</strong></p><p>消息引擎系统的另一大好处在于发送方和接收方的松耦合，这也在一定程度上简化了应用的开发，减少了系统间不必要的交互。</p></blockquote>]]></content>
    
    
    <summary type="html">--</summary>
    
    
    
    <category term="Kafka" scheme="http://universeinheart.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="http://universeinheart.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>01、Netty 解决 TCP 问题</title>
    <link href="http://universeinheart.github.io/2021/04/19/Netty/02/"/>
    <id>http://universeinheart.github.io/2021/04/19/Netty/02/</id>
    <published>2021-04-19T15:26:37.000Z</published>
    <updated>2021-04-19T05:39:06.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是粘包和半包？"><a href="#什么是粘包和半包？" class="headerlink" title="什么是粘包和半包？"></a>什么是粘包和半包？</h3><img src="/2021/04/19/Netty/02/image-20210419130603050.png" class="" title="image-20210419130603050"><ul><li>ABCDEF 粘包</li><li>AB CD EF 半包</li></ul><h3 id="为什么-TCP-应用中会出现粘包和半包现象？"><a href="#为什么-TCP-应用中会出现粘包和半包现象？" class="headerlink" title="为什么 TCP 应用中会出现粘包和半包现象？"></a>为什么 TCP 应用中会出现粘包和半包现象？</h3><blockquote><p>粘包的主要原因：</p><ul><li><p>发送方每次写入数据 &lt; 套接字缓冲区大小</p></li><li><p>接收方读取套接字缓冲区数据不够及时</p></li></ul></blockquote><blockquote><p>半包的主要原因： </p><ul><li>发送方写入数据 &gt; 套接字缓冲区大小 </li><li>发送的数据大于协议的 <code>MTU</code>（<strong>Maximum Transmission Unit，最大传输单元</strong>），必须拆包</li></ul></blockquote><p>根本原因是 <strong>TCP 是流式协议，消息无边界</strong></p><p>UDP 像邮寄的包裹，虽然一次运输多个，但每个包裹都有“界限”，所以无粘包、半包问题</p><h3 id="解决粘包和半包问题的几种常用方法"><a href="#解决粘包和半包问题的几种常用方法" class="headerlink" title="解决粘包和半包问题的几种常用方法"></a>解决粘包和半包问题的几种常用方法</h3><img src="/2021/04/19/Netty/02/image-20210419133643894.png" class="" title="image-20210419133643894"><h3 id="Netty-对三种常用封帧方式的支持"><a href="#Netty-对三种常用封帧方式的支持" class="headerlink" title="Netty 对三种常用封帧方式的支持"></a>Netty 对三种常用封帧方式的支持</h3><img src="/2021/04/19/Netty/02/image-20210419133803626.png" class="" title="image-20210419133803626"><h3 id="解读-Netty-处理粘包、半包的源码"><a href="#解读-Netty-处理粘包、半包的源码" class="headerlink" title="解读 Netty 处理粘包、半包的源码"></a>解读 Netty 处理粘包、半包的源码</h3>]]></content>
    
    
    <summary type="html">TCP粘包半包问题，Netty全搞定</summary>
    
    
    
    <category term="Netty" scheme="http://universeinheart.github.io/categories/Netty/"/>
    
    
    <category term="网络" scheme="http://universeinheart.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Netty" scheme="http://universeinheart.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>21世纪资本论</title>
    <link href="http://universeinheart.github.io/2021/04/18/%E5%B0%8F%E5%86%8C%E5%AD%90/21%E4%B8%96%E7%BA%AA%E8%B5%84%E6%9C%AC%E8%AE%BA/"/>
    <id>http://universeinheart.github.io/2021/04/18/%E5%B0%8F%E5%86%8C%E5%AD%90/21%E4%B8%96%E7%BA%AA%E8%B5%84%E6%9C%AC%E8%AE%BA/</id>
    <published>2021-04-18T15:18:37.000Z</published>
    <updated>2021-04-18T15:47:20.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>李嘉图：稀缺性原则</strong></p><p><strong>马克思：无限积累原则</strong></p><ol><li> 私人资本的积累和分配过程本身就具有使财富集中且往往过度集中的强大推动力</li><li>从长期来看，资本收益率（特别是顶级资本的收益率）明显超过经济增长率。两者之差导致初始资本之间的差距一直延续下去（资本持有者只需将资本收入的一小部分用于保持自己的生活水平，而将大部分用于再投资），并且可能造成资本的高度集中</li><li> 中国原则上可以凭借强有力的中央统一领导体制和高层领导者的反腐和促进公益的决心贯彻累进税制，免于游说集团的压力和竞选政治献金带来的束缚。</li><li>财富分配包含两个维度，一是“要素”分配，这里劳动力和资本被当作是“生产要素”，他们被抽象成两个均匀的实体；二是“个体”分配，这会考虑到个体层面上的劳动收入和资本收入的不平等。现实中这两个维度都非常重要。如果不同时分析这两个维度，是不可能完全理解分配问题的。</li><li>所有产出必须以某种收入的形式分配到劳动或资本上—或者是工资、薪水、酬金、奖金等（作为对工人和在生产过程中贡献了劳动力的人的报酬），或者是其他如利润、红利、利息、租金、版税等（作为对生产过程中使用的资本的所有者的报酬）</li><li>资本指的是能够划分所有权、可在市场中交换的非人力资产的总和，不仅包括所有形式的不动产（含居民住宅），还包括公司和政府机构所使用的金融资本和专业资本（厂房、基础设施、机器、专利等）。</li><li>资本从来不是一成不变的，至少在初期总是伴随着风险与企业家精神，但也总是在积累到足够大的数额后向租金的形式转化，那是它的使命，也是它的逻辑终点</li><li>拥有财富的好处在于，人们即使不工作也能继续消费和积累，或者说能够以比自己从事生产更快的速度来继续消费和积累。同样的逻辑也适用于殖民主义时代的国际舞台</li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;李嘉图：稀缺性原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;马克思：无限积累原则&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 私人</summary>
      
    
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>14.HTTP协议</title>
    <link href="http://universeinheart.github.io/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/14/"/>
    <id>http://universeinheart.github.io/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/14/</id>
    <published>2021-04-18T01:44:37.000Z</published>
    <updated>2021-04-24T15:46:03.598Z</updated>
    
    <content type="html"><![CDATA[<p><code>HTTP</code> 称为协议，<a href="http://www.163.com/">www.163.com</a>  是一个域名，表示互联网上的一个位置。有的 URL 会有更详细的位置标识，例如 <a href="http://www.163.com/index.html">http://www.163.com/index.html</a>  。正是因为这个东西是统一的，所以当你把这样一个字符串输入到浏览器的框里的时候，浏览器才知道如何进行统一处理。</p><h3 id="HTTP-请求的准备"><a href="#HTTP-请求的准备" class="headerlink" title="HTTP 请求的准备"></a>HTTP 请求的准备</h3><p>浏览器会将 <a href="http://www.163.com/">www.163.com</a> 这个域名发送给 <code>DNS</code> 服务器，让它解析为 <code>IP</code> 地址。</p><p><code>HTTP</code> 是基于 <code>TCP</code> 协议的，要先建立 <code>TCP</code> 连接。目前使用的 <code>HTTP</code> 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 <code>Keep-Alive</code> 的，这样建立的 <code>TCP</code> 连接，就可以在多次请求中复用。</p><p><code>TCP</code> 的三次握手和四次挥手，还是挺费劲的。如果好不容易建立了连接，然后就做了一点儿事情就结束了，有点儿浪费人力和物力。</p><h3 id="HTTP-请求的构建"><a href="#HTTP-请求的构建" class="headerlink" title="HTTP 请求的构建"></a>HTTP 请求的构建</h3><p>建立了连接以后，浏览器就要发送 <code>HTTP</code> 的请求</p><img src="/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/14/image-20210424224747049.png" class="" title="image-20210424224747049"><p>HTTP 的报文大概分为三大部分。第一部分是<strong>请求行</strong>，第二部分是<strong>请求的首部</strong>，第三部分才是请求的<strong>正文实体</strong></p><h4 id="第一部分：请求行"><a href="#第一部分：请求行" class="headerlink" title="第一部分：请求行"></a>第一部分：请求行</h4><p>在请求行中，URL 就是 <a href="http://www.163.com/">http://www.163.com</a> ，版本为 HTTP 1.1。</p><p>方法有几种类型。</p><p>对于访问网页来讲，最常用的类型就是 <strong>GET</strong>。顾名思义，GET 就是去服务器获取一些资源。对于访问网页来讲，要获取的资源往往是一个页面。其实也有很多其他的格式，比如说返回一个 JSON 字符串，到底要返回什么，是由服务器端的实现决定的。例如，在云计算中，如果我们的服务器端要提供一个基于 <code>HTTP</code> 协议的 API，获取所有云主机的列表，这就会使用 GET 方法得到，返回的可能是一个 JSON 字符串。字符串里面是一个列表，列表里面是一项的云主机的信息。</p><p>另外一种类型叫做 <strong>POST</strong>。它需要主动告诉服务端一些信息，而非获取。要告诉服务端什么呢？一般会放在正文里面。正文可以有各种各样的格式。常见的格式也是 JSON。例如，我们下一节要讲的支付场景，客户端就需要把“我是谁？我要支付多少？我要买啥？”告诉服务器，这就需要通过 POST 方法。再如，在云计算里，如果我们的服务器端，要提供一个基于 HTTP 协议的创建云主机的 API，也会用到 POST 方法。这个时候往往需要将“我要创建多大的云主机？多少 CPU 多少内存？多大硬盘？”这些信息放在 JSON 字符串里面，通过 POST 的方法告诉服务器端。</p><p>还有一种类型叫 <strong>PUT</strong>，就是向指定资源位置上传最新内容。但是，HTTP 的服务器往往是不允许上传文件的，所以 PUT 和 POST 就都变成了要传给服务器东西的方法。在实际使用过程中，这两者还会有稍许的区别。POST 往往是用来创建一个资源的，而 PUT 往往是用来修改一个资源的。例如，云主机已经创建好了，我想对这个云主机打一个标签，说明这个云主机是生产环境的，另外一个云主机是测试环境的。那怎么修改这个标签呢？往往就是用 PUT 方法。</p><p>再有一种常见的就是 <strong>DELETE</strong>。这个顾名思义就是用来删除资源的。例如，我们要删除一个云主机，就会调用 DELETE 方法。</p><h4 id="第二部分：首部字段"><a href="#第二部分：首部字段" class="headerlink" title="第二部分：首部字段"></a>第二部分：首部字段</h4><p>首部是 key:value，通过冒号分隔。这里面，往往保存了一些非常重要的字段。</p><p>例如，<code>Accept-Charset</code>，表示客户端可以接受的字符集。防止传过来的是另外的字符集，从而导致出现乱码。</p><p>再如，<code>Content-Type</code> 是指正文的格式。例如，我们进行 POST 的请求，如果正文是 JSON，那么我们就应该将这个值设置为 JSON。</p><p>在 <code>HTTP</code> 头里面，<code>Cache-control</code> 是用来控制缓存的。当客户端发送的请求中包含 <code>max-age</code> 指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源；当指定 <code>max-age</code> 值为 0，那么缓存层通常需要将请求转发给应用集群。另外，<code>If-Modified-Since</code> 也是一个关于缓存的。也就是说，如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源；如果没有更新，服务端会返回“<code>304 Not Modified</code>”的响应，那客户端就不用下载了，也会节省带宽。</p><p>对于这种高并发场景下的系统，在真正的业务逻辑之前，都需要有个接入层，将这些静态资源的请求拦在最外面。这个架构的图就像这样。</p><img src="/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/14/image-20210424225500290.png" class="" title="image-20210424225500290"><p><code>Nginx</code>对于静态资源，有 <code>Vanish</code> 缓存层。当缓存过期的时候，才会访问真正的 <code>Tomcat</code> 应用集群</p><h3 id="HTTP-请求的发送"><a href="#HTTP-请求的发送" class="headerlink" title="HTTP 请求的发送"></a>HTTP 请求的发送</h3><p><code>HTTP</code> 协议是基于 <code>TCP</code> 协议的，所以它使用<strong>面向连接</strong>的方式发送请求，通过 <code>stream</code> 二进制流的方式传给对方。当然，到了 <code>TCP</code> 层，它会把二进制流变成一个个报文段发送给服务器。</p><p>在发送给每个报文段的时候，都需要对方有一个回应 <code>ACK</code>，来保证报文可靠地到达了对方。如果没有回应，那么 <code>TCP</code> 这一层会进行重新传输，直到可以到达。同一个包有可能被传了好多次，但是 <code>HTTP</code> 这一层不需要知道这一点，因为是 <code>TCP</code> 这一层在埋头苦干。</p><p><code>TCP</code> 层发送每一个报文的时候，都需要加上自己的地址（即<strong>源地址</strong>）和它想要去的地方（即<strong>目标地址</strong>），将这两个信息放到 IP 头里面，交给 IP 层进行传输。</p><p>IP 层需要查看目标地址和自己是否是在同一个局域网。如果是，就发送 <code>ARP</code> 协议来请求这个目标地址对应的 MAC 地址，然后将源 MAC 和目标 MAC 放入 MAC 头，发送出去即可；如果不在同一个局域网，就需要发送到网关，还要需要发送 <code>ARP</code> 协议，来获取网关的 MAC 地址，然后将源 MAC 和网关 MAC 放入 MAC 头，发送出去。</p><p>网关收到包发现 MAC 符合，取出目标 IP 地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址，将包发给下一跳路由器。</p><p>这样路由器一跳一跳终于到达目标的局域网。这个时候，最后一跳的路由器能够发现，目标地址就在自己的某一个出口的局域网上。于是，在这个局域网上发送 ARP，获得这个目标地址的 MAC 地址，将包发出去。</p><p>目标的机器发现 MAC 地址符合，就将包收起来；发现 IP 地址符合，根据 IP 头中协议项，知道自己上一层是 TCP 协议，于是解析 TCP 的头，里面有序列号，需要看一看这个序列包是不是我要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。</p><p>TCP 头里面还有端口号，HTTP 的服务器正在监听这个端口号。于是，目标机器自然知道是 HTTP 服务器这个进程想要这个包，于是将包发给 HTTP 服务器。HTTP 服务器的进程看到，原来这个请求是要访问一个网页，于是就把这个网页发给客户端。</p><h3 id="HTTP-返回的构建"><a href="#HTTP-返回的构建" class="headerlink" title="HTTP 返回的构建"></a>HTTP 返回的构建</h3><p>HTTP 的返回报文也是有一定格式的。这也是基于 HTTP 1.1 的。</p><img src="/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/14/image-20210424225950187.png" class="" title="image-20210424225950187"><p><strong>状态码</strong>会反映 HTTP 请求的结果。</p><p>“<code>200</code>”意味着大吉大利；而我们最不想见的，就是“<code>404</code>”，也就是“服务端无法响应这个请求”</p><p><code>Retry-After</code> 表示，告诉客户端应该在多长时间以后再次尝试一下。</p><p><code>Content-Type</code>，表示返回的是 HTML，还是 JSON。</p><p>构造好了返回的 HTTP 报文，接下来就是把这个报文发送出去。还是交给 Socket 去发送，还是交给 TCP 层，让 TCP 层将返回的 HTML，也分成一个个小的段，并且保证每个段都可靠到达。</p><p>这些段加上 TCP 头后会交给 IP 层，然后把刚才的发送过程反向走一遍。虽然两次不一定走相同的路径，但是逻辑过程是一样的，一直到达客户端。</p><p>客户端发现 MAC 地址符合、IP 地址符合，于是就会交给 TCP 层。根据序列号看是不是自己要的报文段，如果是，则会根据 TCP 头中的端口号，发给相应的进程。这个进程就是浏览器，浏览器作为客户端也在监听某个端口。</p><p>当浏览器拿到了 HTTP 的报文。发现返回“200”，一切正常，于是就从正文中将 HTML 拿出来。HTML 是一个标准的网页格式。浏览器只要根据这个格式，展示出一个绚丽多彩的网页。</p><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><p>HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。</p><p>为了解决这些问题，HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引。</p><p>另外，HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。</p><p>HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有 <strong>Header 帧</strong>，用于传输 Header 内容，并且会开启一个新的流。再就是 <strong>Data 帧</strong>，用来传输正文实体。多个 Data 帧属于同一个流。</p><p>通过这两种机制，HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。</p><p>假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片 jpg。如果使用 HTTP 1.1 就是串行的，但是如果使用 HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。</p><img src="/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/14/image-20210424232559308.png" class="" title="image-20210424232559308"><p>HTTP 2.0 其实是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP 连接中。</p><img src="/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/14/image-20210424232624831.png" class="" title="image-20210424232624831"><p>HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题，同时，也不需要通过 HTTP 1.x 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应；减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度。</p><h3 id="QUIC-协议的“城会玩”"><a href="#QUIC-协议的“城会玩”" class="headerlink" title="QUIC 协议的“城会玩”"></a>QUIC 协议的“城会玩”</h3><h3 id="机制一：自定义连接机制"><a href="#机制一：自定义连接机制" class="headerlink" title="机制一：自定义连接机制"></a>机制一：自定义连接机制</h3><h3 id="机制二：自定义重传机制"><a href="#机制二：自定义重传机制" class="headerlink" title="机制二：自定义重传机制"></a>机制二：自定义重传机制</h3><h3 id="机制三：无阻塞的多路复用"><a href="#机制三：无阻塞的多路复用" class="headerlink" title="机制三：无阻塞的多路复用"></a>机制三：无阻塞的多路复用</h3><h3 id="机制四：自定义流量控制"><a href="#机制四：自定义流量控制" class="headerlink" title="机制四：自定义流量控制"></a>机制四：自定义流量控制</h3>]]></content>
    
    
    <summary type="html">看个新闻原来这么麻烦</summary>
    
    
    
    <category term="网络" scheme="http://universeinheart.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://universeinheart.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>11.TCP协议（上）</title>
    <link href="http://universeinheart.github.io/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/11/"/>
    <id>http://universeinheart.github.io/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/11/</id>
    <published>2021-04-18T01:43:37.000Z</published>
    <updated>2021-04-24T09:53:51.655Z</updated>
    
    <content type="html"><![CDATA[<p><code>TCP</code> 天然认为网络环境是恶劣的，丢包、乱序、重传，拥塞都是常有的事情，一言不合就可能送达不了，因而要从算法层面来保证可靠性。</p><h3 id="TCP-包头格式"><a href="#TCP-包头格式" class="headerlink" title="TCP 包头格式"></a>TCP 包头格式</h3><img src="/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/11/image-20210418101919820.png" class="" title="image-20210418101919820"><p>首先，<strong>源端口号</strong>和<strong>目标端口号</strong>是不可少的，这一点和 <code>UDP</code> 是一样的。如果没有这两个端口号。数据就不知道应该发给哪个应用。</p><p>接下来是<strong>包的序号</strong>。为什么要给包编号呢？当然是为了<strong>解决乱序</strong>的问题。不编好号怎么确认哪个应该先来，哪个应该后到呢。编号是为了解决乱序问题。</p><p>还应该有的就是<strong>确认序号</strong>。发出去的包应该有确认，要不然我怎么知道对方有没有收到呢？如果没有收到就应该重新发送，直到送达。这个可以解决丢包的问题。作为老司机，做事当然要靠谱，答应了就要做到，暂时做不到也要有个回复。</p><p><code>TCP</code>  是靠谱的协议，但是这不能说明它面临的网络环境好。从 IP 层面来讲，如果网络状况的确那么差，是没有任何可靠性保证的，而作为 <code>IP</code> 的上一层  <code>TCP</code> 也无能为力，唯一能做的就是更加努力，不断重传，通过各种算法保证。也就是说，对于 <code>TCP</code> 来讲，<code>IP</code>  层你丢不丢包，我管不着，但是我在我的层面上，会努力保证可靠性。</p><p><code>TCP</code> 是面向连接的，因而双方要维护连接的状态，这些带<strong>状态位</strong>的包的发送，会引起双方的状态变更。状态位 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。</p><p><code>TCP</code> 要做<strong>流量控制</strong>，通信双方各声明一个窗口，标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p><p><code>TCP</code> 还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</p><h3 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h3><p>首先，为什么要三次，而不是两次？按说两个人打招呼，一来一回就可以了啊？为了可靠，为什么不是四次？</p><p>我们还是假设这个通路是非常不可靠的，A 要发起一个连接，当发了第一个请求杳无音信的时候，会有很多的可能性，比如第一个请求包丢了，再如没有丢，但是绕了弯路，超时了，还有 B 没有响应，不想和我连接。</p><p>A 不能确认结果，于是再发，再发。终于，有一个请求包到了 B，但是请求包到了 B 的这个事情，目前 A 还是不知道的，A 还有可能再发。</p><p>B 收到了请求包，就知道了 A 的存在，并且知道 A 要和它建立连接。如果 B 不乐意建立连接，则 A 会重试一阵后放弃，连接建立失败，没有问题；如果 B 是乐意建立连接的，则会发送应答包给 A。当然对于 B 来说，这个应答包也是一入网络深似海，不知道能不能到达 A。这个时候 B 自然不能认为连接是建立好了，因为应答包仍然会丢，会绕弯路，或者 A 已经挂了都有可能。</p><p>而且这个时候 B 还能碰到一个诡异的现象就是，A 和 B 原来建立了连接，做了简单通信后，结束了连接。还记得吗？A 建立连接的时候，请求包重复发了几次，有的请求包绕了一大圈又回来了，B  会认为这也是一个正常的的请求的话，因此建立了连接，可以想象，这个连接不会进行下去，也没有个终结的时候，纯属单相思了。因而两次握手肯定不行。</p><p>B 发送的应答可能会发送多次，但是只要一次到达 A，A 就认为连接已经建立了，因为对于 A 来讲，他的消息有去有回。A 会给 B 发送应答之应答，而 B 也在等这个消息，才能确认连接的建立，只有等到了这个消息，对于 B 来讲，才算它的消息有去有回。</p><p>当然 A 发给 B 的应答之应答也会丢，也会绕路，甚至 B 挂了。按理来说，还应该有个应答之应答之应答，这样下去就没底了。所以四次握手是可以的，四十次都可以，关键四百次也不能保证就真的可靠了。只要双方的消息都有去有回，就基本可以了。</p><p>好在大部分情况下，A 和 B 建立了连接之后，A 会马上发送数据的，一旦 A 发送数据，则很多问题都得到了解决。例如 A 发给 B 的应答丢了，当 A 后续发送的数据到达的时候，B  可以认为这个连接已经建立，或者 B 压根就挂了，A 发送的数据，会报错，说 B 不可达，A 就知道 B 出事情了。</p><p>当然你可以说 A 比较坏，就是不发数据，建立连接后空着。我们在程序设计的时候，可以要求开启 keepalive 机制，即使没有真实的数据包，也有探活包。</p><p>另外，你作为服务端 B 的程序设计者，对于 A 这种长时间不发包的客户端，可以主动关闭，从而空出资源来给其他客户端使用。</p><p>三次握手除了双方建立连接外，主要还是为了沟通一件事情，就是 <strong>TCP 包的序号的问题</strong>。</p><p>A 要告诉 B，我这面发起的包的序号起始是从哪个号开始的，B 同样也要告诉 A，B 发起的包的序号起始是从哪个号开始的。为什么序号不能都从 1 开始呢？因为这样往往会出现冲突。</p><p>例如，A 连上 B 之后，发送了 1、2、3  三个包，但是发送 3 的时候，中间丢了，或者绕路了，于是重新发送，后来 A 掉线了，重新连上 B 后，序号又从 1 开始，然后发送  2，但是压根没想发送 3，但是上次绕路的那个 3 又回来了，发给了 B，B 自然认为，这就是下一个包，于是发生了错误。</p><p>因而，每个连接都要有不同的序号。这个序号的起始序号是随着时间变化的，可以看成一个 32 位的计数器，每 4 微秒加一，如果计算一下，如果到重复，需要 4 个多小时，那个绕路的包早就死翘翘了，因为我们都知道 IP 包头里面有个 <code>TTL</code>，也即生存时间。</p><p>好了，双方终于建立了信任，建立了连接。前面也说过，为了维护这个连接，双方都要维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><img src="/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/11/image-20210418231407867.png" class="" title="image-20210418231407867"><p>一开始，客户端和服务端都处于 <code>CLOSED</code>  状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。然后客户端主动发起连接 <code>SYN</code>，之后处于 <code>SYN-SENT</code>  状态。服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code> 客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。客户端收到服务端发送的 <code>SYN</code> 和  <code>ACK</code> 之后，发送 <code>ACK</code> 的 <code>ACK</code>，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于 <code>ESTABLISHED</code> 状态，因为它也一发一收了。</p><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><img src="/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/11/image-20210418232328788.png" class="" title="image-20210418232328788"><p>断开的时候，我们可以看到，当 A 说“<strong>不玩了</strong>”，就进入 <code>FIN_WAIT_1</code> 的状态，B 收到“<strong>A 不玩</strong>”的消息后，发送知道了，就进入 <code>CLOSE_WAIT</code> 的状态。</p><p>A 收到“<strong>B 说知道了</strong>”，就进入 <code>FIN_WAIT_2</code> 的状态，如果这个时候 B 直接跑路，则 A 将永远在这个状态。TCP 协议里面并没有对这个状态的处理，但是 <code>Linux</code> 有，可以调整 <code>tcp_fin_timeout</code> 这个参数，设置一个超时时间。</p><p>如果 B 没有跑路，发送了“<strong>B  也不玩了</strong>”的请求到达 A 时，A 发送<strong>“知道 B 也不玩了”</strong>的 <code>ACK</code> 后，从 <code>FIN_WAIT_2</code> 状态结束，按说 A  可以跑路了，但是最后的这个 <code>ACK</code> 万一 B 收不到呢？则 B 会重新发一个“<strong>B 不玩了</strong>”，这个时候 A 已经跑路了的话，B 就再也收不到  ACK 了，因而 <code>TCP</code> 协议要求 A 最后等待一段时间 <code>TIME_WAIT</code>，这个时间要足够长，长到如果 B 没收到 <code>ACK</code> 的话，“<strong>B  说不玩了</strong>”会重发的，A 会重新发一个 <code>ACK</code> 并且足够时间到达 B。</p><p>A 直接跑路还有一个问题是，A  的端口就直接空出来了，但是 B 不知道，B 原来发过的很多包很可能还在路上，如果 A 的端口被一个新的应用占用了，这个新的应用会收到上个连接中 B 发过来的包，虽然序列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而也需要等足够长的时间，等到原来 B  发送的所有的包都死翘翘，再空出端口来。</p><p>等待的时间设为 <code>2MSL</code>，<code>MSL</code> 是  <code>Maximum Segment Lifetime</code>，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 <code>TCP</code>  报文基于是 <code>IP</code> 协议的，而 <code>IP</code> 头中有一个 <code>TTL</code> 域，是 <code>IP</code> 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 <code>ICMP</code> 报文通知源主机。协议规定 <code>MSL</code> 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2  分钟等。</p><p>还有一个异常情况就是，B 超过了 <code>2MSL</code>  的时间，依然没有收到它发的 FIN 的 ACK，怎么办呢？按照 TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A  就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 <code>RST</code>，B 就知道 A 早就跑了。</p><h3 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h3><p>将连接建立和连接断开的两个时序状态图综合起来，就是这个著名的 <strong>TCP 的状态机</strong>。</p><p>学习的时候比较建议将这个状态机和时序状态机对照着看，不然容易晕。</p><img src="/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/11/fd45f9ad6ed575ea6bfdaafeb3bfb62a.jpg" class="" title="img"><p>在这个图中，加黑加粗的部分，是上面说到的主要流程，</p><ul><li>阿拉伯数字的序号，是连接过程中的顺序</li><li>大写中文数字的序号，是连接断开过程中的顺序</li><li>加粗的实线是客户端 A 的状态变迁</li><li>加粗的虚线是服务端 B 的状态变迁</li></ul><blockquote><p>TCP 包头很复杂，但是主要关注五个问题，<strong>顺序问题</strong>，<strong>丢包问题</strong>，<strong>连接维护</strong>，<strong>流量控制</strong>，<strong>拥塞控制</strong></p></blockquote>]]></content>
    
    
    <summary type="html">因性恶而复杂，先恶后善反轻松</summary>
    
    
    
    <category term="网络" scheme="http://universeinheart.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://universeinheart.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>10.UDP协议</title>
    <link href="http://universeinheart.github.io/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/10/"/>
    <id>http://universeinheart.github.io/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/10/</id>
    <published>2021-04-18T01:26:37.000Z</published>
    <updated>2021-04-18T01:43:04.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP-和-UDP-有哪些区别？"><a href="#TCP-和-UDP-有哪些区别？" class="headerlink" title="TCP 和 UDP  有哪些区别？"></a>TCP 和 UDP  有哪些区别？</h3><p>一般面试的时候我问这两个协议的区别，大部分人会回答，TCP 是面向连接的，UDP  是面向无连接的。</p><p>什么叫面向连接，什么叫无连接呢？在互通之前，面向连接的协议会先建立连接。例如，TCP 会三次握手，而 UDP  不会。</p><p>为什么要建立连接呢？你 TCP 三次握手，我 UDP 也可以发三个包玩玩，有什么区别吗？</p><p><strong>所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。</strong></p><blockquote><p><strong>TCP 提供可靠交付</strong>。通过 TCP  连接传输的数据，无差错、不丢失、不重复、并且按序到达。我们都知道 IP  包是没有任何可靠性保证的，一旦发出去，就像西天取经，走丢了、被妖怪吃了，都只能随它去。但是 TCP  号称能做到那个连接维护的程序做的事情，这个下两节我会详细描述。而 <strong>UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达</strong>。</p></blockquote><blockquote><p><strong>TCP 是面向字节流的</strong>。发送的时候发的是一个流，没头没尾。IP 包可不是一个流，而是一个个的 IP 包。之所以变成了流，这也是 TCP 自己的状态维护做的事情。而 <strong>UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收</strong>。</p></blockquote><blockquote><p><strong>TCP 是可以有拥塞控制的</strong>。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。<strong>UDP 就不会，应用让我发，我就发，管它洪水滔天</strong>。</p></blockquote><blockquote><p><strong>TCP 其实是一个有状态服务</strong>，通俗地讲就是有脑子的，里面精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一点儿都不行。而 <strong>UDP 则是无状态服务</strong>。通俗地说是没脑子的，天真无邪的，发出去就发出去了。</p></blockquote><p>我们可以这样比喻，如果 MAC  层定义了本地局域网的传输行为，IP  层定义了整个网络端到端的传输行为，这两层基本定义了这样的基因：网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。我们笼统地称为包。包单独传输，自行选路，在不同的设备封装解封装，不保证到达。基于这个基因，生下来的孩子 UDP 完全继承了这些特性，几乎没有自己的思想。</p><h3 id="UDP-包头是什么样的？"><a href="#UDP-包头是什么样的？" class="headerlink" title="UDP 包头是什么样的？"></a>UDP 包头是什么样的？</h3><p>当我发送的 UDP 包到达目标机器后，发现 MAC 地址匹配，于是就取下来，将剩下的包传给处理 IP 层的代码。把 IP 头取下来，发现目标 IP 匹配，接下来呢？这里面的数据包是给谁呢？</p><p>发送的时候，我知道我发的是一个 UDP  的包，收到的那台机器咋知道的呢？所以在 IP 头里面有个 8 位协议，这里会存放，数据里面到底是 TCP 还是 UDP，当然这里是  UDP。于是，如果我们知道 UDP 头的格式，就能从数据里面，将它解析出来。解析出来以后呢？数据给谁处理呢？</p><p>处理完传输层的事情，内核的事情基本就干完了，里面的数据应该交给应用程序自己去处理，可是一台机器上跑着这么多的应用程序，应该给谁呢？</p><p>无论应用程序写的使用 TCP 传数据，还是  UDP  传数据，都要监听一个端口。正是这个端口，用来区分应用程序，要不说端口不能冲突呢。两个应用监听一个端口，到时候包给谁呀？所以，按理说，无论是  TCP 还是 UDP 包头里面应该有端口号，根据端口号，将数据交给相应的应用程序。</p><img src="/2021/04/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/10/image-20210418091922388.png" class="" title="image-20210418091922388"><p>当我们看到 UDP 包头的时候，发现的确有端口号，有源端口号和目标端口号。因为是两端通信嘛，这很好理解。但是你还会发现，UDP 除了端口号，再没有其他的了。和下两节要讲的 TCP 头比起来，这个简直简单得一塌糊涂啊！</p><h3 id="UDP-的三大特点"><a href="#UDP-的三大特点" class="headerlink" title="UDP 的三大特点"></a>UDP 的三大特点</h3><p>第一，沟通简单，不需要一肚子花花肠子（大量的数据结构、处理逻辑、包头字段）。前提是它相信网络世界是美好的，秉承性善论，相信网络通路默认就是很容易送达的，不容易被丢弃的。</p><p>第二，轻信他人。它不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。</p><p>第三，愣头青，做事不懂权变。不知道什么时候该坚持，什么时候该退让。它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。</p><h3 id="UDP-的三大使用场景"><a href="#UDP-的三大使用场景" class="headerlink" title="UDP 的三大使用场景"></a>UDP 的三大使用场景</h3><p>第一，<strong>需要资源少</strong>，<strong>在网络情况比较好的内网</strong>，或者对于<strong>丢包不敏感的应用</strong>。这很好理解，就像如果你是领导，你会让你们组刚毕业的小朋友去做一些没有那么难的项目，打一些没有那么难的客户，或者做一些失败了也能忍受的实验性项目。</p><p>第二，<strong>不需要一对一沟通，建立连接，而是可以广播的应用</strong>。UDP 的不面向连接的功能，可以使得可以承载广播或者多播的协议。DHCP 就是一种广播的形式，就是基于 UDP  协议的。对于多播，我们在讲 IP 地址的时候，讲过一个 D  类地址，也即组播地址，使用这个地址，可以将包组播给一批机器。当一台机器上的某个进程想监听某个组播地址的时候，需要发送 IGMP  包，所在网络的路由器就能收到这个包，知道有个机器上有个进程在监听这个组播地址。当路由器收到这个组播地址的时候，会将包转发给这台机器，这样就实现了跨路由器的组播。在后面云中网络部分，有一个协议 VXLAN，也是需要用到组播，也是基于 UDP 协议的。</p><p>第三，<strong>需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候</strong>。UDP 简单、处理速度快，不像 TCP  那样，操这么多的心，各种重传啊，保证顺序啊，前面的不收到，后面的没法处理啊。等这些事情做完了，时延早就上去了。而 TCP  在网络不好出现丢包的时候，拥塞控制策略会主动的退缩，降低发送速度，这就相当于本来环境就差，还自断臂膀，用户本来就卡，这下更卡了。</p><p>当前很多应用都是要求低时延的，它们可不想用 TCP  如此复杂的机制，而是想根据自己的场景，实现自己的可靠和连接保证。例如，如果应用自己觉得，有的包丢了就丢了，没必要重传了，就可以算了，有的比较重要，则应用自己重传，而不依赖于  TCP。有的前面的包没到，后面的包到了，那就先给客户展示后面的嘛，干嘛非得等到齐了呢？如果网络不好，丢了包，那不能退缩啊，要尽快传啊，速度不能降下来啊，要挤占带宽，抢在客户失去耐心之前到达。由于 UDP  十分简单，基本啥都没做，也就给了应用“城会玩”的机会。同理如果你实现的应用需要有自己的连接策略，可靠保证，时延要求，使用 UDP，然后再应用层实现这些是再好不过了。</p><h3 id="基于-UDP-的“城会玩”的五个例子"><a href="#基于-UDP-的“城会玩”的五个例子" class="headerlink" title="基于 UDP 的“城会玩”的五个例子"></a>基于 UDP 的“城会玩”的五个例子</h3><h4 id="“城会玩”一：网页或者-APP-的访问"><a href="#“城会玩”一：网页或者-APP-的访问" class="headerlink" title="“城会玩”一：网页或者 APP 的访问"></a>“城会玩”一：网页或者 APP 的访问</h4><p>原来访问网页和手机 APP 都是基于 <code>HTTP</code>  协议的。<code>HTTP</code> 协议是基于 <code>TCP</code>  的，建立连接都需要多次交互，对于时延比较大的目前主流的移动互联网来讲，建立一次连接需要的时间会比较长，然而既然是移动中，<code>TCP</code>  可能还会断了重连，也是很耗时的。而且目前的 <code>HTTP</code> 协议，往往采取多个数据通道共享一个连接的情况，这样本来为了加快传输速度，但是 <code>TCP</code>  的严格顺序策略使得哪怕共享通道，前一个不来，后一个和前一个即便没关系，也要等着，时延也会加大。</p><p><code>QUIC</code>（全称 <code>Quick UDP  Internet Connections</code>，<strong>快速 UDP 互联网连接</strong>）是 Google 提出的一种基于 <code>UDP</code>  改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。</p><p>QUIC  在应用层上，会自己实现快速连接建立、减少重传时延，自适应拥塞控制，是应用层“城会玩”的代表。</p><h4 id="“城会玩”二：流媒体的协议"><a href="#“城会玩”二：流媒体的协议" class="headerlink" title="“城会玩”二：流媒体的协议"></a>“城会玩”二：流媒体的协议</h4><p>直播协议多使用 <code>RTMP</code>， 而这个 <code>RTMP</code> 协议也是基于 <code>UDP</code> 的。</p><p><code>TCP</code>  的严格顺序传输要保证前一个收到了，下一个才能确认，如果前一个收不到，下一个就算包已经收到了，在缓存里面，也需要等着。对于直播来讲，这显然是不合适的，因为老的视频帧丢了其实也就丢了，就算再传过来用户也不在意了，他们要看新的了，如果老是没来就等着，卡顿了，新的也看不了，那就会丢失客户，所以直播，实时性比较比较重要，宁可丢包，也不要卡顿的。</p><p>当网络不好的时候，<code>TCP</code> 协议会主动降低发送速度，这对本来当时就卡的看视频来讲是要命的，应该应用层马上重传，而不是主动让步。因而，很多直播应用，都基于 <code>UDP</code> 实现了自己的视频传输协议。</p><h4 id="“城会玩”三：实时游戏"><a href="#“城会玩”三：实时游戏" class="headerlink" title="“城会玩”三：实时游戏"></a>“城会玩”三：实时游戏</h4><p>实时游戏中客户端和服务端要建立长连接，来保证实时传输。但是游戏玩家很多，服务器却不多。由于维护 <code>TCP</code> 连接需要在内核维护一些数据结构，因而一台机器能够支撑的 <code>TCP</code> 连接数目是有限的，然后 <code>UDP</code> 由于是没有连接的，在异步 IO  机制引入之前，常常是应对海量客户端连接的策略。</p><p><code>TCP</code> 的强顺序问题，对战的游戏，对网络的要求很简单，玩家通过客户端发送给服务器鼠标和键盘行走的位置，服务器会处理每个用户发送过来的所有场景，处理完再返回给客户端，客户端解析响应，渲染最新的场景展示给玩家。</p><p>如果出现一个数据包丢失，所有事情都需要停下来等待这个数据包重发。客户端会出现等待接收数据，然而玩家并不关心过期的数据，激战中卡 1 秒，等能动了都已经死了。</p><p>游戏对实时要求较为严格的情况下，采用自定义的可靠 <code>UDP</code> 协议，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。</p><h4 id="“城会玩”四：IoT-物联网"><a href="#“城会玩”四：IoT-物联网" class="headerlink" title="“城会玩”四：IoT 物联网"></a>“城会玩”四：IoT 物联网</h4><p>一方面，物联网领域终端资源少，很可能只是个内存非常小的嵌入式系统，而维护 TCP 协议代价太大；</p><p>另一方面，物联网对实时性要求也很高，而 TCP 还是因为上面的那些原因导致时延大。</p><p>Google 旗下的 Nest 建立  <code>Thread Group</code>，推出了物联网通信协议 <code>Thread</code>，就是基于 <code>UDP</code> 协议的。</p><h4 id="“城会玩”五：移动通信领域"><a href="#“城会玩”五：移动通信领域" class="headerlink" title="“城会玩”五：移动通信领域"></a>“城会玩”五：移动通信领域</h4><p>在 4G 网络里，移动流量上网的数据面对的协议 <code>GTP-U</code> 是基于 <code>UDP</code> 的。因为移动网络协议比较复杂，而 <code>GTP</code> 协议本身就包含复杂的手机上线下线的通信协议。如果基于 <code>TCP</code>，<code>TCP</code> 的机制就显得非常多余，这部分协议我会在后面的章节单独讲解。</p>]]></content>
    
    
    <summary type="html">因性善而简单，难免碰到“城会玩”</summary>
    
    
    
    <category term="网络" scheme="http://universeinheart.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://universeinheart.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>不要让“假勤奋”害了你，这才是你正确奋斗的打开方式</title>
    <link href="http://universeinheart.github.io/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/01/"/>
    <id>http://universeinheart.github.io/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/01/</id>
    <published>2021-04-17T15:26:37.000Z</published>
    <updated>2021-04-17T10:00:42.665Z</updated>
    
    <content type="html"><![CDATA[<p>你认为自己是一个勤奋的人吗？</p><p>我相信你肯定很“勤奋”，因为你每天都要努力地活着，让自己很好地生存下去。</p><p>问题是，这种“勤奋”，到底能让你产生多少实质的改变呢？</p><p>以下这些状态，你是不是都会遇到：</p><ul><li>每天重复干着不感兴趣的工作，但又不知道可以做什么；</li><li>总觉得自己缺乏自律，想做点什么提升自己都很困难；</li><li>明知道有些问题对自己造成困扰，可就是不知道怎么解决；</li><li>很多时候只能被动成长，无法自我驱动让自己主动进步；-</li></ul><p>如果你有上述这些情况，就算你每天看似活得“很努力”，你也很难获得实质的进步和改变。因为，这只是一种“<strong>虚假式的勤奋</strong>”。</p><p>虚耗时间是一件很容易的事情，但把时间投入在某些事情上，然后收获产出，就需要你对自己提出更高的要求。</p><p>而第一步，就是了解自己当前的“努力状况”。</p><img src="/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/01/image-20210417175412078.png" class="" title="image-20210417175412078"><h3 id="你当前处于哪种劳动类别？"><a href="#你当前处于哪种劳动类别？" class="headerlink" title="你当前处于哪种劳动类别？"></a>你当前处于哪种劳动类别？</h3><p>在这个世界，我们能做的事情几乎多不胜数，而又纷繁复杂。</p><p>如果把这些我们要做的事情分门别类，大概可以分成四种特性的“劳动”：</p><ul><li>单向体力劳动，体力为主要的资源输出。如建筑工人，快递员，运动员等。</li><li>轻型体力劳动，稍微会结合脑力的一种轻度体力资源输出。如销售员，导游，出租车司机等。</li><li>复合脑力型劳动，脑力为主，体力为辅的一种资源输出。如企业策划，公司管理，教育传播等。</li><li>创造性资源劳动，脑力为主要的资源输出。如商业创业，科学发明，电影拍摄等。</li></ul><p>前两个类别，是通过“贩卖”固有的劳动资源去换取价值。这个价值，会有一个“可视化”的衡量标准，只要你肯做，肯定会获得相应的回报。</p><p>但这种劳动类别的缺点是，无论什么行业，你做的事都会有一个标准上限的“阈值”；一旦到达了这个标准上限，即便你成为行业的顶尖人物，获得的回报也就这么多。</p><p>而后两个类别，就是通过利用和整合已有的资源，让其“生出”更多的资源，从而获得高额的价值。</p><p>这些事并没有所谓的上限标准，你能产生多少价值，除了取决于你的个人能力，还要结合其他因素，才能获得“利益最大化”。</p><p>而这种劳动类别的缺点就是，有时候你做的事很讲求“时机”，如果缺乏时机，或者运气不好，就算你付出再多努力，可能也不会获得一个很好的回报。</p><p>于是这四种类型的“劳动”，就有横向和纵向之分，而由此产生两种进阶的方式：</p><ul><li>第一，从横向类别里面，挑选一个适合的工种，让自己从初级菜鸟变成顶尖高手；</li><li>第二，跳出原有劳动类别的限制，跃升到其他劳动类别，从而获得多向的发展途径；</li></ul><p>这两种前进的方式，都有一个共同点，就是无论是哪一类别的劳动，你输出的资源越是独特，越是稀缺，其产出的价值也就会越高。</p><p>在我们每个人在日常生活当中，这些劳动类别都会交错触及。只是哪一种劳动类别做主导，就决定你会产出多少价值而已。</p><p>换言之，按照接触的比例分配，我们把时间分配在哪一类事情上更多，我们由此产出的价值也就更多。</p><p>这样你就可以问自己三个问题：</p><ol><li>目前作为你主导资源输出的，是哪一种劳动类别？</li><li>这种劳动类别，做到最顶尖的程度会有什么结果？</li><li>你目前的资源，能否帮助你跃升到其他的劳动类别？</li></ol><p>好比一个水泥工，一直以来主导他资源输出的，就是单向体力劳动。这种性质的劳动，你一直做下去，只是变得更加熟手，成为这个工种的师傅而已，但本质上依然还是从事着体力劳动，这是一种限制。</p><p>如果你不喜欢这个结果，那当你做到某个程度之后，积累了好一些资源，然后自己跳出来，创业做建筑材料的老板，那这种跃升，就是对自身劳动资源的一种结构调整。</p><p>调整之后，你就脱离了水泥工这种单向体力劳动的限制，从而跳到其他的劳动类别上；输出脑力资源所占据的比例，比以前多了很多，于是个体价值的产出也因此而增加了。</p><p>当然风险也会存在，或许你的业务来源不稳定，获得的回报就没有以前从事单向体力劳动时那么固定，这也是你需要考虑的地方。</p><p>也就是说，有效的勤奋，就是结合两种类别的劳动方式，懂得如何提升自身输出资源的稀缺度，让自己在当前的劳动类别之中成为高手，或者努力跳升到更高维度的劳动类别上面，转变劳动方式，获得更好的发展。</p><p>瞄准这样一个方向去奋斗，这才是正确的做法。</p><img src="/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/01/image-20210417175443825.png" class="" title="image-20210417175443825"><h3 id="你目前拥有的资源是什么？"><a href="#你目前拥有的资源是什么？" class="headerlink" title="你目前拥有的资源是什么？"></a>你目前拥有的资源是什么？</h3><p>奋斗的路上，需要各种资源辅助。</p><p>而在奋斗伊始，我们拥有的资源，就是自身的能力。</p><p>一个打字员和一个写作者，尽管都是“文字输入”，但其能力所创造出来的价值，却完全不一样。</p><p>前者只是“贩卖”自己轻度的脑力和体力，而后者，则是结合自己的轻度体力，通过深度的脑力创造出一篇新的文章，其难度不可同日而语了。</p><p>但正如我前面所说，一个打字员创造出来的价值是稳定的。而一个写作者，写一篇文章出来的价值，却会随着个体名气或市场需求等各种因素，而产生波动，这就是风险。</p><p>所以这就决定了，两者产生价值的不同形式。如果你能够成为一个厉害的作家，写出一篇好的文章，少则会获得几千元的收入，多则获得上万元的也有。</p><p>但一个打字员呢？</p><p>就算他再努力，打字更快，这种资源在他对应的劳动类别当中，其产出的价值也只会局限于某个范围内，很难会有更大的提升了。</p><h4 id="你拥有的资源，会决定你产生多少价值。"><a href="#你拥有的资源，会决定你产生多少价值。" class="headerlink" title="你拥有的资源，会决定你产生多少价值。"></a>你拥有的资源，会决定你产生多少价值。</h4><p>所以为什么很多运动员都愿意跨领域，去参加一些综艺节目和接拍广告之类的事情？因为他们积累下来的资源，可以帮助他们跃升到其他类别的劳动当中，从而获得利益最大化，而不是单纯地输出体力。</p><p>毕竟运动这种事，你再怎么努力，当你拿到第一名时，已经就是尽头了，奖金也有限，尽管这也是非常了不起。但参加综艺节目或者拍摄广告，很难有一个明确的尽头界线。只要你能给商家创造更多的价值，你获得的收益肯定就会更多。</p><p>这种根据自身情况而做出的资源结构调整，是我们每个人都应该掌握的本领。</p><p>既然如此，根据你所处的“劳动类别”，然后给自己分析一下，你当前的努力，可以在你的劳动类别当中深挖下去，成为个中高手吗？抑或你是想跃升到其他的劳动类别，转变你的劳动方式呢？</p><p>如果你想要让自己获得改变，你就需要问一问自己，目前你所拥有的劳动资源，可以给你带来多少价值？</p><p>不管你想成为当前劳动类别的高手，还是想跃升到不同的劳动类别，获得更好的发展，缺少相关的劳动资源，那一切免谈。</p><h2 id="积累资源的方式"><a href="#积累资源的方式" class="headerlink" title="积累资源的方式"></a>积累资源的方式</h2><p>很多人都会有这种问题，就是工作了很多年，发现自己的经验居然“不值钱”。</p><p>一旦想到转换工作，整个人都会傻了眼，好像什么都要重头再来学一遍似的。这种看似勤奋，却无法让自己获得实质进步的行为，就被称为“虚假式勤奋”了。</p><p>无论你从事任何行业，有些基本甚至重要的能力都是通用的，而这些技能就被称为“可迁移能力”。</p><p>掌握这些“可迁移能力”，即便以后你转换工作，你过往的“经验”，也能够帮助你快速上手，而不是要重头再学。</p><p>根据youcore王世民老师提出的概念，我们每个人都应该要有一棵“能力树”，把自己需要积累的能力，清晰地做一个规划。</p><img src="/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/01/image-20210417175517053.png" class="" title="image-20210417175517053"><p>从这棵“能力树”中可以看得出来，决定我们是否能把自身能力转化为资源的要素，大概有四个。</p><p>我们不管从事哪一种工作，都需要以此积累相应的要素，发展自身的“能力树”。</p><p>于是有效的勤奋的步骤，就可以分为四步。</p><h3 id="第一步，设定目标搭建框架。"><a href="#第一步，设定目标搭建框架。" class="headerlink" title="第一步，设定目标搭建框架。"></a>第一步，设定目标搭建框架。</h3><p>如果你现在还在读书，你就要思考一下，将来你从事的职业，是属于哪种劳动类别的工作？</p><p>单向体力劳动的工作，你只要有充沛的体力就行，毕竟一个羸弱的身体，想去搬砖挣钱也挣不了多少。</p><p>而如果你想从事创造性资源的工作，例如想创业，你除了要积累到相关的能力，你还要找到一个可以认可你这种能力的平台。</p><p>一般而言，这个平台就是市场。</p><p>你创业出来的产品，市场的认受性高，你自然就获得丰厚的回报；反之，就是失败的可能性就会比较高。</p><p>这是这种劳动类别必须要承担的风险。</p><p>所以你要想清楚你的职业规划，你要问自己四个问题：</p><ol><li>你打算要从事哪种劳动类别的工作？</li><li>你目前的能力，是否能够从事这种劳动类别的工作？</li><li>你还缺乏哪些知识，才更好从事这种类别的工作？</li><li>你有没有准备好承担从事这种劳动类别的风险？</li></ol><p>有了这些问题的思考，你接下来才可以有目的地搭建你自身能力树的框架。</p><p>设定一个清晰而有效的目标，能够更好地帮助你积累相关的能力资源。</p><p>否则，漫无目的地上班下班，你做五年所获得的经验，也比不上别人一年所获得的经验。</p><img src="/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/01/image-20210417175531687.png" class="" title="image-20210417175531687"><h3 id="第二步，针对性提高自身技能。"><a href="#第二步，针对性提高自身技能。" class="headerlink" title="第二步，针对性提高自身技能。"></a>第二步，针对性提高自身技能。</h3><p>如果你现在已经工作，那么你就要想一想，目前这份工作，能够给你积累的“可迁移能力”会有哪些？</p><p>好比你是一个从事流水线工作的人，每天做一些非常单调又重复的操作，看起来你好像没有什么东西可以从中积累，做多了人还容易变笨。</p><p>但其实对比一下上图的“能力树”，你就可以发现，有很多地方都能够自我提升。</p><p>例如你把手头上做得不好的工作，想办法如何做得更好，这就是思维能力和学习能力的体现，而不是用一种抗拒的心态去面对这些事情。</p><p>再如你平时只关注操作手头上的产品，有时你可以观察一下，这些产品定价背后的因素，以及供应链上下游的不同渠道，是怎么连接在一起，最后去到消费者的手上。</p><p>这些思考的背后，就是零售业和物流业的知识。如果你的关注点放在这些地方上面，你就可以以此积累相关的行业知识，这也是学习能力的体现。</p><p>即便以后你转换工作，你积累回来的这些“经验”，也会变得更加有用。</p><p>根据你设定的目标，针对性地去提高和积累相应的技能，你才不会浪费时间在无谓的事情上面。</p><img src="/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/01/image-20210417175552780.png" class="" title="image-20210417175552780"><h3 id="第三步，到底是选择晋升还是跃升。"><a href="#第三步，到底是选择晋升还是跃升。" class="headerlink" title="第三步，到底是选择晋升还是跃升。"></a>第三步，到底是选择晋升还是跃升。</h3><p>不管你的能力积累得怎么样，你必须要面对一个问题，就是：to be or not to be？</p><p>你要继续从事这份工作，从目前这种劳动类别晋升到更高的层次，还是跳出来，跃升到其他平台，更好发挥自己的能力呢？</p><p>所以这也衍生出另一个问题：你目前的能力资源，是否足够支撑你做出这样的决定？</p><p>你在什么都不懂的情况下，看到别人创业成功，然后你就贸贸然跑去创业，其结果可想而知。</p><p>如果你的能力还不足够支持自己做出某些选择，那你所有的“努力行为”，也只是属于玩票性质而已。</p><p>有本钱当然可以任性，但本钱不足够的前提下，在当前劳动类别中继续深造、积累能力，是一个稳妥的做法。</p><p>记住，晋升是指在同一个劳动类别继续深造；而跃升，则是指从当前的劳动类别，跳到更高层次的劳动类别。</p><p>这两者需要的能力资源，并不一样。</p><p>例如你是一个水泥工，突然不想混下去，然后选择去做一个销售员，那么这种转变，就是跃升，毕竟你从单向体力劳动，转为轻度体力劳动。</p><p>但不管是晋身还是跃升，根据自身的目标，积累相关的知识和能力，你才能够有资本做出相应的选择。</p><h3 id="第四步，试水式实践。"><a href="#第四步，试水式实践。" class="headerlink" title="第四步，试水式实践。"></a>第四步，试水式实践。</h3><p>当你把一些知识和能力积累到一定的程度后，如果没有实践的经验，你运用起来还是无法做到得心应手。</p><p>而通过试水的方式去给自己一个实践的机会，你能够根据实际的反馈情况，有效地调整自己的积累方式。</p><p>例如你想积累写作方面的能力，看了很多书，也练习了很长时间，觉得能力积累的差不多了。可是如果你不把文章发表出来，你根本不知道这篇文章会获得多少反馈。</p><p>没有这些反馈结果，你就无法针对性地调整写作方向，继续提高自己的能力。</p><p>所谓“试水式”，就是一个自己一个了解自己的过程。毕竟你无法一下子就晋升或跃升到更高的层次，你必须循序渐进地把能力发挥出来，获得别人认可后，你才有转变的机会。</p><p>所以，不管你积累什么资源，一定要找机会运用出来。就算你打算创业，也要从实际的事情做起，才能明白到整个创业的操作过程。</p><p>当你能够做到这样子，你的奋斗才会更加高效，你积累回来的经验，也才会更有用。</p><p>这就是所谓的“有效勤奋”了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你认为自己是一个勤奋的人吗？&lt;/p&gt;
&lt;p&gt;我相信你肯定很“勤奋”，因为你每天都要努力地活着，让自己很好地生存下去。&lt;/p&gt;
&lt;p&gt;问题是，这种“勤奋”，到底能让你产生多少实质的改变呢？&lt;/p&gt;
&lt;p&gt;以下这些状态，你是不是都会遇到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每天重复干着</summary>
      
    
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>简历帮你争取到面试</title>
    <link href="http://universeinheart.github.io/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/%E7%AE%80%E5%8E%86%E5%B8%AE%E4%BD%A0%E4%BA%89%E5%8F%96%E5%88%B0%E9%9D%A2%E8%AF%95/"/>
    <id>http://universeinheart.github.io/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/%E7%AE%80%E5%8E%86%E5%B8%AE%E4%BD%A0%E4%BA%89%E5%8F%96%E5%88%B0%E9%9D%A2%E8%AF%95/</id>
    <published>2021-04-17T15:26:37.000Z</published>
    <updated>2021-04-17T10:11:40.991Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、简历中应包含的要素，一个都别落下"><a href="#1、简历中应包含的要素，一个都别落下" class="headerlink" title="1、简历中应包含的要素，一个都别落下"></a>1、简历中应包含的要素，一个都别落下</h3><p>大家在准备简历应当注意“<strong>直接</strong>”两字：能让筛选人能直接地看出本人的教育背景、工作经历和项目经理，并让他们“直接”感到这份简历能纳入考虑范围。</p><table><thead><tr><th>简历中应包含的要素</th><th>目的</th></tr></thead><tbody><tr><td>基本信息，比如姓名，性别，年龄</td><td>1 让招聘方了解候选人的基本信息。 2 以便招聘方通过手机等方式能联系到候选人</td></tr><tr><td>按时间倒叙写教育背景，一般只需要包含高中以上，初中高中等不必写，但需包含专业和学历学位信息</td><td>专业和学历学位等信息向招聘方证明自己的技术背景。</td></tr><tr><td>总结性地列出自己所掌握的技能。比如： 1、 有3年Java经验，有2年Spring MVC经验。 2、有3年Oracle经验，有2年Oracle调优经验。</td><td>一般这些总结点是和职务需求是一致的，这样能让招聘方直接地感受到该候选人的匹配度。在这基础上，可以适当列些能成功帮到自己的总结点。</td></tr><tr><td>按倒叙列出工作过的公司，并列出在这些公司里的项目经验，这部分的技能下文会详细描述。</td><td>在项目经验描述里，能通过项目用到的技术经验等，具体地给出自己“匹配”该岗位的证明。</td></tr><tr><td>用少量篇幅列出自己的兴趣和自我总结</td><td>让招聘公司进一步了解候选人</td></tr></tbody></table><h3 id="2、该如何描述公司的工作情况"><a href="#2、该如何描述公司的工作情况" class="headerlink" title="2、该如何描述公司的工作情况"></a>2、该如何描述公司的工作情况</h3><p>这部分一般是按时间倒叙描述，比如可以按如下的格式写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2015年11月到2017年10月，在xx公司，职务是Java高级开发。离职理由是想进一步发展。</span><br><span class="line"></span><br><span class="line">2012年2月到2015年11月，在xx公司，职务是Java初级开发。离职理由是想进一步发展。</span><br></pre></td></tr></table></figure><p>按此格式写之前的公司情况</p><p>这部分的内容应当尽量靠前，在罗列公司情况时，请大家注意如下的四个要点。</p><p>第一，工作情况可以和项目经验分开写，一般会在后继的项目经验里写具体用到的技术框架以及所做过项目的细节，在这里的工作情况描述里，可以不用过于复杂，让招聘方看到你之前的公司情况即可。</p><p>第二，尽量别出现长时间的“空白期”，比如上份工作是2月份结束的，而下份工作是6月开始的。如果出现持续三个月以上的“不在职状态”，需要在简历中说明情况，比如这段时间你是换城市发展了，或辞职复习考研或复习考公务员，总之得找个能说得过去的理由。</p><p>第三，在简历上，尽量别让人感觉你每份工作都做不长，但不能以此作假。比如我见过有候选人会合并公司，比如2016年11月到2017年3月在A公司，2017年4月到10月在B公司，他为了不让招聘方感觉他换工作太频繁，在简历上就写2016年11月到2017年10月在B公司工作，而故意合并了A公司的经历。这样的话，如果遇到背景调查，会露馅，即使有些公司不做调查，在劳动手册等材料上也能反应出真实的工作情况，所以这种做法有一定的风险性。</p><p>这里推荐的做法是，不要合并公司，但可以写明理由，比如当时小王是被外派公司A以人力派遣的形式外派到B公司，但没过多久A公司因某种原因不再具备人力派遣的资质了，这时小王就不得不终止与A公司的合同转而和B公司签约，这样虽然看上去小王是换了公司，但实际上没有。通过类似的合理解释，招聘方就不再会质疑小王的工作能力和稳定性了。</p><p>第四，可以写上合适的离职理由，尤其当你短时间里换工作比较多，可能引起招聘方的质疑的情况里，更该考虑些合适的理由。</p><p>合理的离职理由可以是，想为自己提供一个更大的发展空间，或想通过升级来独当一面，以此进一步提升自己的能力，或公司因资金等方面的原因倒闭了。总之，这不是我主观上不稳定，而是由于客观原因导致我不得不换工作。</p><p>而可能会导致没面试机会的离职原因是，待遇问题（虽然大家心知肚明，但不能这样写），或无法承受大压力，或同事领导排挤。这类理由往往会暴露出候选人的缺点，所以不建议大家采用。从这意义上来讲，“合同期满”也不是一个好的离职原因，因为如果候选人能力强，那么为什么原公司不和你续约呢？</p><p>总之，在描述公司情况时，一旦出现会让招聘方感觉你能力不强或不稳定时，一定得醒目地写上足以信服的理由，这样你的简历才会有机会被继续被读下去，进而你才会有技术面试的机会。</p><h3 id="3-描述项目经验的技巧"><a href="#3-描述项目经验的技巧" class="headerlink" title="3 描述项目经验的技巧"></a>3 描述项目经验的技巧</h3><p>之前已经提到过，招聘方非常注重候选人简历上相关技术项目经验，因为这至少能有效地证明候选人实践过相关技术，而不是只具有理论知识。</p><p>具体而言，招聘方首先会看候选人最近半年的项目里用的是否是和本岗位相关的技术或框架，如果是，那么说明候选人能在入职后能直接上手干活。其次，会看候选人所有项目经历中和本岗位所用技能（或框架）一致时间年限，一般招聘方会对这个年限有个最低的标砖，当然越长越好。</p><p>如果大家自己感觉项目经历明明很匹配但最终却连面试的机会都没，那么问题大多就出在这个环节，下面我们来具体分析下描述项目经验的技巧。</p><h4 id="3-1尽量把学习培训项目和毕业设计项目往商业项目上靠"><a href="#3-1尽量把学习培训项目和毕业设计项目往商业项目上靠" class="headerlink" title="3.1尽量把学习培训项目和毕业设计项目往商业项目上靠"></a>3.1尽量把学习培训项目和毕业设计项目往商业项目上靠</h4><p>商业项目是指能挣钱的项目，和它对应的就是些不以挣钱为目的的学习项目或毕业设计项目。正因为客户付了钱，所以商业项目的要求要远远高于学习或毕业设计项目，这也是为什么招聘公司会看重商业项目而会主动过滤学习项目的原因。</p><p>职位描述上的相关技能年限一般只是指商业项目经验，而一般不会包括学习项目经验。所以对于一些介于商业项目和学习项目之间的项目，尽量当成商业项目来写。</p><p>比如小张在大三时帮计算机系的王老师所在的ABC软件公司干了半年的活，如果小张在简历上写：“在校期间，从x年x月到x年x月完成了xx系统，用到了xx技术”，那么这多半会被当成类似于课程设计的学习经验，但如果再加上如下关键性的描述：“这个系统是属于xx公司的xx商业项目里的一部分，我和另外三位开发人员做了半年，最终这个系统成功上线并在客户xx公司的环境里投入运营”，那这样小张的商业项目总年限里就能加上这半年时间了。</p><p>又如小李在做毕业设计时，花了7个月的时间参与了导师的一个电商商业项目，他主要的工作是设计一个调度算法，但也参与了一些诸如订单管理模块的工作。如果他就平淡地写一句，毕业设计是xx，毕业论文是xx，那么招聘方看过就算了，也不会认为小李在做毕业设计时还有过商业项目经验，这样小李未免有些吃亏。</p><p>但如果这样写：“在x年x月到x年x月的7个月里，在毕业设计中，我参与了xx公司的xx电商项目，客户方是x，我参与了订单管理和xx模块，并设计了其中的调度算法，在我的毕业论文里，详细介绍了这种做法”。文字没修改太多，但足以让小李增加7个月的商业项目经验。</p><p>在招聘过程中，我们经常会看到有些候选人参加了培训学校，在里面也做了一些实训项目。如果这些项目是用来让学生练手的，而没有产生商业价值，那么虽然这些项目可能来自真实项目，名字也叫xx实训项目，但非常可惜，我们没法把它当成商业项目。不过我们看到过一份印象比较深刻的简历，某候选人小丁在某三个月的时间内，一边参加培训，一边还在朋友的公司里兼职做着xx信息管理系统的项目。那么如果小丁能很好地在简历中很好地说明这个情况，而且还能在面试中很好地回答相应的问题，那么我们不得不相信小丁在这个三个月里确实做的是商业项目。</p><p>对于高级程序员而言，他们的项目年限一般会超过3年，所以多挖掘出来的商业项目年限就属于锦上添花了。不过不少公司在招聘时往往会设个最低年限标准（一般是1年半到两年），这对刚毕业的或工作经验小于2年的初级程序员而言无疑是道坎，所以如果大家处于这青黄不接的时间段里，就更得挖掘这些“严格意义上还算商业项目”的项目经历并写到简历中，这至少能帮大家争取到更多的技术面试机会。</p><p>不仅如此，我们发现大多数初级程序员的水平其实也差不多，这时就得看谁的商业项目经验丰富了。比如有次我们无法从两位候选人中权衡，因为他们的综合条件和面试情况都差不多，但其中有一位在大三阶段有段为期6个月的商业项目实习经验，另一位没有（也有可能他也有但没当成商业项目来写），这种情况下我们就录用了有实习经验的候选人了。</p><h4 id="3-2通过具体案例来看项目经验该怎么描述"><a href="#3-2通过具体案例来看项目经验该怎么描述" class="headerlink" title="3.2通过具体案例来看项目经验该怎么描述"></a>3.2通过具体案例来看项目经验该怎么描述</h4><p>假设某公司需要招一个Java高级开发，如下是职位描述。<br>1、计算机及相关专业毕业，3年以上Java Web项目开发经验；熟悉Linux平台。<br>2、精通JAVA 编程，熟悉Spring、Spring MVC、Mybatis/Hibernate等开源框架，熟悉常用cache机制,Jsp/Servlet等技术。<br>3、熟悉Tomcat、Nginx等应用服务器的配置和优化。<br>4、熟悉数据结构和算法，熟悉Java多线程开发。熟悉MySQL、Redis，熟悉数据库索引。<br>5、了解Web前端技术，包括HTML5/CSS/Javascript等。<br>6、拥有良好的沟通能力和文档能力。<br>7、勤奋而善于思考，愿意不断挑战和提升自己。</p><p>这里先说个技巧，如果候选人能通过简历让招聘方确信，在最近的项目里他用到了不少和招聘岗位相关的技术，那么他得到面试机会的可能性就会大大提升，因为招聘公司会认为候选人能入职后很快上手，而不会有太长的熟悉期。所以，我们可以按如下思路改写最近做的一个项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么我们就可以根据职位需求，从如下几个方面来描述项目经验。</span><br></pre></td></tr></table></figure><p>第一，简要描述项目的背景，比如时间范围，客户是谁，项目规模有多大。</p><p>从x年x月到现在（这个时间范围至少是最近半年），我参与某外汇交易系统，客户是xx银行，这个项目组的构成是，1位项目经理外加10位开发，总共的规模大概在80个人月左右。</p><p>第二，大致描述项目的需求和包含哪些模块，然后简要说下你做了哪些模块，同时说下在这个项目用到的开发工具和主要技术点，这部分的描述如下所述。</p><p>这个外汇交易系统包括挂盘撮合成交、实盘成交、反洗钱和数据批处理等模块，我主要负责了挂盘撮合成交模块，其中用到了Spring MVC架构，数据库是Oracle，用Mybatis实现的ORM，该系统是运行发布在Weblogic服务器上，我们还用了Nginx来实现负载均衡，用Redis来缓存数据。在这个项目里，我还用到了JS实现了一些前台页面。</p><p>这里请大家注意如下的要点。</p><p>1、招聘方在看简历时，更关注的是用的技术，所以这里无需过度展开该项目里的业务细节，比如无需用大篇幅来写挂盘撮合成交模块里干了什么事情。</p><p>2、如果在这个项目里用到了职位介绍里给出的技术，应尽量写在项目描述里，但也要不能不顾事实地一股脑全写上。</p><p>第三，这里可以在刚才的基础上展开写这些技术在项目里是如何用的，以此来进一步证明你和所应聘职务的匹配度。同样这里也应围绕技术，而别多写业务细节，大家可以参考如下的范例。</p><p><strong>具体而言，在这项目的挂盘撮合成交模块里，我们用到Spring MVC框架，用到了其中的拦截器来拦截非法的挂盘订单请求，在数据库层面，我们还把一些常用数据放入Redis里，在Redis里我们用到了list和set这两种数据类型，而且还用到了master-slave模式。在使用Nginx时，我们是通过配置来避免出现Session粘滞的问题。</strong></p><p>  如果大家只写用到过Spring MVC和Nginx，那么筛选简历的人看一眼就过了，最多认为大家用过。但如果大家再写一些只有用过才能知道的细节点，比如Nginx的master-slave模式，那么就会给招聘方留下比较深刻的印象，大家给他们的感觉就会是“不仅用过，而且熟悉（或精通）”。</p><h4 id="3-3这些亮点你大多做过，不加在简历中有些可惜"><a href="#3-3这些亮点你大多做过，不加在简历中有些可惜" class="headerlink" title="3.3这些亮点你大多做过，不加在简历中有些可惜"></a>3.3这些亮点你大多做过，不加在简历中有些可惜</h4><p>  我们见过不少简历，在描述项目时，也能像上文一样，能根据招聘职位的具体要求展示出自己的匹配点，这种简历属于“达标”，即可以纳入考虑范围。在这个基础上，如果大家在项目里有下表列出的亮点，一定请写上，这就是大家优于别人的地方。</p><table><thead><tr><th>可以加入的亮点</th><th>怎么加</th></tr></thead><tbody><tr><td>JVM调优方面</td><td>请参考第九章，里面有专门的描述</td></tr><tr><td>设计模式方面</td><td>请参考第八章，里面有专门的描述</td></tr><tr><td>数据库调优方面</td><td>1可以说在项目里用过批处理预处理事务等高级知识点。 2 能通过监控查看哪些SQL语句需要调优。 3 能通过索引执行计划等方式对SQL语句进行优化. 4 进一步的话，能通过数据库集群等方式分散对单个数据库的压力. 5 如果做过，也可以写一些关于NoSQL和大数据方面的经验</td></tr><tr><td>Spring MVC等架构方面</td><td>1 用过其中诸如拦截器、AOP和事务等高级技能点。 2 在搭建框架时，能一起参与并熟悉如何通过框架来提升代码的可维护性。</td></tr><tr><td>学习和解决问题的能力特别强</td><td>比如可以写，在项目里，自己被分担一块大家都不大熟悉的技能，但你在短时间里就完成了技术调研并把它用到项目里。</td></tr><tr><td>能承担大的工作压力</td><td>1 由于客户方催进度的原因，这个项目需要加班（总之加班原因不是你造成的） 2 在这种情况下，你能和你的团队一起连续奋斗，最终成功地完成进度。</td></tr></tbody></table><p>上述的一些技能要求未必会出现在职位描述里，但确实都属于亮点，而且在大家的项目里，多少会用到些，所以不加有些可惜。当然，如果大家有其它的亮点，也可以加上，毕竟这能提升大家简历的价值。</p><h4 id="3-4多写些和项目管理相关的技能"><a href="#3-4多写些和项目管理相关的技能" class="headerlink" title="3.4多写些和项目管理相关的技能"></a>3.4多写些和项目管理相关的技能</h4><p>我们见过不少简历，在其中更偏重技术或诸如沟通和协作方面的能力，但事实上，项目管理方面的技能同样重要。这里可能会有个误区，不少人认为初级程序员的简历无需写项目经验，但事实上，项目管理技能也是靠积累的，哪怕刚工作1个月，也能积累这方面的能力。</p><p>在这方面，项目经理更偏重于如何根据项目需求合理地分配任务和协调进度，对于程序员而言，则可以在简历中写项目管理的方式以及如何使用常见的管理软件来提升项目管理的效率。</p><p>这里我们就以“敏捷开发”为例，向大家展示下如何介绍自己项目管理的方式。</p><p>我们这个项目采用了敏捷开发的模式，具体而言，我们会根据项目总体需求，设置若干个发布点，在时间上，每隔1个月就会设置一个。根据任务的优先级，我们先会大致定下每个发布时间范围内的大致任务，而在每个发布时间范围内，会根据当前情况适当微调。</p><p>而且，我们项目组还引入了“每天站立会议（Stand up Meeting）“的形式，每天我们项目组会用大致20分钟的时间一起讨论下每人已经完成的任务、要做的任务和遇到的问题，这样即使遇到阻碍性的问题，也不会耽搁整个项目很久的时间。</p><p>相关的内容无需多，大家只需列些“敏捷开发的必做点”，以此来证明自己实践过这种开发方式即可。如果招聘公司也是采用类似的项目管理方式，那么这点一定是个很好的加分项，即使招聘公司采用其它方式，比如瀑布模型，那么你写上这话，招聘方的评价就不会仅仅是“熟悉项目开发的技术”，而且还是“了解并实践过XX项目管理方式，对项目管理有一定的了解”，这样这份简历获得面试机会的可能性就大大增加了。如果大家在项目里用到的不是敏捷管理模式，而是其它的管理方式，也可以照着这个思路写。</p><p>此外，正规的项目多少或用些项目管理的工具，大家也可以在简历中列一些自己用过的，以此来进一步证明项目管理方面的经验。在下表里，我们总结了一些常见的开发人员能用得上的项目管理工具。</p><table><thead><tr><th>工具或软件</th><th>项目管理方向</th><th>能起到什么样的作用</th></tr></thead><tbody><tr><td>JUnit</td><td>单元测试</td><td>开发人员在开发完成后，可以用Junit来编写自己代码的单元测试代码， 运行单元测试代码后，能测试自己开发的模块。</td></tr><tr><td>Maven</td><td>构建项目</td><td>通过Maven，我们能给项目引入必备的jar文件， 也能方便地编译(build)和发布项目代码。</td></tr><tr><td>Jenkins</td><td>持续集成工具</td><td>（一般会和Ant一起用）我们一般会用重复的工作来发布不同版本的项目， 比如运行ant脚本，把生成的jar放入指定的Linux目录并设置一些script文件的可运行权限。 我们可以通过设置Jenkins脚本来配置这些重复的工作。</td></tr><tr><td>Jira</td><td>缺陷或任务管理</td><td>每当遇到一个Bug或一个新任务，我们可以建一个jira， 此时该Jira状态是Open，程序员开始开发时，会设置成In Progress， 完成开发后能设置成In QA，这样测试人员就能介入测试， 测试完成后，测试人员能把它设置成In UAT，一旦把该任务部署到生产环境， 就能Close这个Jira。也就是说，通过Jira，我们能在项目里很好地跟踪和 监控具体问题和任务的当前状态。</td></tr><tr><td>Git</td><td>版本管理</td><td>通过Git或SVN等版本管理工具， 在项目里我们能方便地建立提交或回退各人的修改，还能分支版本。 Git还有个好处：可以设置成“评审后才能提交”的模式， 这样某人要往主版本提交的代码必须要经过一人或多人的评审， 这样就能很好地控制代码的质量。</td></tr><tr><td>Autosys或Crontab</td><td>用于定时跑脚本任务</td><td>比如我们要定时跑一个脚本， 我们就能通过Autosys或Crontab来设置， 通过Autosys，我们更能方便地设置任务间的依赖关系， 比如A任务跑好后B任务才能跑，而且还能查看任务运行的状态是成功还是失败。</td></tr><tr><td>Sonar</td><td>代码质量管理</td><td>通过Sonar，我们不仅能检查代码是否还有bug， 还能查看代码的质量，比如代码的注释率是多少， 单元测试覆盖率是多少。Sonar还能给出一些代码方面的建议。 总之，通过Sonar，我们能提升代码质量。</td></tr></tbody></table><p>具体而言，大家可以在简历加上如下的内容：在这个银行（或其它）项目里，我们用Maven来管理项目，用Git做版本管理，用Junit来做单元测试，用Jira来做bug管理，在代码上线前，我们还会用Sonar来扫描代码，如果发现一些可改进点，比如Junit覆盖率不高，我们会及时改正。</p><p>大家在简历中写这部分的内容时请注意如下的两个要点：</p><p>1 在项目管理方面一般都会用到些工具，也就是说，大家可以写上在自己项目里用到的工具以及这些工具应用在哪些方面，但别什么都不写。</p><p>2 面试官在看到相关描述后，一般会在面试中询问些细节，比如Jenkin的配置方式等，也就是说，大家不仅要写，还得适当地了解下这些工具的使用细节，以备面试时的提问。</p><h3 id="4-投送简历时的注意要点"><a href="#4-投送简历时的注意要点" class="headerlink" title="4 投送简历时的注意要点"></a>4 投送简历时的注意要点</h3><p>简历准备得再好，如果用不恰当的方式投递出去，同样无法得到面试机会，所以大家在发送简历时，应当注意如下的要点。</p><h4 id="4-1不要发送“万能“简历，根据具体的职位要求进行微调"><a href="#4-1不要发送“万能“简历，根据具体的职位要求进行微调" class="headerlink" title="4.1不要发送“万能“简历，根据具体的职位要求进行微调"></a>4.1不要发送“万能“简历，根据具体的职位要求进行微调</h4><p>这可能是不少求职者的“通病”，他们往往就准备一份简历，然后看到一个合适的工作机会就发一份，也不关注这个公司的行业背景，也不看这个职位的具体要求。</p><p>其实大家的简历是“闭门造车”的形式写出来的，只能“尽可能”地描述自己掌握的技能（无法完全描述出你项目里用到的所有技能要点），而每个公司的职务要求一定不会完全相同，所以大家在发送简历前一定得根据具体的职位需求改写相关的项目经验描述，以求达到“匹配度”最高的效果。</p><p>相反，如果大家针对不同的公司发的是同一份简历，那么就得撞大运了，这样一定会失去不少“匹配度不高“的面试机会，其实修改简历所用的时间不会太多，但效果一定是大相庭径。</p><h4 id="4-2在招聘会上，尽量要口头说出你和这个职位的匹配点"><a href="#4-2在招聘会上，尽量要口头说出你和这个职位的匹配点" class="headerlink" title="4.2在招聘会上，尽量要口头说出你和这个职位的匹配点"></a>4.2在招聘会上，尽量要口头说出你和这个职位的匹配点</h4><p>在招聘会上，大家只能是发送同一份简历，在这种情况下，大家一定得尽可能地和招聘方交流几句，同坦诚的措辞，口头说下你和这个职位的匹配度，同时让招聘方感受到你热切想得到这份工作，这样比“递交简历无其它互动“的效果要好很多，至少能给招聘方留下些许印象。</p><h4 id="4-3简历以正文形式发送，别让招聘方觉出敷衍"><a href="#4-3简历以正文形式发送，别让招聘方觉出敷衍" class="headerlink" title="4.3简历以正文形式发送，别让招聘方觉出敷衍"></a>4.3简历以正文形式发送，别让招聘方觉出敷衍</h4><p>在很多场合下，大家是通过邮件的方式发送简历，在这种方式下，由于只是通过文字，无法面对面直接交流，所以大家应当尽量让招聘方感受到自己求职的诚意，至少别让他们感觉出“敷衍”。</p><p>这里来举些可能会让招聘方感受到“敷衍”的例子。</p><p>例子1，从邮件的标题和称谓上，看不出这份邮件是给本公司专门定制的。比如我们经常会收到这样的简历，标题是“应聘xx岗位”，开头是，尊敬的先生/女士，在其中第一没有公司的称谓，第二我们已经在招聘要求里写了负责收简历的是人事王先生，但这里没有具体的称谓，这就会让我们感觉这份邮件是通用的，而不是专门发给我们公司的。</p><p>恰当的做法是，在邮件标题里写上具体的公司名，比如应聘xx公司的xx岗位，在开头上写，xx公司，尊敬的人事王先生，这里如果没有留收简历人的称谓就写尊敬的人事，这样就会让人感到候选人在这份邮件至少是下过功夫的。</p><p>例子2：从邮件列表里，我们能看出候选人是群发邮件，把同一份简历发给不同的公司。这种情况不多，但有，恰当的做法是，在一封邮件里，只给一个公司发送求职信息。</p><p>例子3：有些候选人在邮件里，直接用附件的形式发简历，而没有任何正文的内容。这就无法让招聘方感觉到候选人的诚意了。</p><p>比较恰当的做法是，候选人还应当在邮件里写上如下样式的求职信。</p><p>xx公司，尊敬的人事张先生：</p><p>我在xx招聘网站上看到您这边的招聘Java高级开发的信息，特来应聘。</p><p>我叫xxx，今年xx岁，xx大学xx系毕业，本科学历，手机是xx。</p><p>我有x年java经验，用过Spring MVC等技术（根据职位描述列出用到过的其它Java技术），数据库方面，我用过xx，也有过调优经验（数据库方面的经验也请和职位描述一致）。再根据职位描述写一些自己和这个岗位相匹配的技术。</p><p>我非常愿意加入贵公司从事Java高级开发的工作，我的详细情况请看我的简历，如果可以，我非常愿意向您这边提供更多的个人信息。</p><p>最后列上署名</p><p>因为有些公司的邮箱出于安全因素，会过滤附件，所以还是建议大家以附件形式发简历的同时，在正文里也加上简历的内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、简历中应包含的要素，一个都别落下&quot;&gt;&lt;a href=&quot;#1、简历中应包含的要素，一个都别落下&quot; class=&quot;headerlink&quot; title=&quot;1、简历中应包含的要素，一个都别落下&quot;&gt;&lt;/a&gt;1、简历中应包含的要素，一个都别落下&lt;/h3&gt;&lt;p&gt;大家在准备简</summary>
      
    
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>别急着写文章，先练好如何表达一个观点</title>
    <link href="http://universeinheart.github.io/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/09/"/>
    <id>http://universeinheart.github.io/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/09/</id>
    <published>2021-04-17T15:18:37.000Z</published>
    <updated>2021-04-17T10:12:41.409Z</updated>
    
    <content type="html"><![CDATA[<p><strong>你必须通过表达观点去改变别人，才能生存下去。</strong></p><p>比如走进一家面馆，你会说，我想来一碗牛肉面。然后服务员会给你端来一碗，你通过对她<strong>行为上的改变</strong>，才不会让自己挨饿。</p><p>或者你参加面试，你通过表达观点，让简历平庸的你，立即让面试官眼前一亮。他决定录用你，这是他<strong>决策上的改变</strong>，然后你才可以开始挣钱。</p><p>所以，为什么你要表达一个观点，其本质就是：<strong>是否可以改变别人。</strong></p><p>如今多数人的表达都更习惯自嗨，为了<strong>想要表达而表达，叫自我思维表达。</strong></p><p>而我们今天所讲的是<strong>为了别人改变而表达，叫做用户思维表达。</strong></p><p>这两种表达方式的差别在于，自我思维的表达效率高，但市场效率低。</p><p>比如你和一个老友聊天，一见面就可以聊，根本不需要准备。但是聊天通常只能面对一个人，最多几个人。</p><p>而用户思维表达刚好相反，表达效率低，但市场效率高。</p><p>比如你准备一场稍微正式的演讲，少说需要花个七八天时间。你需要考虑台下到底有50人还是500人，能否被你的演讲触动。</p><p>所以，如果你希望自己的表达，市场效率更高。唯一所需要做的，就是从<strong>自我思维表达</strong>切换到<strong>用户思维表达。</strong></p><p>有一个营销心理学中的模型，可以让我们Get到完整的解决办法。</p><p>我把它称为<strong>“培根三明治”模型</strong>，由两片面包，培根，和蔬菜构成。</p><p>1、上层的面包是指开头，热烤的面包香味可以立即吸引用户，这里重要的是<strong>建立“用户链接”。</strong></p><p>2、而培根是论点，份量最少但最核心，作用是进行<strong>“感性启发或理性启发”。</strong></p><p>3、蔬菜部分是指论据，可以由生菜、西红柿等新鲜食材构成，这里的重点是<strong>建立“鲜活性效应”。</strong></p><p>4、下层的面包是结尾，它和开头遥相呼应，都需要激发用户的情感，重点是<strong>提供“情绪价值”。</strong></p><img src="/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/09/image-20210417180656664.png" class="" title="image-20210417180656664"><p>假如你和朋友刚吃完火锅，门口有个摊贩问你：“需要来罐凉茶吗？”你肯定纳闷，我现在要凉茶干什么？</p><p>但这时候别人吼出响亮一声“怕上火，喝王老吉”，你多半就可能会买一罐了，因为吃火锅容易上火嘛。</p><p>这个就叫<strong>“建立用户链接”</strong>，凉茶本来和你没有关系，但上火就有关系了，而凉茶就可以消火。</p><p>这也是建立用户链接的第一个方法<strong>，让用户关注他们自己。</strong></p><p>而另外一个方法是，引起他们的兴趣。</p><p>比如说一些有反差的事例：我这辈子从来没有用过香水，但是昨天，我却一口气买了三种不同味道的香水。</p><p>或者提供一个让人震惊的事实：你知道吗？住巷尾那个人，眼睛根本就没有瞎。他这么多年处心积虑，是为了……</p><p>又或者讲个故事，比如卡夫卡《变形记》的开头：当格里高·萨姆莎从烦躁不安的梦中醒来时，发现他在床上变成了一个巨大的甲虫。</p><p>当然，你的整个表达都应该引起用户兴趣，但最好在开场30秒之内就要做到第一次兴趣点的激发。</p><p>04 培根</p><p>在设置“培根”（论点）时，许多人都会想，如何才能有好的观点博人眼球呢？</p><p>但请注意，博人眼球这种把戏，在设置“上层的面包”（开场）时，比划比划就行了。</p><p>在这个环节要给最好的肉，给点实在的东西。</p><p>但这个”实在的东西“绝不是故作高深的理论，切记没人喜欢听说教。</p><p>人们更愿意通过你表达，获得<strong>感性启发或理性启发。</strong></p><p>在《放牛班的春天》里，教导主任通常都是对学生一顿臭骂，或一通说教，这毫无作用。</p><p>但马修老师的表达方式就不一样。比如他对皮埃尔说到，“凡事都有可能，永远不说永远”。这句话直接坚定了皮埃尔唱歌的信心，终让他成为享誉全球的音乐大师。</p><p>因为我们大脑中感性部分和理性部分的长期博弈，每个人都有及时行乐和长期自律的双面性。</p><p>我们有时候很想狂吃一顿火锅（及时行乐），但是又想通过长期锻炼来保持身材（长期自律）。</p><p>所以，针对这个特征，你可以选择要么唤起情绪化、负面、短浅的感性面，要么唤起理性、自律、长远考虑的理性面。</p><p>比如迷蒙的文章，“女人好好打扮就是为了取悦男人？瞎扯！”这就立即唤起了广大女性同胞渴望独立，活得自主的女权情绪。（感性启发）</p><p>再比如道长的这篇文章，没有更多说表达观点的技巧。而是更注重唤起你的理性思维，让你自己去思考你应该如何改变。（理性启发）</p><p>05 蔬菜</p><p>但如何去唤起呢？这就是整个观点的“蔬菜”（论据）部分。</p><p>蔬菜不能太多，三种最合适。</p><p>而针对感性启发和理性启发，我们是否需要两种不同的办法呢？</p><p>答案是不用，你只需要提供一种东西就可以，<strong>鲜活性效应（Vividness Effect）</strong>。</p><p>这最早由心理学家凯勒·阿兰德提出，是指一种人类被感性情境轻易打动的心理。</p><p>比如有人给你说，“有300万犹太人被送往奥斯维辛集中营的毒气室被杀害”，你可能感受不太明显。</p><p>但如果看到下面这张图片，你是否依然能够听到那些指甲划过硬墙，撕心裂肺的声音。</p><img src="/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/09/image-20210417180746701.png" class="" title="image-20210417180746701"><p>你可能说，不能用图片怎么办呢？</p><p>那就尽量用文字去塑造这种场景感：</p><p>比如“踩惯了红地毯，会梦见石板路”，就比“我偶尔会怀念故乡”要好很多。</p><p>在这里你可能有一个疑问，最有说服力的不是数据吗？</p><p>NO! 冷冰冰的数据本身，只能提供逻辑。只有它与场景感相连接，唤起人们的感受，才能影响他们的行为。</p><p>比如“一年买了7.17亿杯奶茶” ，你感受不大。</p><p>但“一年买了7亿杯奶茶，可绕地球赤道两圈。”这个感受就很深刻了。</p><p>06 下层的面包</p><p>最后，是“下层的面包”，结尾部分。</p><p>如何去写结尾，是小学三年级开始学写作文时，老师就会教我们的东西。</p><p>但你可能不知道结尾最真正的效用，<strong>提供情绪价值（Emotional value）。</strong></p><p>什么是情绪价值呢？</p><p>比如你今天悄悄走到一个女同事旁边，在她耳朵旁悄悄说了一句，今天这件衣服，真的很适合你。</p><p>这时候你就给同事提供了自信、满足、窃喜的情绪价值。</p><p>在表达过程中，你之前做了那么多铺垫，不就是为了你表达的终极目标“改变别人，促使行动”吗？</p><p>而通常人们都是在有情绪的情况下才会作出改变。</p><p>比如别人一激动，就转发你的文章。头脑一发热，就把那件3000块的衣服买了</p><p>用户在享用了你的“上层的面包”、“培根”和“蔬菜”后，其实大多都有一个既定的情绪了，只需要你准确提供他们所需要的情绪价值就行。</p><p>比如奥巴马卸任演讲的结尾其中9个单词：</p><p>Yes We can.是的，我们能行。</p><p>Yes We did.是的，我们做到了。</p><p>Yes We can.是的，我们能行！</p><p>这是一种完成使命后的坚定，也是英雄迟暮的感怆，也是一种低头洒泪后、仍目光坚毅不断前行的国家气魄。</p><p>相信在台下，他的所有簇拥者，都会被这个情绪所影响深远。</p><p>07 结语</p><p>怎么样？关于如何去表达一个观点，脑子里是否一下就清晰了呢？</p><p>相信你再也不会担心这样的场景：</p><p>有一天，你的领导突然让你在一个正式场合，分享个什么东西。</p><p>你可以十分优雅地回应他，请给我十分钟时间准备。</p><p>然后你迅速躲到卫生间最里间的马桶上，拿出纸笔，画下道长今天送你的这个“培根三明治”，把面包、培根、蔬菜的部分，充分填充你惊为天人的想法。</p><p>然后你轻步上台，让所有领导来宾全部懵逼，太特么有才了！</p><p>都写得有点激动了。深吸口气，平静下来。</p><p>此时只想说，观点请收下，练习最重要，相信你可以！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;你必须通过表达观点去改变别人，才能生存下去。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如走进一家面馆，你会说，我想来一碗牛肉面。然后服务员会给你端来一碗，你通过对她&lt;strong&gt;行为上的改变&lt;/strong&gt;，才不会让自己挨饿。&lt;/p&gt;
&lt;p&gt;或者你参加面试，你</summary>
      
    
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>程序员需要避免的 10 个坏习惯</title>
    <link href="http://universeinheart.github.io/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%2010%20%E4%B8%AA%E5%9D%8F%E4%B9%A0%E6%83%AF/"/>
    <id>http://universeinheart.github.io/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%2010%20%E4%B8%AA%E5%9D%8F%E4%B9%A0%E6%83%AF/</id>
    <published>2021-04-17T15:18:37.000Z</published>
    <updated>2021-04-17T10:12:03.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-休息不够"><a href="#1-休息不够" class="headerlink" title="1. 休息不够"></a>1. 休息不够</h2><p>我敢肯定你们很多人或者说几乎所有人都对这个坏习惯感到十分罪恶。我也是，对没有休息或休息不够依然有罪恶感。曾有一段时间，我凌晨六点入睡，中午一点左右起来吃午饭，一直工作到第二天凌晨六七点。这简直太常见了，几乎每天都是如此。在工作任务紧急的时候，我做过许多可笑的事情。我想我们每个人面对DDL的时候都有过这样的情况，我要说的不是这种，而是你的日常习惯。</p><p>我建议你每天尽量多休息。我不能说那种具体而微的计划，因为每个人都不一样，但在一般意义上，你应该每小时都应该起身伸展四肢，活动一下，喝杯咖啡，吃点东西。很多时候，如果你思路停滞，那你需要休息一下，大脑得到休息有助于更容易地解决问题。所以找到适合你的休息方式。即使你认为自己不需要休息，但也试一下，你会发现自己的效率提高了不少。</p><h2 id="2-拒绝寻求帮助"><a href="#2-拒绝寻求帮助" class="headerlink" title="2. 拒绝寻求帮助"></a>2. 拒绝寻求帮助</h2><p>这一条在学习和工作场景中都很常见。我们很多人都不寻求帮助。原因很多，但我认为最主要的原因无非是自尊以及害怕让人认为自己啥也不会。我们很多人都有冒名顶替综合征，觉得自己不完全胜任自己的工作。我在公司里、在和客户打交道时、甚至在上课和辅导中都有这种感觉。我们认为寻求帮助会强化这种感觉。但事实上，它浪费了大量时间，阻碍了你的成长。</p><p>其他真正的开发人员们都是视频或书籍一般的资源，甚至要比这些好太多。他们可以直接回答你的问题，帮助你真正的理解它。 只有混蛋才会因为你问问题而批评你，这时候我会尽力避开这些人。 如果你想要自己找到答案，不想寻求帮助，那也没问题，给自己一个时间限制。当你的前辈就在你旁边，他可能知道或至少可以帮到你的时候，千万不要浪费几天时间来寻找答案。</p><h2 id="3-停止学习"><a href="#3-停止学习" class="headerlink" title="3. 停止学习"></a>3. 停止学习</h2><p>我不管你是否是从业20余年的高级开发人员，你应该一直把自己当成一个学生。这比大多数职业的要求更高，因为这一行总在变化。没有一个开发人员可以知道所有事情的全部内容，他们这一分钟这样做，下一分钟就有变化发生，他们就必须学习更多。如果你骄傲自满，停止阅读、学习，你必然会落后。即便你有一份不需要学习任何新东西的工作，一旦你失去了那份工作（这并非不可能发生），你会远远落后。所以即使有这样的工作，我也建议你边工作边学习。</p><p>不管你喜欢那种语言、框架、库，你都要及时更新你的知识。如果你的职位需要的只是旧知识，这也是可理解的，因为很多领导倾向于认为如果公司还没没落，那就没必要修复。所以你仍然会发现有些团队用着过时的、不受支持的技术，只因为该技术还能运行。如果你边工作边学习这方面的新东西，那你就可以向团队展示更快、更高效、更简单的新技术是可能的。你或许能够说服他们更新技术、改善公司。</p><h2 id="4-混乱的代码"><a href="#4-混乱的代码" class="headerlink" title="4. 混乱的代码"></a>4. 混乱的代码</h2><p>这一条更多地是一种技术习惯，但也可能意味着很多事情。你应当以一种直观、高效、安全的方式写代码。这在自学的时候简直太难了，因为在相关的课程中，你学到的不是写某些代码的最佳方法，而是导师认为这么写最容易理解一些核心概念。所以，你必须进行一些额外的研究，找出清理你代码的最佳方法。</p><p>我绝对建议你使用“<strong>避免重复代码原则”（DRY principle，don’t repeat yourself</strong>）。如果你遇到常见的代码块，那就创建某种“类”（class）或“函数”（function）来合并这部分功能，而不是仅仅重复它。这让代码更加简洁，节省了大量代码行，并且便于他人使用。 你也要注意性能，比如压缩图片、缩小JavaScript和CSS。你可以使用task runner（如gulp）或其他工具自动完成压缩，面对小型任务，你甚至可以使用minifier.org等手动完成。</p><p>另外，不要进行不必要的API接口调用，要使你的全栈应用程序以尽可能少的请求完成你需要的全部功能。以及测试……我在这上面犯了很多错，没有做足够的测试。就我所知，单元测试有助于搭建更健全的应用程序，避免潜在问题，节约时间和开销。但我就是很讨厌它，这可能是我最坏的习惯之一，也是我成为更好的开发人员需要解决的大问题。有时候我们回了节约时间减少测试，但在现实中，这样做会降低应用程序的性能、效率和可读性，而且与一开始就采用正确的方法相比，它可能在将来引起更大的麻烦。所以请记住这一点。</p><h2 id="5-工作和生活的不平衡"><a href="#5-工作和生活的不平衡" class="headerlink" title="5. 工作和生活的不平衡"></a>5. 工作和生活的不平衡</h2><p>工作和生活的平衡真的很重要，尤其是当我们成家以后。不管什么类型的程序员都要花大量的时间在工作上，这有很多原因：事情总在发生变化；我们遇到的问题让我们寸步难行；我们需要研究这些问题等等……这就导致了很多时候，我们不得不工作到很晚、很早就开始工作、周末也加班。这会让你远离生活中的一切，比如你爱的人们、你的个人爱好。你可能喜欢运动、远足或是在外吃大餐，但假如你一直要加班，你就没法做这些让你快乐的事情。</p><p>我在这个领域有很多经验。我和妻子有两个孩子，其中一个患有自闭症，但我没法像我想的那样花大量的时间陪他们。我面临着双重困境，因为我既要处理编码问题，又要处理内容创作者的问题，要不断地提出新想法，有质量地记录下来等等。</p><p>如果你是自由职业者，为自己工作，所有的生计都取决于完成工作，你只有把所有的事情做完才能拿到报酬。有报酬，也就必然得承受持续不断的担忧：自己是否能跟上进度、自己能否完成任务。压力真的很大，让我们不得不把其他事情从我们生活中挤走。并不是说在公司工作的人就不会经历这些，而是说当你需要考虑所有的事情的时候，压力等级完全不同。所以我很同情那些有自己生意的人。</p><p>但即便如此，你也不能让它控制你的生活，你必须为你的家人和朋友留出时间，或者更坦率地说，为你自己留出时间。生活可远比写几行代码丰富多了。做你自己喜欢的事情，给你的生活带来平衡。</p><h2 id="6-糟糕的办公室政治"><a href="#6-糟糕的办公室政治" class="headerlink" title="6. 糟糕的办公室政治"></a>6. 糟糕的办公室政治</h2><p>这一条是给那些在公司工作的人们的。你和其他人一起工作，但这反过来又会引起冲突、分歧、争论等等。许多开发人员十分傲慢，总认为自己是正确的，即使他们知道自己犯了错，他们中的一些人也永远不会承认。我不是说这是大多数开发人员，但我认为我们至少会遇到一位这样的人。我听很多人说，他们的团队非常棒，成员之间相处得非常融洽，这很好，但不是所有团队都是这样子。</p><ul><li>很多时候你们会在想法和解决方案上发生冲突，试着表现得老练和对对方的尊重，但同时，也不要太容易就被说服，尤其是当你对自己的提案非常有信心的时候。</li><li>不要大喊大叫，不要骂人，千万别做这些事情，这什么用也没有。</li><li>如果他们开始这样对待你，你就离开，做一个更强大的人。</li><li>如果你不幸遇到了一个十足混蛋的团队成员，他完全不听理由，你除了想办法避开他之外，别无他法。</li><li>在某些情况下，你可能不得不和你们的领导交谈，不过我还是建议你先和那个人谈谈。</li></ul><h2 id="7-不能从错误中吸取教训"><a href="#7-不能从错误中吸取教训" class="headerlink" title="7. 不能从错误中吸取教训"></a>7. 不能从错误中吸取教训</h2><p>作为一位开发人员，你会犯很多错误，这不可避免也没什么大不了的。但如果你总是犯同样的错误，不能从中吸取教训，那就有问题了。</p><p>当你犯错后，我建议你遵从这样一个流程：</p><ul><li>找出错误的根本原因是什么；</li><li>找到可以防止错误再次出现的流程；</li><li>弄清楚如果早先发现了错误，能否避免后果。</li></ul><p>当你犯下大错，请你仔细思考一下这三件事，很有可能就不会再犯这个错误了，或者你至少下次会尽早发现错误，避免情况恶化。同时，不要因为犯错而对自己太苛刻，谁都会犯错。</p><h2 id="8-太早放弃"><a href="#8-太早放弃" class="headerlink" title="8. 太早放弃"></a>8. 太早放弃</h2><p>挫折是编程的重要环节。我制作了一些关于挫折及其应对的视频。我也见过很多人因为沮丧而在特定的项目和编程上过早言弃。一些项目确实特别难，似乎一旦你修复了一些bug，它就会导致另一个bug，bug复bug无穷尽也。你可能开始觉得自己处理不了，自己本可以去做别的，做这个就是浪费时间浪费生命浪费金钱……你开始产生很多消极的想法。如果你很快就放弃某个项目，或是很快辞职，那么拟投入到这个项目或工作中的一切都将化为泡影。</p><p>我并不是说你啥项目都不能放弃，只是我看过太多次人们在即将成功的前夜放弃了。所以在放弃之前，确保你试尽了所有可能：已经上下求索、寻求帮助、用遍方法、换个技术、休息很长一段时间让自己的思绪恢复正常、如果可能的话已经搁置了一段时间……你在放弃之前做了所有能做的事情，如果还是失败，那么也许是时候放弃它、继续前进了。成功可能就在眼前，如果你这时候放弃，真的太耻辱了。</p><h2 id="9-做一个无所不知的人"><a href="#9-做一个无所不知的人" class="headerlink" title="9. 做一个无所不知的人"></a>9. 做一个无所不知的人</h2><p>我之前提到过，我认为一些开发人员十分傲慢的原因是，他们认为自己无所不知。他们从不听其他人的意见，他们为啥要听呢？他们知道所有的答案。如果你周围全是这样的人，那真是糟透了，这对你也没好处，因为你也会认为自己无所不知，就会不积极学习、不改善自己。我敢打赌，总有一天你会被自己犯下的错误叫醒，这源于你不听取任何人的意见，也不自己进行调研。</p><p>这些人大多数都是Stack Overflow网站（一个IT技术问答网站）的魔鬼，他们取笑新开发人员的问题，嘲笑他人的回答，一有机会就点击“反对”。我讨厌死这些人了。我认为他们中的许多人在学校里就总是被人找茬，他们利用自己的知识欺负其他可能有问题或是没有所得的开发人员，看上去像是忘掉了被欺负的感受，只想要复仇。我这个理论可能有问题，只是一家之言。</p><p>无论他们出于什么原因这么做，我认为如果他们思想开放、欢迎不同的想法、尊重他人，那他们就会比总是想要“正确”的人快乐多了。他们可能是团队中最聪明的人，也是最糟糕的人，因为没人愿意和他们合作，无法进行良好的沟通。对于一个想要成功的团队来说，沟通和团结是必需的，而无所不知的人会破坏这些。所以，如果你是这样的人，试着别那么自负，开放一点，尊重一点，你会走得更远。</p><h2 id="10-不接受建设性批评"><a href="#10-不接受建设性批评" class="headerlink" title="10. 不接受建设性批评"></a>10. 不接受建设性批评</h2><p>最后一条和上一条有点联系，不能接受建设性批评。无所不知的魔鬼和真心想要帮助你的人之间还是有很大区别的。有时你很难看清这个区别，因为别人指出你的错误或者不完善的地方，你可能感觉不是那么好，感觉自己受到他人的攻击。</p><p>但很多情况下不是这样的，这只是某个人想教给你一个更好地方法，或是分享自己的意见。作为内容生产者，我花了很久才学会分辨挑事者和好心人。一开始，有人谈论我如何做某事的时候，我都很有戒心。但我意识到，他们中的许多人只是在试图提供合理的帮助。如果他们并非不尊重，或者只是对一些无关紧要的事情挑三拣四，那我就需要把它当做对我和对我的知识有益的东西。</p><p>建设性的批评是学习的绝佳资源，因为建设性的批评很有针对性，是你现有的问题，是他人给你的具体解决方案，这是无价的。事实上，代码审查简直太棒了，你可以得到其他人的建议，改进你的代码甚至是你自己。</p><p>所以不要把这类事情都看成人身攻击，除非你真的受到了攻击，或是故意的取笑和不尊重。听进别人的批评或改进建议总是很难，但最终，这会让你成为一个更棒的开发者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-休息不够&quot;&gt;&lt;a href=&quot;#1-休息不够&quot; class=&quot;headerlink&quot; title=&quot;1. 休息不够&quot;&gt;&lt;/a&gt;1. 休息不够&lt;/h2&gt;&lt;p&gt;我敢肯定你们很多人或者说几乎所有人都对这个坏习惯感到十分罪恶。我也是，对没有休息或休息不够依然有罪恶感。</summary>
      
    
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>高手养成</title>
    <link href="http://universeinheart.github.io/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/%E9%AB%98%E6%89%8B%E5%85%BB%E6%88%90/"/>
    <id>http://universeinheart.github.io/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/%E9%AB%98%E6%89%8B%E5%85%BB%E6%88%90/</id>
    <published>2021-04-17T15:16:37.000Z</published>
    <updated>2021-04-17T10:11:55.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、真正危险的是，人们总是高估今天的变化"><a href="#一、真正危险的是，人们总是高估今天的变化" class="headerlink" title="一、真正危险的是，人们总是高估今天的变化"></a>一、真正危险的是，人们总是高估今天的变化</h3><p>  <strong>与其过分追逐变化的外在，不如研究不变的规律与价值</strong><br>  如果不认识到这一点，你永远会像个陀螺一般，每天疲于奔命应付外在的变化，却很少沉下心来反思真正的问题出在哪里，你会被变化迷障了双眼，对未来越来越迷茫。<br>  正如有句话说的那样，人总有一种错觉，对“发生在现在的事”比对“将来会发生的事”更敏感，因此，<strong>人们往往倾向于夸大眼前的困难，或者夸大眼前的成绩。</strong><br>  那些口口声声为明天焦虑的人，他们担心的恰恰不是未来，而是他们高估了眼前的变化，去徒劳地追逐那些稍纵即逝的目标</p><h3 id="二、人生算法的核心：把未来建立在不变的基础上"><a href="#二、人生算法的核心：把未来建立在不变的基础上" class="headerlink" title="二、人生算法的核心：把未来建立在不变的基础上"></a>二、人生算法的核心：把未来建立在不变的基础上</h3><p>  <strong>人生就像滚雪球，重要的是发现很湿的雪和很长的坡</strong></p><p>  所谓职业危机的真相，本质上说来就是一个人永远停留在职业适应阶段，TA根本没有成功跨越适应期的问题，到达更高的层面；如果一个人能在任何领域修炼到了高手区，那么任何危机对这个高手而言只不过是换个玩法，说不定还蕴藏着不错的转机。</p><p><strong>举个简单的例子。</strong></p><p>在会计培训领域有很多名师，例如教会计的张志凤老师，请问他会担心职业危机的到来吗？不会。原因很简单。</p><p>因为他的收入来源由这几项构成：</p><p>1、张志凤老师的本职工作是北京信息科技大学经济管理学院的会计学教授，硕士生导师，这部分收入性质和很多人一样，都是工作带来的收入，属于<strong>劳动收入</strong>；</p><p>2、张志凤在工作期间潜心研究专业领域，发表了一系列的专著论文，在业界享有一定的声望与名气，与网校合作讲课，这是无形资产（个人影响力）给他带来的收入，属于<strong>资产类收入</strong>；</p><p>3、如果张志凤老师退休后创办会计师事务所，成为自负盈亏的企业法人，按照他的专业水平与名气，以及他的人缘及口碑，拓展业务并非难事，那么这部分收入则与市场风险直接关联，属于<strong>风险类收入</strong>，未来业务一旦步入正轨，收益也巨大；</p><p>4、如果张志凤老师退休后不想开事务所，也可以给很多公司做财务顾问，等等。</p><p>如此一来，你会发现张志凤老师永远都有路走，永远都不用担心职业危机。</p><p>  <strong>因此，想要在变化的世界里打造不变的竞争力，对于很多家境普通的“拼一代”而言，成为高手是一条靠谱的逆袭路径，它可以跨越阶层、直至改变自己的命运。</strong></p><h3 id="三、高手和普通人的差距到底在哪里？"><a href="#三、高手和普通人的差距到底在哪里？" class="headerlink" title="三、高手和普通人的差距到底在哪里？"></a>三、高手和普通人的差距到底在哪里？</h3><p><strong>想要成为高手，就需要了解高手与普通人的具体差异所在，才能找到正确的努力路径和方法。</strong></p><p>为了说明这个问题，我们以一名职业棋手的成长为例。</p><p>请问，如果一个人想要成为职业棋手，他要经过哪些训练和努力呢？</p><p>我猜你的回答可能是——<br>1、找一家培训机构，跟着专业的老师学习下棋<br>2、打比赛一路升级<br>3、成为职业棋手</p><p>  还不够，我们还要继续分析：如果这个人跟着老师学习下棋，需要学习哪些内容，又到底要经过哪些阶段呢？</p><p>  <strong>1、花大量的时间研究棋谱。</strong><br>  琢磨整盘棋大体有哪些布局，对手经常出哪些招数，对应的破解招数有哪些？<br>  因此多数时候，一名真正的专业棋手大部分时间恰恰不是和人下棋，而是一个人静静地对着棋盘摆棋谱，不断加深对棋谱的记忆和运用能力。</p><p>  <strong>2、大量重复的练习。</strong><br>  作为一名真正的棋手，主要的练习往往是记定式、打棋谱这种思维模式的训练，同时适时安排对弈，需要经过长时间的练习，才能真正掌握棋谱。</p><p>  <strong>3、及时反馈。</strong><br>  有一名教练至关重要，因为教练的主要作用就是以旁观者身份提供及时反馈，指出你可能无法意识到的盲区，渐渐地将棋谱内化到自己的脑海中，最终形成一个强大的神经网络结构，让你面对任何棋局都能游刃有余，最终成为专业棋手。</p><p>  而下棋里的棋谱，就是最核心的东西，叫做“<strong>模型或套路</strong>”。因此，想要成为真正的高手，最关键的一步就在于熟悉并掌握这个行业或领域的模型或套路。<br>  这种所谓的模型和套路，就像学画画的人一定要从素描学起，必须掌握起码的线条和结构，才能谈及深入学习，于是，这种模型和套路有一个耳熟能详的名字，<strong>基本功</strong>。<br>  这种基本功，无一不是经过了大量的学习和训练，因此，如果你真的想成为一个高手，最关键的一点就是，永远不要贪图捷径，所谓“21天成为专家”根本就是一个噱头——不肯真正下功夫去学去练，神仙也帮不了你！</p><h3 id="四、方法论：高手是怎样炼成的？"><a href="#四、方法论：高手是怎样炼成的？" class="headerlink" title="四、方法论：高手是怎样炼成的？"></a>四、方法论：高手是怎样炼成的？</h3><p> 一个人想要成为某个领域的高手离不开三大要素：</p><ul><li>一是基本功（也称套路和模型）</li><li>二是大量反复的练习</li><li>三是及时搜集反馈、不断反思和改进</li></ul><p>。</p><p>我们回到最开始的那个例子，类似于张志凤老师这样的会计培训专家又是如何炼成的呢？</p><h4 id="1、扎实的基本功"><a href="#1、扎实的基本功" class="headerlink" title="1、扎实的基本功"></a>1、扎实的基本功</h4><p>  譬如，张志凤老师毕业于首都经贸大学，1994年前往美国蒙哥马利奥本留学，1992年起开始从事会计职称考试培训工作，1997年起从事注册会计师考试辅导工作。</p><p>  任何一个领域的牛人，他的知识储备足够多，不仅仅体现在数量上，还体现在思考的质量上——你没想过的他都想过，你开始想的他早就研究过，你打算研究的他已经实践过。</p><p>  经过了学习、实践及思考，他的头脑对这一领域的知识已经<strong>高度系统化和抽象化</strong>，早就内化进了自己的大脑，渐渐地有了自己独特的看法与观点，并逐渐触及到了这个领域的<strong>本源和实质</strong>。</p><h4 id="2、大量重复的训练"><a href="#2、大量重复的训练" class="headerlink" title="2、大量重复的训练"></a>2、大量重复的训练</h4><p>  我所喜欢的一位作家叫余华，写过《许三观卖血记》、《活着》等好作品。他之前是一名牙医，当时牙医工作很辛苦，为了更舒服地生活，他开始到文化馆写小说。</p><p>  余华说：“一开始时，我连标点符号都不会用。根本不知道如何写，所以就先从短篇小说学习，那个过程很艰难。坐在书桌前，我脑子里什么内容都没有，但一直逼着自己往下写。我发现写作会让一个人变得自信，我第一部作品写得很差，但有几句话写得很好。第二部好像开始有故事了，然后再写第三部，就发表了。”</p><p>  用对话推动情节，对人物进行心理描写等都是一名小说作家的基本功，但余华却发现自己不会这些基本的技能，怎么办？为了练习这些技能，他也是很拼的：</p><p>  “看了威廉·福克纳一篇小说，故事是一个穷人把富人杀了，作家用了近一页纸去描写他刚杀完人后，他的女儿如何看他。作家用杀人者的眼睛去看，把杀人者的心态表现得非常到位。 就这样，经过大量反复的磨砺与死磕，余华终于成就了自己的梦想，成为了一名作家。</p><p>  要知道，不会有任何厉害的高手被训练丧失了灵气；但如果缺乏大量反复的训练，一个人很难成为高手。没有大量反复的训练，即便你天资再高也枉然.</p><h4 id="3、搜集反馈，不断反思与总结"><a href="#3、搜集反馈，不断反思与总结" class="headerlink" title="3、搜集反馈，不断反思与总结"></a>3、搜集反馈，不断反思与总结</h4><p>  很多职场人和我抱怨说，自己缺乏师傅或者教练在一旁给予专业的指点，但如果他们得知<strong>教练的主要作用是以旁观者身份提供及时反馈</strong>的话，那么在职场环境中，这个功能离开教练也同样可以由他人完成，例如你的同事、你的客户、你的领导等等。</p><p>  职场是人和人构成的江湖，在这个江湖里，你心里能装下多少人又能影响多少人，直接决定了你的江湖地位和威望。</p><p>  毫无疑问，一个心中时时有他人遇事愿意为他人着想的人，自然就不太容易受到情绪的困扰，因为遇到任何问题即便是不好的反馈，这些人的思考方向永远都是：如何做才能让对方感觉更便利更好呢？如此，这个人更能够集中精力和注意力放在服务他人方面，随着服务质量的提高，自己的口碑自然就提高了。</p><p>  从这个角度来说，如果领导批评了你，如果同事指出了你的不足，倘若你意识到自己真的存在不足，感激都还来不及，又有什么可委屈的呢？想想看，我们不正是通过这种反馈才能看见自己看不到的盲区，然后才能谈及改进和成长的吗？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、真正危险的是，人们总是高估今天的变化&quot;&gt;&lt;a href=&quot;#一、真正危险的是，人们总是高估今天的变化&quot; class=&quot;headerlink&quot; title=&quot;一、真正危险的是，人们总是高估今天的变化&quot;&gt;&lt;/a&gt;一、真正危险的是，人们总是高估今天的变化&lt;/h3&gt;&lt;</summary>
      
    
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>给程序员的建议</title>
    <link href="http://universeinheart.github.io/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/%E7%BB%99%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BB%BA%E8%AE%AE/"/>
    <id>http://universeinheart.github.io/2021/04/17/%E5%B0%8F%E5%86%8C%E5%AD%90/%E7%BB%99%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BB%BA%E8%AE%AE/</id>
    <published>2021-04-17T15:16:37.000Z</published>
    <updated>2021-04-17T10:11:50.655Z</updated>
    
    <content type="html"><![CDATA[<ol><li>想清楚，写清楚，说清楚，才是真正的清楚！</li><li>多花点时间沟通清楚需求，才能把握正确方向！</li><li>修复需求错误的成本是代码错误的几十倍！</li><li>程序员最大的坏习惯就是：急于动手写代码！</li><li>提高开发效率的捷径：一次做对，不返工！</li><li>写代码之前三件事：<ol><li>弄清楚做什么；</li><li>说清楚怎么做；</li><li>想清楚怎么测！</li></ol></li><li>职业的程序员设计程序，业余的程序员调试程序；</li><li>拷贝粘贴式的作业方式，最容易导入bug，最难调试！</li><li>重复代码是万恶之源！</li><li>小函数，小方法，以功能命名，可以消除注释！</li><li>做一点，测一点，测试驱动的开发，返工最少，返工最易；</li><li>一个方法的复杂度应该小于10，否则很难调试它！</li><li>随时重构代码，不遗留垃圾代码!</li><li>消除静态检查的warning和error！</li><li>职业的程序员是预防BUG，业余程序员是修改BUG；</li><li>经常总结自己的经验教训，写下来！汇总在一起！</li><li>任何复杂的问题都可以简化，两种简化的手段： 按时序拆分，按整体部分拆分；</li><li>每日构建，每日确认，尽早发现错误，尽早返工！</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;想清楚，写清楚，说清楚，才是真正的清楚！&lt;/li&gt;
&lt;li&gt;多花点时间沟通清楚需求，才能把握正确方向！&lt;/li&gt;
&lt;li&gt;修复需求错误的成本是代码错误的几十倍！&lt;/li&gt;
&lt;li&gt;程序员最大的坏习惯就是：急于动手写代码！&lt;/li&gt;
&lt;li&gt;提高开发效率的捷径：一</summary>
      
    
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="http://universeinheart.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>
